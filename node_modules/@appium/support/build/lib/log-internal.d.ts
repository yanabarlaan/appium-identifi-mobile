export default SECURE_VALUES_PREPROCESSOR;
export type Rule = {
    /**
     * A valid RegExp pattern to be replaced
     */
    pattern: string;
    /**
     * A text match to replace. Either this property or the
     * above one must be provided. `pattern` has priority over `text` if both are provided.
     */
    text: string;
    /**
     * Regular expression flags for the given pattern.
     * Supported flag are the same as for the standard JavaScript RegExp constructor:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Advanced_searching_with_flags_2
     * The 'g' (global matching) is always enabled though.
     */
    flags?: string | undefined;
    /**
     * The replacer value to use. By default
     * equals to `DEFAULT_SECURE_REPLACER`
     */
    replacer?: string | undefined;
};
export type SecureValuePreprocessingRule = {
    /**
     * The parsed pattern which is going to be used for replacement
     */
    pattern: RegExp;
    /**
     * The replacer value to use. By default
     * equals to `DEFAULT_SECURE_REPLACER`
     */
    replacer?: string | undefined;
};
export const SECURE_VALUES_PREPROCESSOR: SecureValuesPreprocessor;
export class SecureValuesPreprocessor {
    _rules: any[];
    /**
     * @returns {Array<SecureValuePreprocessingRule>} The list of successfully
     * parsed preprocessing rules
     */
    get rules(): SecureValuePreprocessingRule[];
    /**
     * Parses single rule from the given JSON file
     *
     * @param {string|Rule} rule The rule might either be represented as a single string
     * or a configuration object
     * @throws {Error} If there was an error while parsing the rule
     * @returns {SecureValuePreprocessingRule} The parsed rule
     */
    parseRule(rule: string | Rule): SecureValuePreprocessingRule;
    /**
     * Loads rules from the given JSON file
     *
     * @param {string|string[]|Rule[]} source The full path to the JSON file containing secure
     * values replacement rules or the rules themselves represented as an array
     * @throws {Error} If the format of the source file is invalid or
     * it does not exist
     * @returns {Promise<string[]>} The list of issues found while parsing each rule.
     * An empty list is returned if no rule parsing issues were found
     */
    loadRules(source: string | string[] | Rule[]): Promise<string[]>;
    /**
     * Performs secure values replacement inside the given string
     * according to the previously loaded rules. No replacement is made
     * if there are no rules or the given value is not a string
     *
     * @param {string} str The string to make replacements in
     * @returns {string} The string with replacements made
     */
    preprocess(str: string): string;
}
//# sourceMappingURL=log-internal.d.ts.map