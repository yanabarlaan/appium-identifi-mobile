export type W3CCapabilities = import('@appium/types').W3CCapabilities;
export type Constraints = import('@appium/types').Constraints;
export type Capabilities = import('@appium/types').Capabilities;
export type ValidateCapsOpts = {
    /**
     * - if true, skip the presence constraint
     */
    skipPresenceConstraint?: boolean | undefined;
};
/**
 *
 * @param {W3CCapabilities} caps
 * @param {Constraints} [constraints]
 * @param {boolean} [shouldValidateCaps]
 * @returns
 */
export function parseCaps(caps: W3CCapabilities, constraints?: import("@appium/types").Constraints | undefined, shouldValidateCaps?: boolean | undefined): {
    requiredCaps: Partial<import("@wdio/types/build/Capabilities").Capabilities & import("@wdio/types/build/Capabilities").AppiumW3CCapabilities & {
        [x: `${string}:${string}`]: any;
    }>;
    allFirstMatchCaps: Partial<import("@wdio/types/build/Capabilities").Capabilities & import("@wdio/types/build/Capabilities").AppiumW3CCapabilities & {
        [x: `${string}:${string}`]: any;
    }>[];
    validatedFirstMatchCaps: Partial<import("@wdio/types/build/Capabilities").Capabilities & import("@wdio/types/build/Capabilities").AppiumCapabilities & {
        [x: string]: any;
    }>[];
    matchedCaps: Partial<import("@wdio/types/build/Capabilities").Capabilities & import("@wdio/types/build/Capabilities").AppiumCapabilities & {
        [x: string]: any;
    }> | null;
    validationErrors: any[];
};
/**
 *
 * @param {W3CCapabilities} w3cCaps
 * @param {Constraints} [constraints]
 * @param {boolean} [shouldValidateCaps]
 * @returns {Capabilities}
 */
export function processCapabilities(w3cCaps: W3CCapabilities, constraints?: import("@appium/types").Constraints | undefined, shouldValidateCaps?: boolean | undefined): Capabilities;
/**
 *
 * @param {Capabilities} caps
 * @param {Constraints} [constraints]
 * @param {ValidateCapsOpts} [opts]
 * @returns {Capabilities}
 */
export function validateCaps(caps: Capabilities, constraints?: import("@appium/types").Constraints | undefined, opts?: ValidateCapsOpts | undefined): Capabilities;
/**
 * @param {Capabilities} [primary]
 * @param {Capabilities} [secondary]
 * @returns {Capabilities}
 */
export function mergeCaps(primary?: Partial<import("@wdio/types/build/Capabilities").Capabilities & import("@wdio/types/build/Capabilities").AppiumCapabilities & {
    [x: string]: any;
}> | undefined, secondary?: Partial<import("@wdio/types/build/Capabilities").Capabilities & import("@wdio/types/build/Capabilities").AppiumCapabilities & {
    [x: string]: any;
}> | undefined): Capabilities;
export const APPIUM_VENDOR_PREFIX: "appium:";
export const APPIUM_OPTS_CAP: "options";
/**
 * Get an array of all the unprefixed caps that are being used in 'alwaysMatch' and all of the 'firstMatch' object
 * @param {Object} caps A capabilities object
 */
export function findNonPrefixedCaps({ alwaysMatch, firstMatch }: any): string[];
export function isStandardCap(cap: any): boolean;
export function stripAppiumPrefixes(caps: any): void;
/**
 * Return a copy of a capabilities object which has taken everything within the 'options'
 * capability and promoted it to the top level. Note that this function is assumed to be run after
 * all vendor prefixes have already been stripped from the top level. So we are dealing with e.g.
 * 'options' and not 'appium:options' at this point. Any prefixes _inside_ the 'options' capability
 * will themselves be stripped. This is designed as an internal function, not one to operate on
 * user-constructed capabilities.
 *
 * @param {object} originalCaps - the capabilities to analyze and promote from 'options'
 * @return {object!} - the capabilities with 'options' promoted if necessary
 */
export function promoteAppiumOptions(originalCaps: object): object;
export const PREFIXED_APPIUM_OPTS_CAP: string;
//# sourceMappingURL=capabilities.d.ts.map