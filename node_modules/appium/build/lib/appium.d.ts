/**
 * Thrown when Appium tried to proxy a command using a driver's `proxyCommand` method but the
 * method did not exist
 */
export class NoDriverProxyCommandError extends Error {
    constructor();
    /**
     * @type {Readonly<string>}
     */
    code: Readonly<string>;
}
export type ExternalDriver = import('@appium/types').ExternalDriver;
export type W3CCapabilities = import('@appium/types').W3CCapabilities;
export type DriverData = import('@appium/types').DriverData;
export type DriverOpts = import('@appium/types').ServerArgs;
export type Constraints = import('@appium/types').Constraints;
export type AppiumServer = import('@appium/types').AppiumServer;
export type ExtensionType = import('../types').ExtensionType;
export type PluginClass = import('../types/extension').PluginClass;
export type DriverConfig = import('./extension/driver-config').DriverConfig;
/**
 * Used by {@linkcode AppiumDriver.createSession } and {@linkcode AppiumDriver.deleteSession } to describe
 * result.
 */
export type SessionHandlerResult<V> = {
    value?: V | undefined;
    error?: Error | undefined;
    protocol?: string | undefined;
};
export type SessionHandler = import('@appium/types').SessionHandler<SessionHandlerResult<any[]>, SessionHandlerResult<void>>;
/**
 * @implements {SessionHandler}
 */
export class AppiumDriver extends DriverCore implements SessionHandler {
    /**
     * @param {DriverOpts} opts
     */
    constructor(opts: DriverOpts);
    /**
     * Access to sessions list must be guarded with a Semaphore, because
     * it might be changed by other async calls at any time
     * It is not recommended to access this property directly from the outside
     * @type {Record<string,ExternalDriver>}
     */
    sessions: Record<string, ExternalDriver>;
    /**
     * Access to pending drivers list must be guarded with a Semaphore, because
     * it might be changed by other async calls at any time
     * It is not recommended to access this property directly from the outside
     * @type {Record<string,ExternalDriver[]>}
     */
    pendingDrivers: Record<string, ExternalDriver[]>;
    /**
     * List of active plugins
     * @type {PluginClass[]}
     */
    pluginClasses: PluginClass[];
    /**
     * map of sessions to actual plugin instances per session
     * @type {Record<string,InstanceType<PluginClass>[]>}
     */
    sessionPlugins: Record<string, InstanceType<PluginClass>[]>;
    /**
     * some commands are sessionless, so we need a set of plugins for them
     * @type {InstanceType<PluginClass>[]}
     */
    sessionlessPlugins: InstanceType<PluginClass>[];
    /** @type {DriverConfig} */
    driverConfig: DriverConfig;
    /** @type {AppiumServer} */
    server: AppiumServer;
    desiredCapConstraints: Readonly<import("@appium/types").Constraints>;
    args: {
        address: string;
        allowCors: boolean;
        allowInsecure: import("@appium/types").AllowInsecureConfig;
        basePath: string;
        callbackAddress: string | undefined;
        callbackPort: number;
        debugLogSpacing: boolean;
        defaultCapabilities: import("@appium/types").DefaultCapabilitiesConfig | undefined;
        denyInsecure: import("@appium/types").DenyInsecureConfig;
        driver: import("@appium/types").DriverConfig | undefined;
        keepAliveTimeout: number;
        localTimezone: boolean;
        logFile: string | undefined;
        logFilters: import("@appium/types").LogFiltersConfig | undefined;
        loglevel: import("@appium/types").LogLevelConfig;
        logNoColors: boolean;
        logTimestamp: boolean;
        longStacktrace: boolean;
        noPermsCheck: boolean;
        nodeconfig: import("@appium/types").NodeconfigConfig | undefined;
        plugin: import("@appium/types").PluginConfig | undefined;
        port: number;
        relaxedSecurityEnabled: boolean;
        sessionOverride: boolean;
        strictCaps: boolean;
        tmpDir: string | undefined;
        traceDir: string | undefined;
        useDrivers: import("@appium/types").UseDriversConfig;
        usePlugins: import("@appium/types").UsePluginsConfig;
        webhook: string | undefined;
    };
    sessionExists(sessionId: any): boolean;
    driverForSession(sessionId: any): import("@appium/types").ExternalDriver;
    getStatus(): Promise<{
        build: import("../types").BuildInfo;
    }>;
    getSessions(): Promise<{
        id: string;
        capabilities: Partial<import("@wdio/types/build/Capabilities").Capabilities & import("@wdio/types/build/Capabilities").AppiumCapabilities & {
            [x: string]: any;
        }> | undefined;
    }[]>;
    printNewSessionAnnouncement(driverName: any, driverVersion: any, driverBaseVersion: any): void;
    /**
     * Validate and assign CLI args for a driver or plugin
     *
     * If the extension has provided a schema, validation has already happened.
     *
     * Any arg which is equal to its default value will not be assigned to the extension.
     * @param {ExtensionType} extType 'driver' or 'plugin'
     * @param {string} extName the name of the extension
     * @param {Object} extInstance the driver or plugin instance
     */
    assignCliArgsToExtension(extType: ExtensionType, extName: string, extInstance: any): void;
    /**
     * Create a new session
     * @param {W3CCapabilities} jsonwpCaps JSONWP formatted desired capabilities
     * @param {W3CCapabilities} reqCaps Required capabilities (JSONWP standard)
     * @param {W3CCapabilities} w3cCapabilities W3C capabilities
     * @param {import('@appium/types').DriverData[]} [driverData]
     */
    createSession(jsonwpCaps: W3CCapabilities, reqCaps: W3CCapabilities, w3cCapabilities: W3CCapabilities, driverData?: import("@appium/types").DriverData[] | undefined): Promise<{
        protocol: any;
        error: any;
        value?: undefined;
    } | {
        protocol: any;
        value: any[];
        error?: undefined;
    }>;
    attachUnexpectedShutdownHandler(driver: any, innerSessionId: any): void;
    /**
     *
     * @param {import('../types/extension').DriverClass} InnerDriver
     * @returns {Promise<DriverData[]>}}
     */
    curSessionDataForDriver(InnerDriver: BaseDriverBase<import("@appium/types").ExternalDriver, import("../types").ExternalDriverStatic>): Promise<DriverData[]>;
    /**
     * @param {string} sessionId
     */
    deleteSession(sessionId: string): Promise<{
        protocol: undefined;
        value: void;
        error?: undefined;
    } | {
        protocol: undefined;
        error: any;
        value?: undefined;
    }>;
    deleteAllSessions(opts?: {}): Promise<void>;
    /**
     * Get the appropriate plugins for a session (or sessionless plugins)
     *
     * @param {?string} sessionId - the sessionId (or null) to use to find plugins
     * @returns {Array} - array of plugin instances
     */
    pluginsForSession(sessionId?: string | null): any[];
    /**
     * To get plugins for a command, we either get the plugin instances associated with the
     * particular command's session, or in the case of sessionless plugins, pull from the set of
     * plugin instances reserved for sessionless commands (and we lazily create plugin instances on
     * first use)
     *
     * @param {string} cmd - the name of the command to find a plugin to handle
     * @param {?string} sessionId - the particular session for which to find a plugin, or null if
     * sessionless
     */
    pluginsToHandleCmd(cmd: string, sessionId?: string | null): any[];
    createPluginInstances(): import("../types").PluginProto[];
    /**
     *
     * @param {string} cmd
     * @param  {...any} args
     * @returns {Promise<{value: any, error?: Error, protocol: string} | import('type-fest').AsyncReturnType<import('@appium/types').Driver['executeCommand']>>}
     */
    executeCommand(cmd: string, ...args: any[]): Promise<any>;
    wrapCommandWithPlugins({ driver, cmd, args, next, cmdHandledBy, plugins }: {
        driver: any;
        cmd: any;
        args: any;
        next: any;
        cmdHandledBy: any;
        plugins: any;
    }): any;
    logPluginHandlerReport(plugins: any, { cmd, cmdHandledBy }: {
        cmd: any;
        cmdHandledBy: any;
    }): void;
    executeWrappedCommand({ wrappedCmd, protocol }: {
        wrappedCmd: any;
        protocol: any;
    }): Promise<{
        value: any;
        error: any;
        protocol: any;
    }>;
    proxyActive(sessionId: any): boolean;
    getProxyAvoidList(sessionId: any): [string, RegExp][];
    canProxy(sessionId: any): boolean;
}
import { DriverCore } from "@appium/base-driver";
//# sourceMappingURL=appium.d.ts.map