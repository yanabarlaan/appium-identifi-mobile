/**
 * @extends {ExtensionConfig<DriverType>}
 */
export class DriverConfig extends ExtensionConfig<"driver"> {
    /**
     * A mapping of {@link Manifest} instances to {@link DriverConfig} instances.
     *
     * `Manifest` and `ExtensionConfig` have a one-to-many relationship; each `Manifest` should be associated with a `DriverConfig` and a `PluginConfig`; no more, no less.
     *
     * This variable tracks the `Manifest`-to-`DriverConfig` portion.
     *
     * @type {WeakMap<Manifest,DriverConfig>}
     * @private
     */
    private static _instances;
    /**
     * Creates a new {@link DriverConfig} instance for a {@link Manifest} instance.
     *
     * @param {Manifest} manifest
     * @param {DriverConfigOptions} [opts]
     * @throws If `manifest` already associated with a `DriverConfig`
     * @returns {DriverConfig}
     */
    static create(manifest: Manifest, { extData, logFn }?: DriverConfigOptions | undefined): DriverConfig;
    /**
     * Returns a DriverConfig associated with a Manifest
     * @param {Manifest} manifest
     * @returns {DriverConfig|undefined}
     */
    static getInstance(manifest: Manifest): DriverConfig | undefined;
    /**
    * Call {@link DriverConfig.create} instead.
    * @private
    * @param {import('./manifest').Manifest} manifest - Manifest instance
    * @param {DriverConfigOptions} [opts]
    */
    private constructor();
    /**
     * A set of unique automation names used by drivers.
     * @type {Set<string>}
     */
    knownAutomationNames: Set<string>;
    /**
    * Given capabilities, find a matching driver within the config. Load its class and return it along with version and driver name.
    * @param {Capabilities} caps
    * @returns {MatchedDriver}
    */
    findMatchingDriver({ automationName, platformName }: Capabilities): MatchedDriver;
    /**
    * Given an automation name and platform name, find a suitable driver and return its extension data.
    * @param {string} matchAutomationName
    * @param {string} matchPlatformName
    * @returns {ExtMetadata<DriverType> & import('../../types/appium-manifest').InternalMetadata & import('../../types/external-manifest').CommonMetadata}
    */
    _getDriverBySupport(matchAutomationName: string, matchPlatformName: string): ExtMetadata<DriverType> & import('../../types/appium-manifest').InternalMetadata & import('../../types/external-manifest').CommonMetadata;
}
export type DriverConfigOptions = {
    /**
     * - Optional logging function
     */
    logFn?: import("./extension-config").ExtensionLogFn | undefined;
    /**
     * - Extension data
     */
    extData?: import("../../types").DriverRecord | undefined;
};
export type ExtMetadata<T> = import('../../types').ExtMetadata<T>;
export type ExtManifest<T> = import('../../types').ExtManifest<T>;
export type ManifestData = import('../../types').ManifestData;
export type DriverType = import('../../types').DriverType;
export type Manifest = import('./manifest').Manifest;
export type ExtRecord<T> = import('../../types').ExtRecord<T>;
export type ExtName<T> = import('../../types').ExtName<T>;
/**
 * Return value of {@linkcode DriverConfig.findMatchingDriver }
 */
export type MatchedDriver = {
    driver: BaseDriverBase<import("@appium/types").ExternalDriver, import("../../types").ExternalDriverStatic>;
    version: string;
    driverName: string;
};
export type Capabilities = import('@appium/types').Capabilities;
import { ExtensionConfig } from "./extension-config";
//# sourceMappingURL=driver-config.d.ts.map