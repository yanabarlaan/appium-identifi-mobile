"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.packageDidChange = packageDidChange;

require("source-map-support/register");

var _support = require("@appium/support");

var _packageChanged = require("package-changed");

var _path = _interopRequireDefault(require("path"));

var _constants = require("../constants");

var _logger = _interopRequireDefault(require("../logger"));

async function packageDidChange(appiumHome) {
  const hashFilename = _path.default.join(appiumHome, _constants.PKG_HASHFILE_RELATIVE_PATH);

  let isChanged;
  let writeHash;
  let hash;
  let oldHash;

  const hashFilenameDir = _path.default.dirname(hashFilename);

  _logger.default.debug(`Creating hash file directory: ${hashFilenameDir}`);

  try {
    await _support.fs.mkdirp(hashFilenameDir);
  } catch (err) {
    throw new Error(`Appium could not create the directory for hash file: ${hashFilenameDir}. Original error: ${err.message}`);
  }

  try {
    ({
      isChanged,
      writeHash,
      oldHash,
      hash
    } = await (0, _packageChanged.isPackageChanged)({
      cwd: appiumHome,
      hashFilename: _constants.PKG_HASHFILE_RELATIVE_PATH
    }));
  } catch {
    return true;
  }

  if (isChanged) {
    try {
      var _oldHash;

      writeHash();

      _logger.default.debug(`Updated hash of ${appiumHome}/package.json from: ${(_oldHash = oldHash) !== null && _oldHash !== void 0 ? _oldHash : '(none)'} to: ${hash}`);
    } catch (err) {
      throw new Error(`Appium could not write hash file: ${hashFilenameDir}. Original error: ${err.message}`);
    }
  }

  return isChanged;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwYWNrYWdlRGlkQ2hhbmdlIiwiYXBwaXVtSG9tZSIsImhhc2hGaWxlbmFtZSIsInBhdGgiLCJqb2luIiwiUEtHX0hBU0hGSUxFX1JFTEFUSVZFX1BBVEgiLCJpc0NoYW5nZWQiLCJ3cml0ZUhhc2giLCJoYXNoIiwib2xkSGFzaCIsImhhc2hGaWxlbmFtZURpciIsImRpcm5hbWUiLCJsb2ciLCJkZWJ1ZyIsImZzIiwibWtkaXJwIiwiZXJyIiwiRXJyb3IiLCJtZXNzYWdlIiwiY3dkIl0sInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2V4dGVuc2lvbi9wYWNrYWdlLWNoYW5nZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBmcyB9IGZyb20gJ0BhcHBpdW0vc3VwcG9ydCc7XG5pbXBvcnQgeyBpc1BhY2thZ2VDaGFuZ2VkIH0gZnJvbSAncGFja2FnZS1jaGFuZ2VkJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgUEtHX0hBU0hGSUxFX1JFTEFUSVZFX1BBVEggfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgZXh0ZW5zaW9ucyBoYXZlIGNoYW5nZWQsIGFuZCB1cGRhdGVzIGEgaGFzaCB0aGUgYHBhY2thZ2UuanNvbmAgaW4gYGFwcGl1bUhvbWVgIGlmIHNvLlxuICpcbiAqIElmIHRoZXkgaGF2ZSwgd2UgbmVlZCB0byBzeW5jIHRoZW0gd2l0aCB0aGUgYGV4dGVuc2lvbnMueWFtbGAgbWFuaWZlc3QuXG4gKlxuICogX1dhcm5pbmc6IHRoaXMgbWFrZXMgYSBibG9ja2luZyBjYWxsIHRvIGB3cml0ZUZpbGVTeW5jYC5fXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwaXVtSG9tZVxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IGB0cnVlYCBpZiBgcGFja2FnZS5qc29uYCBgYXBwaXVtSG9tZWAgY2hhbmdlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFja2FnZURpZENoYW5nZSAoYXBwaXVtSG9tZSkge1xuICBjb25zdCBoYXNoRmlsZW5hbWUgPSBwYXRoLmpvaW4oYXBwaXVtSG9tZSwgUEtHX0hBU0hGSUxFX1JFTEFUSVZFX1BBVEgpO1xuXG4gIC8vIFhYWDogdGhlIHR5cGVzIGluIGBwYWNrYWdlLWNoYW5nZWRgIHNlZW0gdG8gYmUgd3JvbmcuXG5cbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBsZXQgaXNDaGFuZ2VkO1xuICAvKiogQHR5cGUgeygpID0+IHZvaWR9ICovXG4gIGxldCB3cml0ZUhhc2g7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQgaGFzaDtcbiAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICBsZXQgb2xkSGFzaDtcblxuICAvLyBmaXJzdCBta2RpcnAgdGhlIHRhcmdldCBkaXIuXG4gIGNvbnN0IGhhc2hGaWxlbmFtZURpciA9IHBhdGguZGlybmFtZShoYXNoRmlsZW5hbWUpO1xuICBsb2cuZGVidWcoYENyZWF0aW5nIGhhc2ggZmlsZSBkaXJlY3Rvcnk6ICR7aGFzaEZpbGVuYW1lRGlyfWApO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLm1rZGlycChoYXNoRmlsZW5hbWVEaXIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXBwaXVtIGNvdWxkIG5vdCBjcmVhdGUgdGhlIGRpcmVjdG9yeSBmb3IgaGFzaCBmaWxlOiAke2hhc2hGaWxlbmFtZURpcn0uIE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgKHtpc0NoYW5nZWQsIHdyaXRlSGFzaCwgb2xkSGFzaCwgaGFzaH0gPSBhd2FpdCBpc1BhY2thZ2VDaGFuZ2VkKHtcbiAgICAgIGN3ZDogYXBwaXVtSG9tZSxcbiAgICAgIGhhc2hGaWxlbmFtZTogUEtHX0hBU0hGSUxFX1JFTEFUSVZFX1BBVEgsXG4gICAgfSkpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc0NoYW5nZWQpIHtcbiAgICB0cnkge1xuICAgICAgd3JpdGVIYXNoKCk7XG4gICAgICBsb2cuZGVidWcoYFVwZGF0ZWQgaGFzaCBvZiAke2FwcGl1bUhvbWV9L3BhY2thZ2UuanNvbiBmcm9tOiAke29sZEhhc2ggPz8gJyhub25lKSd9IHRvOiAke2hhc2h9YCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBcHBpdW0gY291bGQgbm90IHdyaXRlIGhhc2ggZmlsZTogJHtoYXNoRmlsZW5hbWVEaXJ9LiBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDaGFuZ2VkO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQVdPLGVBQWVBLGdCQUFmLENBQWlDQyxVQUFqQyxFQUE2QztFQUNsRCxNQUFNQyxZQUFZLEdBQUdDLGNBQUtDLElBQUwsQ0FBVUgsVUFBVixFQUFzQkkscUNBQXRCLENBQXJCOztFQUtBLElBQUlDLFNBQUo7RUFFQSxJQUFJQyxTQUFKO0VBRUEsSUFBSUMsSUFBSjtFQUVBLElBQUlDLE9BQUo7O0VBR0EsTUFBTUMsZUFBZSxHQUFHUCxjQUFLUSxPQUFMLENBQWFULFlBQWIsQ0FBeEI7O0VBQ0FVLGdCQUFJQyxLQUFKLENBQVcsaUNBQWdDSCxlQUFnQixFQUEzRDs7RUFDQSxJQUFJO0lBQ0YsTUFBTUksWUFBR0MsTUFBSCxDQUFVTCxlQUFWLENBQU47RUFDRCxDQUZELENBRUUsT0FBT00sR0FBUCxFQUFZO0lBQ1osTUFBTSxJQUFJQyxLQUFKLENBQ0gsd0RBQXVEUCxlQUFnQixxQkFBb0JNLEdBQUcsQ0FBQ0UsT0FBUSxFQURwRyxDQUFOO0VBR0Q7O0VBRUQsSUFBSTtJQUNGLENBQUM7TUFBQ1osU0FBRDtNQUFZQyxTQUFaO01BQXVCRSxPQUF2QjtNQUFnQ0Q7SUFBaEMsSUFBd0MsTUFBTSxzQ0FBaUI7TUFDOURXLEdBQUcsRUFBRWxCLFVBRHlEO01BRTlEQyxZQUFZLEVBQUVHO0lBRmdELENBQWpCLENBQS9DO0VBSUQsQ0FMRCxDQUtFLE1BQU07SUFDTixPQUFPLElBQVA7RUFDRDs7RUFFRCxJQUFJQyxTQUFKLEVBQWU7SUFDYixJQUFJO01BQUE7O01BQ0ZDLFNBQVM7O01BQ1RLLGdCQUFJQyxLQUFKLENBQVcsbUJBQWtCWixVQUFXLHVCQUE5QixZQUFvRFEsT0FBcEQsK0NBQStELFFBQVMsUUFBT0QsSUFBSyxFQUE5RjtJQUNELENBSEQsQ0FHRSxPQUFPUSxHQUFQLEVBQVk7TUFDWixNQUFNLElBQUlDLEtBQUosQ0FDSCxxQ0FBb0NQLGVBQWdCLHFCQUFvQk0sR0FBRyxDQUFDRSxPQUFRLEVBRGpGLENBQU47SUFHRDtFQUNGOztFQUVELE9BQU9aLFNBQVA7QUFDRCJ9