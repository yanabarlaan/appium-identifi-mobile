"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateXcodeConfigFile = generateXcodeConfigFile;
exports.getAdditionalRunContent = getAdditionalRunContent;
exports.getPIDsListeningOnPort = getPIDsListeningOnPort;
exports.getWDAUpgradeTimestamp = getWDAUpgradeTimestamp;
exports.getXctestrunFileName = getXctestrunFileName;
exports.getXctestrunFilePath = getXctestrunFilePath;
exports.isTvOS = isTvOS;
exports.killAppUsingPattern = killAppUsingPattern;
exports.killProcess = killProcess;
exports.randomInt = randomInt;
exports.resetProjectFile = resetProjectFile;
exports.resetTestProcesses = resetTestProcesses;
exports.setRealDeviceSecurity = setRealDeviceSecurity;
exports.setXctestrunFile = setXctestrunFile;
exports.updateProjectFile = updateProjectFile;

require("source-map-support/register");

var _support = require("@appium/support");

var _teen_process = require("teen_process");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("./logger"));

var _lodash = _interopRequireDefault(require("lodash"));

var _constants = require("./constants");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _asyncbox = require("asyncbox");

const ROOT_DIR = _path.default.basename(__dirname) === 'lib' ? _path.default.resolve(__dirname, process.env.NO_PRECOMPILE ? '..' : '../..') : __dirname;
const PROJECT_FILE = 'project.pbxproj';

async function getPIDsUsingPattern(pattern) {
  const args = ['-if', pattern];

  try {
    const {
      stdout
    } = await (0, _teen_process.exec)('pgrep', args);
    return stdout.split(/\s+/).map(x => parseInt(x, 10)).filter(_lodash.default.isInteger).map(x => `${x}`);
  } catch (err) {
    _logger.default.debug(`'pgrep ${args.join(' ')}' didn't detect any matching processes. Return code: ${err.code}`);

    return [];
  }
}

async function killAppUsingPattern(pgrepPattern) {
  const signals = [2, 15, 9];

  for (const signal of signals) {
    const matchedPids = await getPIDsUsingPattern(pgrepPattern);

    if (_lodash.default.isEmpty(matchedPids)) {
      return;
    }

    const args = [`-${signal}`, ...matchedPids];

    try {
      await (0, _teen_process.exec)('kill', args);
    } catch (err) {
      _logger.default.debug(`kill ${args.join(' ')} -> ${err.message}`);
    }

    if (signal === _lodash.default.last(signals)) {
      return;
    }

    try {
      await (0, _asyncbox.waitForCondition)(async () => {
        const pidCheckPromises = matchedPids.map(pid => (0, _teen_process.exec)('kill', ['-0', pid]).then(() => false).catch(() => true));
        return (await _bluebird.default.all(pidCheckPromises)).every(x => x === true);
      }, {
        waitMs: 1000,
        intervalMs: 100
      });
      return;
    } catch (ign) {}
  }
}

function isTvOS(platformName) {
  return _lodash.default.toLower(platformName) === _lodash.default.toLower(_constants.PLATFORM_NAME_TVOS);
}

async function replaceInFile(file, find, replace) {
  let contents = await _support.fs.readFile(file, 'utf8');
  let newContents = contents.replace(find, replace);

  if (newContents !== contents) {
    await _support.fs.writeFile(file, newContents, 'utf8');
  }
}

async function updateProjectFile(agentPath, newBundleId) {
  let projectFilePath = _path.default.resolve(agentPath, PROJECT_FILE);

  try {
    await _support.fs.copyFile(projectFilePath, `${projectFilePath}.old`);
    await replaceInFile(projectFilePath, new RegExp(_lodash.default.escapeRegExp(_constants.WDA_RUNNER_BUNDLE_ID), 'g'), newBundleId);

    _logger.default.debug(`Successfully updated '${projectFilePath}' with bundle id '${newBundleId}'`);
  } catch (err) {
    _logger.default.debug(`Error updating project file: ${err.message}`);

    _logger.default.warn(`Unable to update project file '${projectFilePath}' with ` + `bundle id '${newBundleId}'. WebDriverAgent may not start`);
  }
}

async function resetProjectFile(agentPath) {
  const projectFilePath = _path.default.join(agentPath, PROJECT_FILE);

  try {
    if (!(await _support.fs.exists(`${projectFilePath}.old`))) {
      return;
    }

    await _support.fs.mv(`${projectFilePath}.old`, projectFilePath);

    _logger.default.debug(`Successfully reset '${projectFilePath}' with bundle id '${_constants.WDA_RUNNER_BUNDLE_ID}'`);
  } catch (err) {
    _logger.default.debug(`Error resetting project file: ${err.message}`);

    _logger.default.warn(`Unable to reset project file '${projectFilePath}' with ` + `bundle id '${_constants.WDA_RUNNER_BUNDLE_ID}'. WebDriverAgent has been ` + `modified and not returned to the original state.`);
  }
}

async function setRealDeviceSecurity(keychainPath, keychainPassword) {
  _logger.default.debug('Setting security for iOS device');

  await (0, _teen_process.exec)('security', ['-v', 'list-keychains', '-s', keychainPath]);
  await (0, _teen_process.exec)('security', ['-v', 'unlock-keychain', '-p', keychainPassword, keychainPath]);
  await (0, _teen_process.exec)('security', ['set-keychain-settings', '-t', '3600', '-l', keychainPath]);
}

async function generateXcodeConfigFile(orgId, signingId) {
  _logger.default.debug(`Generating xcode config file for orgId '${orgId}' and signingId ` + `'${signingId}'`);

  const contents = `DEVELOPMENT_TEAM = ${orgId}
CODE_SIGN_IDENTITY = ${signingId}
`;
  const xcconfigPath = await _support.tempDir.path('appium-temp.xcconfig');

  _logger.default.debug(`Writing xcode config file to ${xcconfigPath}`);

  await _support.fs.writeFile(xcconfigPath, contents, 'utf8');
  return xcconfigPath;
}

async function setXctestrunFile(deviceInfo, sdkVersion, bootstrapPath, wdaRemotePort) {
  const xctestrunFilePath = await getXctestrunFilePath(deviceInfo, sdkVersion, bootstrapPath);
  const xctestRunContent = await _support.plist.parsePlistFile(xctestrunFilePath);
  const updateWDAPort = getAdditionalRunContent(deviceInfo.platformName, wdaRemotePort);

  const newXctestRunContent = _lodash.default.merge(xctestRunContent, updateWDAPort);

  await _support.plist.updatePlistFile(xctestrunFilePath, newXctestRunContent, true);
  return xctestrunFilePath;
}

function getAdditionalRunContent(platformName, wdaRemotePort) {
  const runner = `WebDriverAgentRunner${isTvOS(platformName) ? '_tvOS' : ''}`;
  return {
    [runner]: {
      EnvironmentVariables: {
        USE_PORT: `${wdaRemotePort}`
      }
    }
  };
}

async function getXctestrunFilePath(deviceInfo, sdkVersion, bootstrapPath) {
  const sdkBased = [_path.default.resolve(bootstrapPath, `${deviceInfo.udid}_${sdkVersion}.xctestrun`), sdkVersion];
  const platformBased = [_path.default.resolve(bootstrapPath, `${deviceInfo.udid}_${deviceInfo.platformVersion}.xctestrun`), deviceInfo.platformVersion];

  for (const [filePath, version] of [sdkBased, platformBased]) {
    if (await _support.fs.exists(filePath)) {
      _logger.default.info(`Using '${filePath}' as xctestrun file`);

      return filePath;
    }

    const originalXctestrunFile = _path.default.resolve(bootstrapPath, getXctestrunFileName(deviceInfo, version));

    if (await _support.fs.exists(originalXctestrunFile)) {
      await _support.fs.copyFile(originalXctestrunFile, filePath);

      _logger.default.info(`Using '${filePath}' as xctestrun file copied by '${originalXctestrunFile}'`);

      return filePath;
    }
  }

  _logger.default.errorAndThrow(`If you are using 'useXctestrunFile' capability then you ` + `need to have a xctestrun file (expected: ` + `'${_path.default.resolve(bootstrapPath, getXctestrunFileName(deviceInfo, sdkVersion))}')`);
}

function getXctestrunFileName(deviceInfo, version) {
  return isTvOS(deviceInfo.platformName) ? `WebDriverAgentRunner_tvOS_appletv${deviceInfo.isRealDevice ? `os${version}-arm64` : `simulator${version}-x86_64`}.xctestrun` : `WebDriverAgentRunner_iphone${deviceInfo.isRealDevice ? `os${version}-arm64` : `simulator${version}-x86_64`}.xctestrun`;
}

async function killProcess(name, proc) {
  if (!proc || !proc.isRunning) {
    return;
  }

  _logger.default.info(`Shutting down '${name}' process (pid '${proc.proc.pid}')`);

  _logger.default.info(`Sending 'SIGTERM'...`);

  try {
    await proc.stop('SIGTERM', 1000);
    return;
  } catch (err) {
    if (!err.message.includes(`Process didn't end after`)) {
      throw err;
    }

    _logger.default.debug(`${name} process did not end in a timely fashion: '${err.message}'.`);
  }

  _logger.default.info(`Sending 'SIGKILL'...`);

  try {
    await proc.stop('SIGKILL');
  } catch (err) {
    if (err.message.includes('not currently running')) {
      return;
    }

    throw err;
  }
}

function randomInt(low, high) {
  return Math.floor(Math.random() * (high - low) + low);
}

async function getWDAUpgradeTimestamp() {
  const packageManifest = _path.default.resolve(ROOT_DIR, 'package.json');

  if (!(await _support.fs.exists(packageManifest))) {
    return null;
  }

  const {
    mtime
  } = await _support.fs.stat(packageManifest);
  return mtime.getTime();
}

async function resetTestProcesses(udid, isSimulator) {
  const processPatterns = [`xcodebuild.*${udid}`];

  if (isSimulator) {
    processPatterns.push(`${udid}.*XCTRunner`);
    processPatterns.push(`xctest.*${udid}`);
  }

  _logger.default.debug(`Killing running processes '${processPatterns.join(', ')}' for the device ${udid}...`);

  await _bluebird.default.all(processPatterns.map(killAppUsingPattern));
}

async function getPIDsListeningOnPort(port, filteringFunc = null) {
  const result = [];

  try {
    const {
      stdout
    } = await (0, _teen_process.exec)('lsof', ['-ti', `tcp:${port}`]);
    result.push(...stdout.trim().split(/\n+/));
  } catch (e) {
    if (e.code !== 1) {
      _logger.default.debug(`Error getting processes listening on port '${port}': ${e.stderr || e.message}`);
    }

    return result;
  }

  if (!_lodash.default.isFunction(filteringFunc)) {
    return result;
  }

  return await _bluebird.default.filter(result, async pid => {
    let stdout;

    try {
      ({
        stdout
      } = await (0, _teen_process.exec)('ps', ['-p', pid, '-o', 'command']));
    } catch (e) {
      if (e.code === 1) {
        return false;
      }

      throw e;
    }

    return await filteringFunc(stdout);
  });
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL3V0aWxzLmpzIiwibmFtZXMiOlsiUk9PVF9ESVIiLCJwYXRoIiwiYmFzZW5hbWUiLCJfX2Rpcm5hbWUiLCJyZXNvbHZlIiwicHJvY2VzcyIsImVudiIsIk5PX1BSRUNPTVBJTEUiLCJQUk9KRUNUX0ZJTEUiLCJnZXRQSURzVXNpbmdQYXR0ZXJuIiwicGF0dGVybiIsImFyZ3MiLCJzdGRvdXQiLCJzcGxpdCIsIm1hcCIsIngiLCJwYXJzZUludCIsImZpbHRlciIsIl8iLCJpc0ludGVnZXIiLCJlcnIiLCJsb2ciLCJkZWJ1ZyIsImpvaW4iLCJjb2RlIiwia2lsbEFwcFVzaW5nUGF0dGVybiIsInBncmVwUGF0dGVybiIsInNpZ25hbHMiLCJzaWduYWwiLCJtYXRjaGVkUGlkcyIsImlzRW1wdHkiLCJtZXNzYWdlIiwibGFzdCIsInBpZENoZWNrUHJvbWlzZXMiLCJwaWQiLCJ0aGVuIiwiY2F0Y2giLCJCIiwiYWxsIiwiZXZlcnkiLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwiaWduIiwiaXNUdk9TIiwicGxhdGZvcm1OYW1lIiwidG9Mb3dlciIsIlBMQVRGT1JNX05BTUVfVFZPUyIsInJlcGxhY2VJbkZpbGUiLCJmaWxlIiwiZmluZCIsInJlcGxhY2UiLCJjb250ZW50cyIsImZzIiwicmVhZEZpbGUiLCJuZXdDb250ZW50cyIsIndyaXRlRmlsZSIsInVwZGF0ZVByb2plY3RGaWxlIiwiYWdlbnRQYXRoIiwibmV3QnVuZGxlSWQiLCJwcm9qZWN0RmlsZVBhdGgiLCJjb3B5RmlsZSIsIlJlZ0V4cCIsImVzY2FwZVJlZ0V4cCIsIldEQV9SVU5ORVJfQlVORExFX0lEIiwid2FybiIsInJlc2V0UHJvamVjdEZpbGUiLCJleGlzdHMiLCJtdiIsInNldFJlYWxEZXZpY2VTZWN1cml0eSIsImtleWNoYWluUGF0aCIsImtleWNoYWluUGFzc3dvcmQiLCJnZW5lcmF0ZVhjb2RlQ29uZmlnRmlsZSIsIm9yZ0lkIiwic2lnbmluZ0lkIiwieGNjb25maWdQYXRoIiwidGVtcERpciIsInNldFhjdGVzdHJ1bkZpbGUiLCJkZXZpY2VJbmZvIiwic2RrVmVyc2lvbiIsImJvb3RzdHJhcFBhdGgiLCJ3ZGFSZW1vdGVQb3J0IiwieGN0ZXN0cnVuRmlsZVBhdGgiLCJnZXRYY3Rlc3RydW5GaWxlUGF0aCIsInhjdGVzdFJ1bkNvbnRlbnQiLCJwbGlzdCIsInBhcnNlUGxpc3RGaWxlIiwidXBkYXRlV0RBUG9ydCIsImdldEFkZGl0aW9uYWxSdW5Db250ZW50IiwibmV3WGN0ZXN0UnVuQ29udGVudCIsIm1lcmdlIiwidXBkYXRlUGxpc3RGaWxlIiwicnVubmVyIiwiRW52aXJvbm1lbnRWYXJpYWJsZXMiLCJVU0VfUE9SVCIsInNka0Jhc2VkIiwidWRpZCIsInBsYXRmb3JtQmFzZWQiLCJwbGF0Zm9ybVZlcnNpb24iLCJmaWxlUGF0aCIsInZlcnNpb24iLCJpbmZvIiwib3JpZ2luYWxYY3Rlc3RydW5GaWxlIiwiZ2V0WGN0ZXN0cnVuRmlsZU5hbWUiLCJlcnJvckFuZFRocm93IiwiaXNSZWFsRGV2aWNlIiwia2lsbFByb2Nlc3MiLCJuYW1lIiwicHJvYyIsImlzUnVubmluZyIsInN0b3AiLCJpbmNsdWRlcyIsInJhbmRvbUludCIsImxvdyIsImhpZ2giLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJnZXRXREFVcGdyYWRlVGltZXN0YW1wIiwicGFja2FnZU1hbmlmZXN0IiwibXRpbWUiLCJzdGF0IiwiZ2V0VGltZSIsInJlc2V0VGVzdFByb2Nlc3NlcyIsImlzU2ltdWxhdG9yIiwicHJvY2Vzc1BhdHRlcm5zIiwicHVzaCIsImdldFBJRHNMaXN0ZW5pbmdPblBvcnQiLCJwb3J0IiwiZmlsdGVyaW5nRnVuYyIsInJlc3VsdCIsInRyaW0iLCJlIiwic3RkZXJyIiwiaXNGdW5jdGlvbiJdLCJzb3VyY2VSb290IjoiLi4vLi4iLCJzb3VyY2VzIjpbImxpYi91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmcywgdGVtcERpciwgcGxpc3QgfSBmcm9tICdAYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFdEQV9SVU5ORVJfQlVORExFX0lELCBQTEFURk9STV9OQU1FX1RWT1MgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuXG5jb25zdCBST09UX0RJUiA9IHBhdGguYmFzZW5hbWUoX19kaXJuYW1lKSA9PT0gJ2xpYidcbiAgPyBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCBwcm9jZXNzLmVudi5OT19QUkVDT01QSUxFID8gJy4uJyA6ICcuLi8uLicpXG4gIDogX19kaXJuYW1lO1xuY29uc3QgUFJPSkVDVF9GSUxFID0gJ3Byb2plY3QucGJ4cHJvaic7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFBJRHNVc2luZ1BhdHRlcm4gKHBhdHRlcm4pIHtcbiAgY29uc3QgYXJncyA9IFtcbiAgICAnLWlmJywgLy8gY2FzZSBpbnNlbnNpdGl2ZSwgZnVsbCBjbWRsaW5lIG1hdGNoXG4gICAgcGF0dGVybixcbiAgXTtcbiAgdHJ5IHtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ3BncmVwJywgYXJncyk7XG4gICAgcmV0dXJuIHN0ZG91dC5zcGxpdCgvXFxzKy8pXG4gICAgICAubWFwKCh4KSA9PiBwYXJzZUludCh4LCAxMCkpXG4gICAgICAuZmlsdGVyKF8uaXNJbnRlZ2VyKVxuICAgICAgLm1hcCgoeCkgPT4gYCR7eH1gKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKGAncGdyZXAgJHthcmdzLmpvaW4oJyAnKX0nIGRpZG4ndCBkZXRlY3QgYW55IG1hdGNoaW5nIHByb2Nlc3Nlcy4gUmV0dXJuIGNvZGU6ICR7ZXJyLmNvZGV9YCk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGtpbGxBcHBVc2luZ1BhdHRlcm4gKHBncmVwUGF0dGVybikge1xuICBjb25zdCBzaWduYWxzID0gWzIsIDE1LCA5XTtcbiAgZm9yIChjb25zdCBzaWduYWwgb2Ygc2lnbmFscykge1xuICAgIGNvbnN0IG1hdGNoZWRQaWRzID0gYXdhaXQgZ2V0UElEc1VzaW5nUGF0dGVybihwZ3JlcFBhdHRlcm4pO1xuICAgIGlmIChfLmlzRW1wdHkobWF0Y2hlZFBpZHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbYC0ke3NpZ25hbH1gLCAuLi5tYXRjaGVkUGlkc107XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4ZWMoJ2tpbGwnLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5kZWJ1Zyhga2lsbCAke2FyZ3Muam9pbignICcpfSAtPiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBpZiAoc2lnbmFsID09PSBfLmxhc3Qoc2lnbmFscykpIHtcbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gd2FpdCBhZnRlciBTSUdLSUxMXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcGlkQ2hlY2tQcm9taXNlcyA9IG1hdGNoZWRQaWRzXG4gICAgICAgICAgLm1hcCgocGlkKSA9PiBleGVjKCdraWxsJywgWyctMCcsIHBpZF0pXG4gICAgICAgICAgICAvLyB0aGUgcHJvY2VzcyBpcyBzdGlsbCBhbGl2ZVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gZmFsc2UpXG4gICAgICAgICAgICAvLyB0aGUgcHJvY2VzcyBpcyBkZWFkXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4gdHJ1ZSlcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gKGF3YWl0IEIuYWxsKHBpZENoZWNrUHJvbWlzZXMpKVxuICAgICAgICAgIC5ldmVyeSgoeCkgPT4geCA9PT0gdHJ1ZSk7XG4gICAgICB9LCB7XG4gICAgICAgIHdhaXRNczogMTAwMCxcbiAgICAgICAgaW50ZXJ2YWxNczogMTAwLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSBjYXRjaCAoaWduKSB7XG4gICAgICAvLyB0cnkgdGhlIG5leHQgc2lnbmFsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIHBsYXRmb3JtTmFtZSBpcyB0dk9TXG4gKiBAcGFyYW0ge3N0cmluZ30gcGxhdGZvcm1OYW1lIFRoZSBuYW1lIG9mIHRoZSBwbGF0b3JtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIHRydWUgaWYgdGhlIHBsYXRmb3JtTmFtZSBpcyB0dk9TXG4gKi9cbmZ1bmN0aW9uIGlzVHZPUyAocGxhdGZvcm1OYW1lKSB7XG4gIHJldHVybiBfLnRvTG93ZXIocGxhdGZvcm1OYW1lKSA9PT0gXy50b0xvd2VyKFBMQVRGT1JNX05BTUVfVFZPUyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlcGxhY2VJbkZpbGUgKGZpbGUsIGZpbmQsIHJlcGxhY2UpIHtcbiAgbGV0IGNvbnRlbnRzID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZSwgJ3V0ZjgnKTtcblxuICBsZXQgbmV3Q29udGVudHMgPSBjb250ZW50cy5yZXBsYWNlKGZpbmQsIHJlcGxhY2UpO1xuICBpZiAobmV3Q29udGVudHMgIT09IGNvbnRlbnRzKSB7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGZpbGUsIG5ld0NvbnRlbnRzLCAndXRmOCcpO1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIFdlYkRyaXZlckFnZW50UnVubmVyIHByb2plY3QgYnVuZGxlIElEIHdpdGggbmV3QnVuZGxlSWQuXG4gKiBUaGlzIG1ldGhvZCBhc3N1bWVzIHByb2plY3QgZmlsZSBpcyBpbiB0aGUgY29ycmVjdCBzdGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhZ2VudFBhdGggLSBQYXRoIHRvIHRoZSAueGNvZGVwcm9qIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdCdW5kbGVJZCB0aGUgbmV3IGJ1bmRsZSBJRCB1c2VkIHRvIHVwZGF0ZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvamVjdEZpbGUgKGFnZW50UGF0aCwgbmV3QnVuZGxlSWQpIHtcbiAgbGV0IHByb2plY3RGaWxlUGF0aCA9IHBhdGgucmVzb2x2ZShhZ2VudFBhdGgsIFBST0pFQ1RfRklMRSk7XG4gIHRyeSB7XG4gICAgLy8gQXNzdW1pbmcgcHJvamVjdEZpbGVQYXRoIGlzIGluIHRoZSBjb3JyZWN0IHN0YXRlLCBjcmVhdGUgLm9sZCBmcm9tIHByb2plY3RGaWxlUGF0aFxuICAgIGF3YWl0IGZzLmNvcHlGaWxlKHByb2plY3RGaWxlUGF0aCwgYCR7cHJvamVjdEZpbGVQYXRofS5vbGRgKTtcbiAgICBhd2FpdCByZXBsYWNlSW5GaWxlKHByb2plY3RGaWxlUGF0aCwgbmV3IFJlZ0V4cChfLmVzY2FwZVJlZ0V4cChXREFfUlVOTkVSX0JVTkRMRV9JRCksICdnJyksIG5ld0J1bmRsZUlkKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgIGxvZy5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgJyR7cHJvamVjdEZpbGVQYXRofScgd2l0aCBidW5kbGUgaWQgJyR7bmV3QnVuZGxlSWR9J2ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZGVidWcoYEVycm9yIHVwZGF0aW5nIHByb2plY3QgZmlsZTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvIHVwZGF0ZSBwcm9qZWN0IGZpbGUgJyR7cHJvamVjdEZpbGVQYXRofScgd2l0aCBgICtcbiAgICAgIGBidW5kbGUgaWQgJyR7bmV3QnVuZGxlSWR9Jy4gV2ViRHJpdmVyQWdlbnQgbWF5IG5vdCBzdGFydGApO1xuICB9XG59XG5cbi8qKlxuICogUmVzZXQgV2ViRHJpdmVyQWdlbnRSdW5uZXIgcHJvamVjdCBidW5kbGUgSUQgdG8gY29ycmVjdCBzdGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhZ2VudFBhdGggLSBQYXRoIHRvIHRoZSAueGNvZGVwcm9qIGRpcmVjdG9yeS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzZXRQcm9qZWN0RmlsZSAoYWdlbnRQYXRoKSB7XG4gIGNvbnN0IHByb2plY3RGaWxlUGF0aCA9IHBhdGguam9pbihhZ2VudFBhdGgsIFBST0pFQ1RfRklMRSk7XG4gIHRyeSB7XG4gICAgLy8gcmVzdG9yZSBwcm9qZWN0RmlsZVBhdGggZnJvbSAub2xkIGZpbGVcbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhgJHtwcm9qZWN0RmlsZVBhdGh9Lm9sZGApKSB7XG4gICAgICByZXR1cm47IC8vIG5vIG5lZWQgdG8gcmVzZXRcbiAgICB9XG4gICAgYXdhaXQgZnMubXYoYCR7cHJvamVjdEZpbGVQYXRofS5vbGRgLCBwcm9qZWN0RmlsZVBhdGgpO1xuICAgIGxvZy5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IHJlc2V0ICcke3Byb2plY3RGaWxlUGF0aH0nIHdpdGggYnVuZGxlIGlkICcke1dEQV9SVU5ORVJfQlVORExFX0lEfSdgKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKGBFcnJvciByZXNldHRpbmcgcHJvamVjdCBmaWxlOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIGxvZy53YXJuKGBVbmFibGUgdG8gcmVzZXQgcHJvamVjdCBmaWxlICcke3Byb2plY3RGaWxlUGF0aH0nIHdpdGggYCArXG4gICAgICBgYnVuZGxlIGlkICcke1dEQV9SVU5ORVJfQlVORExFX0lEfScuIFdlYkRyaXZlckFnZW50IGhhcyBiZWVuIGAgK1xuICAgICAgYG1vZGlmaWVkIGFuZCBub3QgcmV0dXJuZWQgdG8gdGhlIG9yaWdpbmFsIHN0YXRlLmApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNldFJlYWxEZXZpY2VTZWN1cml0eSAoa2V5Y2hhaW5QYXRoLCBrZXljaGFpblBhc3N3b3JkKSB7XG4gIGxvZy5kZWJ1ZygnU2V0dGluZyBzZWN1cml0eSBmb3IgaU9TIGRldmljZScpO1xuICBhd2FpdCBleGVjKCdzZWN1cml0eScsIFsnLXYnLCAnbGlzdC1rZXljaGFpbnMnLCAnLXMnLCBrZXljaGFpblBhdGhdKTtcbiAgYXdhaXQgZXhlYygnc2VjdXJpdHknLCBbJy12JywgJ3VubG9jay1rZXljaGFpbicsICctcCcsIGtleWNoYWluUGFzc3dvcmQsIGtleWNoYWluUGF0aF0pO1xuICBhd2FpdCBleGVjKCdzZWN1cml0eScsIFsnc2V0LWtleWNoYWluLXNldHRpbmdzJywgJy10JywgJzM2MDAnLCAnLWwnLCBrZXljaGFpblBhdGhdKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVYY29kZUNvbmZpZ0ZpbGUgKG9yZ0lkLCBzaWduaW5nSWQpIHtcbiAgbG9nLmRlYnVnKGBHZW5lcmF0aW5nIHhjb2RlIGNvbmZpZyBmaWxlIGZvciBvcmdJZCAnJHtvcmdJZH0nIGFuZCBzaWduaW5nSWQgYCArXG4gICAgICAgICAgICBgJyR7c2lnbmluZ0lkfSdgKTtcbiAgY29uc3QgY29udGVudHMgPSBgREVWRUxPUE1FTlRfVEVBTSA9ICR7b3JnSWR9XG5DT0RFX1NJR05fSURFTlRJVFkgPSAke3NpZ25pbmdJZH1cbmA7XG4gIGNvbnN0IHhjY29uZmlnUGF0aCA9IGF3YWl0IHRlbXBEaXIucGF0aCgnYXBwaXVtLXRlbXAueGNjb25maWcnKTtcbiAgbG9nLmRlYnVnKGBXcml0aW5nIHhjb2RlIGNvbmZpZyBmaWxlIHRvICR7eGNjb25maWdQYXRofWApO1xuICBhd2FpdCBmcy53cml0ZUZpbGUoeGNjb25maWdQYXRoLCBjb250ZW50cywgJ3V0ZjgnKTtcbiAgcmV0dXJuIHhjY29uZmlnUGF0aDtcbn1cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3RcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZUluZm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpc1JlYWxEZXZpY2UgLSBFcXVhbHMgdG8gdHJ1ZSBpZiB0aGUgY3VycmVudCBkZXZpY2UgaXMgYSByZWFsIGRldmljZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIFVESUQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGxhdGZvcm1WZXJzaW9uIC0gVGhlIHBsYXRmb3JtIHZlcnNpb24gb2YgT1MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGxhdGZvcm1OYW1lIC0gVGhlIHBsYXRmb3JtIG5hbWUgb2YgaU9TLCB0dk9TXG4qL1xuLyoqXG4gKiBDcmVhdGVzIHhjdGVzdHJ1biBmaWxlIHBlciBkZXZpY2UgJiBwbGF0Zm9ybSB2ZXJzaW9uLlxuICogV2UgZXhwZWN0cyB0byBoYXZlIFdlYkRyaXZlckFnZW50UnVubmVyX2lwaG9uZW9zJHtzZGtWZXJzaW9ufHBsYXRmb3JtVmVyc2lvbn0tYXJtNjQueGN0ZXN0cnVuIGZvciByZWFsIGRldmljZVxuICogYW5kIFdlYkRyaXZlckFnZW50UnVubmVyX2lwaG9uZXNpbXVsYXRvciR7c2RrVmVyc2lvbnxwbGF0Zm9ybVZlcnNpb259LXg4Nl82NC54Y3Rlc3RydW4gZm9yIHNpbXVsYXRvciBsb2NhdGVkIEBib290c3RyYXBQYXRoXG4gKiBOZXdlciBYY29kZSAoWGNvZGUgMTAuMCBhdCBsZWFzdCkgZ2VuZXJhdGUgeGN0ZXN0cnVuIGZpbGUgZm9sbG93aW5nIHNka1ZlcnNpb24uXG4gKiBlLmcuIFhjb2RlIHdoaWNoIGhhcyBpT1MgU0RLIFZlcnNpb24gMTIuMiBnZW5lcmF0ZSBXZWJEcml2ZXJBZ2VudFJ1bm5lcl9pcGhvbmVzaW11bGF0b3IuMi14ODZfNjQueGN0ZXN0cnVuXG4gKiAgICAgIGV2ZW4gaWYgdGhlIGNhcCBoYXMgcGxhdGZvcm0gdmVyc2lvbiAxMS40XG4gKlxuICogQHBhcmFtIHtEZXZpY2VJbmZvfSBkZXZpY2VJbmZvXG4gKiBAcGFyYW0ge3N0cmluZ30gc2RrVmVyc2lvbiAtIFRoZSBYY29kZSBTREsgdmVyc2lvbiBvZiBPUy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBib290c3RyYXBQYXRoIC0gVGhlIGZvbGRlciBwYXRoIGNvbnRhaW5pbmcgeGN0ZXN0cnVuIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gd2RhUmVtb3RlUG9ydCAtIFRoZSByZW1vdGUgcG9ydCBXREEgaXMgbGlzdGVuaW5nIG9uLlxuICogQHJldHVybiB7c3RyaW5nfSByZXR1cm5zIHhjdGVzdHJ1bkZpbGVQYXRoIGZvciBnaXZlbiBkZXZpY2VcbiAqIEB0aHJvd3MgaWYgV2ViRHJpdmVyQWdlbnRSdW5uZXJfaXBob25lb3Mke3Nka1ZlcnNpb258cGxhdGZvcm1WZXJzaW9ufS1hcm02NC54Y3Rlc3RydW4gZm9yIHJlYWwgZGV2aWNlXG4gKiBvciBXZWJEcml2ZXJBZ2VudFJ1bm5lcl9pcGhvbmVzaW11bGF0b3Ike3Nka1ZlcnNpb258cGxhdGZvcm1WZXJzaW9ufS14ODZfNjQueGN0ZXN0cnVuIGZvciBzaW11bGF0b3IgaXMgbm90IGZvdW5kIEBib290c3RyYXBQYXRoLFxuICogdGhlbiBpdCB3aWxsIHRocm93IGZpbGUgbm90IGZvdW5kIGV4Y2VwdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRYY3Rlc3RydW5GaWxlIChkZXZpY2VJbmZvLCBzZGtWZXJzaW9uLCBib290c3RyYXBQYXRoLCB3ZGFSZW1vdGVQb3J0KSB7XG4gIGNvbnN0IHhjdGVzdHJ1bkZpbGVQYXRoID0gYXdhaXQgZ2V0WGN0ZXN0cnVuRmlsZVBhdGgoZGV2aWNlSW5mbywgc2RrVmVyc2lvbiwgYm9vdHN0cmFwUGF0aCk7XG4gIGNvbnN0IHhjdGVzdFJ1bkNvbnRlbnQgPSBhd2FpdCBwbGlzdC5wYXJzZVBsaXN0RmlsZSh4Y3Rlc3RydW5GaWxlUGF0aCk7XG4gIGNvbnN0IHVwZGF0ZVdEQVBvcnQgPSBnZXRBZGRpdGlvbmFsUnVuQ29udGVudChkZXZpY2VJbmZvLnBsYXRmb3JtTmFtZSwgd2RhUmVtb3RlUG9ydCk7XG4gIGNvbnN0IG5ld1hjdGVzdFJ1bkNvbnRlbnQgPSBfLm1lcmdlKHhjdGVzdFJ1bkNvbnRlbnQsIHVwZGF0ZVdEQVBvcnQpO1xuICBhd2FpdCBwbGlzdC51cGRhdGVQbGlzdEZpbGUoeGN0ZXN0cnVuRmlsZVBhdGgsIG5ld1hjdGVzdFJ1bkNvbnRlbnQsIHRydWUpO1xuXG4gIHJldHVybiB4Y3Rlc3RydW5GaWxlUGF0aDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIFdEQSBvYmplY3Qgd2hpY2ggYXBwZW5kcyBleGlzdGluZyB4Y3Rlc3QgcnVubmVyIGNvbnRlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwbGF0Zm9ybU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGxhdGZvcm1cbiAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIC0gVGhlIFhjb2RlIFNESyB2ZXJzaW9uIG9mIE9TLlxuICogQHJldHVybiB7b2JqZWN0fSByZXR1cm5zIGEgcnVubmVyIG9iamVjdCB3aGljaCBoYXMgVVNFX1BPUlRcbiAqL1xuZnVuY3Rpb24gZ2V0QWRkaXRpb25hbFJ1bkNvbnRlbnQgKHBsYXRmb3JtTmFtZSwgd2RhUmVtb3RlUG9ydCkge1xuICBjb25zdCBydW5uZXIgPSBgV2ViRHJpdmVyQWdlbnRSdW5uZXIke2lzVHZPUyhwbGF0Zm9ybU5hbWUpID8gJ190dk9TJyA6ICcnfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBbcnVubmVyXToge1xuICAgICAgRW52aXJvbm1lbnRWYXJpYWJsZXM6IHtcbiAgICAgICAgLy8gVVNFX1BPUlQgbXVzdCBiZSAnc3RyaW5nJ1xuICAgICAgICBVU0VfUE9SVDogYCR7d2RhUmVtb3RlUG9ydH1gXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGF0aCBvZiB4Y3Rlc3RydW4gaWYgaXQgZXhpc3RzXG4gKiBAcGFyYW0ge0RldmljZUluZm99IGRldmljZUluZm9cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZGtWZXJzaW9uIC0gVGhlIFhjb2RlIFNESyB2ZXJzaW9uIG9mIE9TLlxuICogQHBhcmFtIHtzdHJpbmd9IGJvb3RzdHJhcFBhdGggLSBUaGUgZm9sZGVyIHBhdGggY29udGFpbmluZyB4Y3Rlc3RydW4gZmlsZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0WGN0ZXN0cnVuRmlsZVBhdGggKGRldmljZUluZm8sIHNka1ZlcnNpb24sIGJvb3RzdHJhcFBhdGgpIHtcbiAgLy8gRmlyc3QgdHJ5IHRoZSBTREsgcGF0aCwgZm9yIFhjb2RlIDEwIChhdCBsZWFzdClcbiAgY29uc3Qgc2RrQmFzZWQgPSBbXG4gICAgcGF0aC5yZXNvbHZlKGJvb3RzdHJhcFBhdGgsIGAke2RldmljZUluZm8udWRpZH1fJHtzZGtWZXJzaW9ufS54Y3Rlc3RydW5gKSxcbiAgICBzZGtWZXJzaW9uLFxuICBdO1xuICAvLyBOZXh0IHRyeSBQbGF0Zm9ybSBwYXRoLCBmb3IgZWFybGllciBYY29kZSB2ZXJzaW9uc1xuICBjb25zdCBwbGF0Zm9ybUJhc2VkID0gW1xuICAgIHBhdGgucmVzb2x2ZShib290c3RyYXBQYXRoLCBgJHtkZXZpY2VJbmZvLnVkaWR9XyR7ZGV2aWNlSW5mby5wbGF0Zm9ybVZlcnNpb259LnhjdGVzdHJ1bmApLFxuICAgIGRldmljZUluZm8ucGxhdGZvcm1WZXJzaW9uLFxuICBdO1xuXG4gIGZvciAoY29uc3QgW2ZpbGVQYXRoLCB2ZXJzaW9uXSBvZiBbc2RrQmFzZWQsIHBsYXRmb3JtQmFzZWRdKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhmaWxlUGF0aCkpIHtcbiAgICAgIGxvZy5pbmZvKGBVc2luZyAnJHtmaWxlUGF0aH0nIGFzIHhjdGVzdHJ1biBmaWxlYCk7XG4gICAgICByZXR1cm4gZmlsZVBhdGg7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsWGN0ZXN0cnVuRmlsZSA9IHBhdGgucmVzb2x2ZShib290c3RyYXBQYXRoLCBnZXRYY3Rlc3RydW5GaWxlTmFtZShkZXZpY2VJbmZvLCB2ZXJzaW9uKSk7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhvcmlnaW5hbFhjdGVzdHJ1bkZpbGUpKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGZpcnN0IHRpbWUgcnVuIGZvciBnaXZlbiBkZXZpY2UsIHRoZW4gZmlyc3QgZ2VuZXJhdGUgeGN0ZXN0cnVuIGZpbGUgZm9yIGRldmljZS5cbiAgICAgIC8vIFdlIG5lZWQgdG8gaGF2ZSBhIHhjdGVzdHJ1biBmaWxlICoqcGVyIGRldmljZSoqIGJlY2F1c2Ugd2UgY2FudCBub3QgaGF2ZSBzYW1lIHdkYSBwb3J0IGZvciBhbGwgZGV2aWNlcy5cbiAgICAgIGF3YWl0IGZzLmNvcHlGaWxlKG9yaWdpbmFsWGN0ZXN0cnVuRmlsZSwgZmlsZVBhdGgpO1xuICAgICAgbG9nLmluZm8oYFVzaW5nICcke2ZpbGVQYXRofScgYXMgeGN0ZXN0cnVuIGZpbGUgY29waWVkIGJ5ICcke29yaWdpbmFsWGN0ZXN0cnVuRmlsZX0nYCk7XG4gICAgICByZXR1cm4gZmlsZVBhdGg7XG4gICAgfVxuICB9XG5cbiAgbG9nLmVycm9yQW5kVGhyb3coYElmIHlvdSBhcmUgdXNpbmcgJ3VzZVhjdGVzdHJ1bkZpbGUnIGNhcGFiaWxpdHkgdGhlbiB5b3UgYCArXG4gICAgYG5lZWQgdG8gaGF2ZSBhIHhjdGVzdHJ1biBmaWxlIChleHBlY3RlZDogYCArXG4gICAgYCcke3BhdGgucmVzb2x2ZShib290c3RyYXBQYXRoLCBnZXRYY3Rlc3RydW5GaWxlTmFtZShkZXZpY2VJbmZvLCBzZGtWZXJzaW9uKSl9JylgKTtcbn1cblxuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB4Y3Rlc3RydW4gZmlsZVxuICogQHBhcmFtIHtEZXZpY2VJbmZvfSBkZXZpY2VJbmZvXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiAtIFRoZSBYY29kZSBTREsgdmVyc2lvbiBvZiBPUy5cbiAqIEByZXR1cm4ge3N0cmluZ30gcmV0dXJucyB4Y3Rlc3RydW5GaWxlUGF0aCBmb3IgZ2l2ZW4gZGV2aWNlXG4gKi9cbmZ1bmN0aW9uIGdldFhjdGVzdHJ1bkZpbGVOYW1lIChkZXZpY2VJbmZvLCB2ZXJzaW9uKSB7XG4gIHJldHVybiBpc1R2T1MoZGV2aWNlSW5mby5wbGF0Zm9ybU5hbWUpXG4gICAgPyBgV2ViRHJpdmVyQWdlbnRSdW5uZXJfdHZPU19hcHBsZXR2JHtkZXZpY2VJbmZvLmlzUmVhbERldmljZSA/IGBvcyR7dmVyc2lvbn0tYXJtNjRgIDogYHNpbXVsYXRvciR7dmVyc2lvbn0teDg2XzY0YH0ueGN0ZXN0cnVuYFxuICAgIDogYFdlYkRyaXZlckFnZW50UnVubmVyX2lwaG9uZSR7ZGV2aWNlSW5mby5pc1JlYWxEZXZpY2UgPyBgb3Mke3ZlcnNpb259LWFybTY0YCA6IGBzaW11bGF0b3Ike3ZlcnNpb259LXg4Nl82NGB9LnhjdGVzdHJ1bmA7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGtpbGxQcm9jZXNzIChuYW1lLCBwcm9jKSB7XG4gIGlmICghcHJvYyB8fCAhcHJvYy5pc1J1bm5pbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsb2cuaW5mbyhgU2h1dHRpbmcgZG93biAnJHtuYW1lfScgcHJvY2VzcyAocGlkICcke3Byb2MucHJvYy5waWR9JylgKTtcblxuICBsb2cuaW5mbyhgU2VuZGluZyAnU0lHVEVSTScuLi5gKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBwcm9jLnN0b3AoJ1NJR1RFUk0nLCAxMDAwKTtcbiAgICByZXR1cm47XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoYFByb2Nlc3MgZGlkbid0IGVuZCBhZnRlcmApKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtuYW1lfSBwcm9jZXNzIGRpZCBub3QgZW5kIGluIGEgdGltZWx5IGZhc2hpb246ICcke2Vyci5tZXNzYWdlfScuYCk7XG4gIH1cblxuICBsb2cuaW5mbyhgU2VuZGluZyAnU0lHS0lMTCcuLi5gKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBwcm9jLnN0b3AoJ1NJR0tJTEwnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKCdub3QgY3VycmVudGx5IHJ1bm5pbmcnKSkge1xuICAgICAgLy8gdGhlIHByb2Nlc3MgZW5kZWQgYnV0IGZvciBzb21lIHJlYXNvbiB3ZSB3ZXJlIG5vdCBpbmZvcm1lZFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJhbmRvbSBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBudW1iZXIgaW4gcmFuZ2UgW2xvdywgaGlnaHQpLiBgbG93YGAgaXMgaW5jbHVzaXZlIGFuZCBgaGlnaGAgaXMgZXhjbHVzaXZlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnQgKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpICsgbG93KTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgV0RBIHVwZ3JhZGUgdGltZXN0YW1wXG4gKlxuICogQHJldHVybiB7P251bWJlcn0gVGhlIFVOSVggdGltZXN0YW1wIG9mIHRoZSBwYWNrYWdlIG1hbmlmZXN0LiBUaGUgbWFuaWZlc3Qgb25seSBnZXRzIG1vZGlmaWVkIG9uXG4gKiBwYWNrYWdlIHVwZ3JhZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFdEQVVwZ3JhZGVUaW1lc3RhbXAgKCkge1xuICBjb25zdCBwYWNrYWdlTWFuaWZlc3QgPSBwYXRoLnJlc29sdmUoUk9PVF9ESVIsICdwYWNrYWdlLmpzb24nKTtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGFja2FnZU1hbmlmZXN0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHttdGltZX0gPSBhd2FpdCBmcy5zdGF0KHBhY2thZ2VNYW5pZmVzdCk7XG4gIHJldHVybiBtdGltZS5nZXRUaW1lKCk7XG59XG5cbi8qKlxuICogS2lsbHMgcnVubmluZyBYQ1Rlc3QgcHJvY2Vzc2VzIGZvciB0aGUgcGFydGljdWxhciBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIFVESUQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2ltdWxhdG9yIC0gRXF1YWxzIHRvIHRydWUgaWYgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIGEgU2ltdWxhdG9yXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc2V0VGVzdFByb2Nlc3NlcyAodWRpZCwgaXNTaW11bGF0b3IpIHtcbiAgY29uc3QgcHJvY2Vzc1BhdHRlcm5zID0gW2B4Y29kZWJ1aWxkLioke3VkaWR9YF07XG4gIGlmIChpc1NpbXVsYXRvcikge1xuICAgIHByb2Nlc3NQYXR0ZXJucy5wdXNoKGAke3VkaWR9LipYQ1RSdW5uZXJgKTtcbiAgICAvLyBUaGUgcGF0dGVybiB0byBmaW5kIGluIGNhc2UgaWRiIHdhcyB1c2VkXG4gICAgcHJvY2Vzc1BhdHRlcm5zLnB1c2goYHhjdGVzdC4qJHt1ZGlkfWApO1xuICB9XG4gIGxvZy5kZWJ1ZyhgS2lsbGluZyBydW5uaW5nIHByb2Nlc3NlcyAnJHtwcm9jZXNzUGF0dGVybnMuam9pbignLCAnKX0nIGZvciB0aGUgZGV2aWNlICR7dWRpZH0uLi5gKTtcbiAgYXdhaXQgQi5hbGwocHJvY2Vzc1BhdHRlcm5zLm1hcChraWxsQXBwVXNpbmdQYXR0ZXJuKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBJRHMgb2YgcHJvY2Vzc2VzIGxpc3RlbmluZyBvbiB0aGUgcGFydGljdWxhciBzeXN0ZW0gcG9ydC5cbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXBwbHkgYWRkaXRpb25hbCBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlXG4gKiBwcm9jZXNzIGNvbW1hbmQgbGluZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHBvcnQgLSBUaGUgcG9ydCBudW1iZXIuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZmlsdGVyaW5nRnVuYyAtIE9wdGlvbmFsIGxhbWJkYSBmdW5jdGlvbiwgd2hpY2hcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXMgY29tbWFuZCBsaW5lIHN0cmluZyBvZiB0aGUgcGFydGljdWxhciBwcm9jZXNzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmluZyBvbiBnaXZlbiBwb3J0LCBhbmQgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVpdGhlciB0cnVlIG9yIGZhbHNlIHRvIGluY2x1ZGUvZXhjbHVkZSB0aGUgY29ycmVzcG9uZGluZyBQSURcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSB0aGUgcmVzdWx0aW5nIGFycmF5LlxuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IC0gdGhlIGxpc3Qgb2YgbWF0Y2hlZCBwcm9jZXNzIGlkcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UElEc0xpc3RlbmluZ09uUG9ydCAocG9ydCwgZmlsdGVyaW5nRnVuYyA9IG51bGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHRyeSB7XG4gICAgLy8gVGhpcyBvbmx5IHdvcmtzIHNpbmNlIE1hYyBPUyBYIEVsIENhcGl0YW5cbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ2xzb2YnLCBbJy10aScsIGB0Y3A6JHtwb3J0fWBdKTtcbiAgICByZXN1bHQucHVzaCguLi4oc3Rkb3V0LnRyaW0oKS5zcGxpdCgvXFxuKy8pKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5jb2RlICE9PSAxKSB7XG4gICAgICAvLyBjb2RlIDEgbWVhbnMgbm8gcHJvY2Vzc2VzLiBPdGhlciBlcnJvcnMgbmVlZCByZXBvcnRpbmdcbiAgICAgIGxvZy5kZWJ1ZyhgRXJyb3IgZ2V0dGluZyBwcm9jZXNzZXMgbGlzdGVuaW5nIG9uIHBvcnQgJyR7cG9ydH0nOiAke2Uuc3RkZXJyIHx8IGUubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghXy5pc0Z1bmN0aW9uKGZpbHRlcmluZ0Z1bmMpKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gYXdhaXQgQi5maWx0ZXIocmVzdWx0LCBhc3luYyAocGlkKSA9PiB7XG4gICAgbGV0IHN0ZG91dDtcbiAgICB0cnkge1xuICAgICAgKHtzdGRvdXR9ID0gYXdhaXQgZXhlYygncHMnLCBbJy1wJywgcGlkLCAnLW8nLCAnY29tbWFuZCddKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSA9PT0gMSkge1xuICAgICAgICAvLyBUaGUgcHJvY2VzcyBkb2VzIG5vdCBleGlzdCBhbnltb3JlLCB0aGVyZSdzIG5vdGhpbmcgdG8gZmlsdGVyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBmaWx0ZXJpbmdGdW5jKHN0ZG91dCk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyB1cGRhdGVQcm9qZWN0RmlsZSwgcmVzZXRQcm9qZWN0RmlsZSwgc2V0UmVhbERldmljZVNlY3VyaXR5LFxuICBnZXRBZGRpdGlvbmFsUnVuQ29udGVudCwgZ2V0WGN0ZXN0cnVuRmlsZU5hbWUsIGdlbmVyYXRlWGNvZGVDb25maWdGaWxlLFxuICBzZXRYY3Rlc3RydW5GaWxlLCBnZXRYY3Rlc3RydW5GaWxlUGF0aCwga2lsbFByb2Nlc3MsIHJhbmRvbUludCxcbiAgZ2V0V0RBVXBncmFkZVRpbWVzdGFtcCwgcmVzZXRUZXN0UHJvY2Vzc2VzLFxuICBnZXRQSURzTGlzdGVuaW5nT25Qb3J0LCBraWxsQXBwVXNpbmdQYXR0ZXJuLCBpc1R2T1MsXG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsTUFBTUEsUUFBUSxHQUFHQyxjQUFLQyxRQUFMLENBQWNDLFNBQWQsTUFBNkIsS0FBN0IsR0FDYkYsY0FBS0csT0FBTCxDQUFhRCxTQUFiLEVBQXdCRSxPQUFPLENBQUNDLEdBQVIsQ0FBWUMsYUFBWixHQUE0QixJQUE1QixHQUFtQyxPQUEzRCxDQURhLEdBRWJKLFNBRko7QUFHQSxNQUFNSyxZQUFZLEdBQUcsaUJBQXJCOztBQUVBLGVBQWVDLG1CQUFmLENBQW9DQyxPQUFwQyxFQUE2QztFQUMzQyxNQUFNQyxJQUFJLEdBQUcsQ0FDWCxLQURXLEVBRVhELE9BRlcsQ0FBYjs7RUFJQSxJQUFJO0lBQ0YsTUFBTTtNQUFDRTtJQUFELElBQVcsTUFBTSx3QkFBSyxPQUFMLEVBQWNELElBQWQsQ0FBdkI7SUFDQSxPQUFPQyxNQUFNLENBQUNDLEtBQVAsQ0FBYSxLQUFiLEVBQ0pDLEdBREksQ0FDQ0MsQ0FBRCxJQUFPQyxRQUFRLENBQUNELENBQUQsRUFBSSxFQUFKLENBRGYsRUFFSkUsTUFGSSxDQUVHQyxnQkFBRUMsU0FGTCxFQUdKTCxHQUhJLENBR0NDLENBQUQsSUFBUSxHQUFFQSxDQUFFLEVBSFosQ0FBUDtFQUlELENBTkQsQ0FNRSxPQUFPSyxHQUFQLEVBQVk7SUFDWkMsZ0JBQUlDLEtBQUosQ0FBVyxVQUFTWCxJQUFJLENBQUNZLElBQUwsQ0FBVSxHQUFWLENBQWUsd0RBQXVESCxHQUFHLENBQUNJLElBQUssRUFBbkc7O0lBQ0EsT0FBTyxFQUFQO0VBQ0Q7QUFDRjs7QUFFRCxlQUFlQyxtQkFBZixDQUFvQ0MsWUFBcEMsRUFBa0Q7RUFDaEQsTUFBTUMsT0FBTyxHQUFHLENBQUMsQ0FBRCxFQUFJLEVBQUosRUFBUSxDQUFSLENBQWhCOztFQUNBLEtBQUssTUFBTUMsTUFBWCxJQUFxQkQsT0FBckIsRUFBOEI7SUFDNUIsTUFBTUUsV0FBVyxHQUFHLE1BQU1wQixtQkFBbUIsQ0FBQ2lCLFlBQUQsQ0FBN0M7O0lBQ0EsSUFBSVIsZ0JBQUVZLE9BQUYsQ0FBVUQsV0FBVixDQUFKLEVBQTRCO01BQzFCO0lBQ0Q7O0lBQ0QsTUFBTWxCLElBQUksR0FBRyxDQUFFLElBQUdpQixNQUFPLEVBQVosRUFBZSxHQUFHQyxXQUFsQixDQUFiOztJQUNBLElBQUk7TUFDRixNQUFNLHdCQUFLLE1BQUwsRUFBYWxCLElBQWIsQ0FBTjtJQUNELENBRkQsQ0FFRSxPQUFPUyxHQUFQLEVBQVk7TUFDWkMsZ0JBQUlDLEtBQUosQ0FBVyxRQUFPWCxJQUFJLENBQUNZLElBQUwsQ0FBVSxHQUFWLENBQWUsT0FBTUgsR0FBRyxDQUFDVyxPQUFRLEVBQW5EO0lBQ0Q7O0lBQ0QsSUFBSUgsTUFBTSxLQUFLVixnQkFBRWMsSUFBRixDQUFPTCxPQUFQLENBQWYsRUFBZ0M7TUFFOUI7SUFDRDs7SUFDRCxJQUFJO01BQ0YsTUFBTSxnQ0FBaUIsWUFBWTtRQUNqQyxNQUFNTSxnQkFBZ0IsR0FBR0osV0FBVyxDQUNqQ2YsR0FEc0IsQ0FDakJvQixHQUFELElBQVMsd0JBQUssTUFBTCxFQUFhLENBQUMsSUFBRCxFQUFPQSxHQUFQLENBQWIsRUFFWEMsSUFGVyxDQUVOLE1BQU0sS0FGQSxFQUlYQyxLQUpXLENBSUwsTUFBTSxJQUpELENBRFMsQ0FBekI7UUFPQSxPQUFPLENBQUMsTUFBTUMsa0JBQUVDLEdBQUYsQ0FBTUwsZ0JBQU4sQ0FBUCxFQUNKTSxLQURJLENBQ0d4QixDQUFELElBQU9BLENBQUMsS0FBSyxJQURmLENBQVA7TUFFRCxDQVZLLEVBVUg7UUFDRHlCLE1BQU0sRUFBRSxJQURQO1FBRURDLFVBQVUsRUFBRTtNQUZYLENBVkcsQ0FBTjtNQWNBO0lBQ0QsQ0FoQkQsQ0FnQkUsT0FBT0MsR0FBUCxFQUFZLENBRWI7RUFDRjtBQUNGOztBQU9ELFNBQVNDLE1BQVQsQ0FBaUJDLFlBQWpCLEVBQStCO0VBQzdCLE9BQU8xQixnQkFBRTJCLE9BQUYsQ0FBVUQsWUFBVixNQUE0QjFCLGdCQUFFMkIsT0FBRixDQUFVQyw2QkFBVixDQUFuQztBQUNEOztBQUVELGVBQWVDLGFBQWYsQ0FBOEJDLElBQTlCLEVBQW9DQyxJQUFwQyxFQUEwQ0MsT0FBMUMsRUFBbUQ7RUFDakQsSUFBSUMsUUFBUSxHQUFHLE1BQU1DLFlBQUdDLFFBQUgsQ0FBWUwsSUFBWixFQUFrQixNQUFsQixDQUFyQjtFQUVBLElBQUlNLFdBQVcsR0FBR0gsUUFBUSxDQUFDRCxPQUFULENBQWlCRCxJQUFqQixFQUF1QkMsT0FBdkIsQ0FBbEI7O0VBQ0EsSUFBSUksV0FBVyxLQUFLSCxRQUFwQixFQUE4QjtJQUM1QixNQUFNQyxZQUFHRyxTQUFILENBQWFQLElBQWIsRUFBbUJNLFdBQW5CLEVBQWdDLE1BQWhDLENBQU47RUFDRDtBQUNGOztBQVFELGVBQWVFLGlCQUFmLENBQWtDQyxTQUFsQyxFQUE2Q0MsV0FBN0MsRUFBMEQ7RUFDeEQsSUFBSUMsZUFBZSxHQUFHMUQsY0FBS0csT0FBTCxDQUFhcUQsU0FBYixFQUF3QmpELFlBQXhCLENBQXRCOztFQUNBLElBQUk7SUFFRixNQUFNNEMsWUFBR1EsUUFBSCxDQUFZRCxlQUFaLEVBQThCLEdBQUVBLGVBQWdCLE1BQWhELENBQU47SUFDQSxNQUFNWixhQUFhLENBQUNZLGVBQUQsRUFBa0IsSUFBSUUsTUFBSixDQUFXM0MsZ0JBQUU0QyxZQUFGLENBQWVDLCtCQUFmLENBQVgsRUFBaUQsR0FBakQsQ0FBbEIsRUFBeUVMLFdBQXpFLENBQW5COztJQUNBckMsZ0JBQUlDLEtBQUosQ0FBVyx5QkFBd0JxQyxlQUFnQixxQkFBb0JELFdBQVksR0FBbkY7RUFDRCxDQUxELENBS0UsT0FBT3RDLEdBQVAsRUFBWTtJQUNaQyxnQkFBSUMsS0FBSixDQUFXLGdDQUErQkYsR0FBRyxDQUFDVyxPQUFRLEVBQXREOztJQUNBVixnQkFBSTJDLElBQUosQ0FBVSxrQ0FBaUNMLGVBQWdCLFNBQWxELEdBQ04sY0FBYUQsV0FBWSxpQ0FENUI7RUFFRDtBQUNGOztBQU1ELGVBQWVPLGdCQUFmLENBQWlDUixTQUFqQyxFQUE0QztFQUMxQyxNQUFNRSxlQUFlLEdBQUcxRCxjQUFLc0IsSUFBTCxDQUFVa0MsU0FBVixFQUFxQmpELFlBQXJCLENBQXhCOztFQUNBLElBQUk7SUFFRixJQUFJLEVBQUMsTUFBTTRDLFlBQUdjLE1BQUgsQ0FBVyxHQUFFUCxlQUFnQixNQUE3QixDQUFQLENBQUosRUFBZ0Q7TUFDOUM7SUFDRDs7SUFDRCxNQUFNUCxZQUFHZSxFQUFILENBQU8sR0FBRVIsZUFBZ0IsTUFBekIsRUFBZ0NBLGVBQWhDLENBQU47O0lBQ0F0QyxnQkFBSUMsS0FBSixDQUFXLHVCQUFzQnFDLGVBQWdCLHFCQUFvQkksK0JBQXFCLEdBQTFGO0VBQ0QsQ0FQRCxDQU9FLE9BQU8zQyxHQUFQLEVBQVk7SUFDWkMsZ0JBQUlDLEtBQUosQ0FBVyxpQ0FBZ0NGLEdBQUcsQ0FBQ1csT0FBUSxFQUF2RDs7SUFDQVYsZ0JBQUkyQyxJQUFKLENBQVUsaUNBQWdDTCxlQUFnQixTQUFqRCxHQUNOLGNBQWFJLCtCQUFxQiw2QkFENUIsR0FFTixrREFGSDtFQUdEO0FBQ0Y7O0FBRUQsZUFBZUsscUJBQWYsQ0FBc0NDLFlBQXRDLEVBQW9EQyxnQkFBcEQsRUFBc0U7RUFDcEVqRCxnQkFBSUMsS0FBSixDQUFVLGlDQUFWOztFQUNBLE1BQU0sd0JBQUssVUFBTCxFQUFpQixDQUFDLElBQUQsRUFBTyxnQkFBUCxFQUF5QixJQUF6QixFQUErQitDLFlBQS9CLENBQWpCLENBQU47RUFDQSxNQUFNLHdCQUFLLFVBQUwsRUFBaUIsQ0FBQyxJQUFELEVBQU8saUJBQVAsRUFBMEIsSUFBMUIsRUFBZ0NDLGdCQUFoQyxFQUFrREQsWUFBbEQsQ0FBakIsQ0FBTjtFQUNBLE1BQU0sd0JBQUssVUFBTCxFQUFpQixDQUFDLHVCQUFELEVBQTBCLElBQTFCLEVBQWdDLE1BQWhDLEVBQXdDLElBQXhDLEVBQThDQSxZQUE5QyxDQUFqQixDQUFOO0FBQ0Q7O0FBRUQsZUFBZUUsdUJBQWYsQ0FBd0NDLEtBQXhDLEVBQStDQyxTQUEvQyxFQUEwRDtFQUN4RHBELGdCQUFJQyxLQUFKLENBQVcsMkNBQTBDa0QsS0FBTSxrQkFBakQsR0FDQyxJQUFHQyxTQUFVLEdBRHhCOztFQUVBLE1BQU10QixRQUFRLEdBQUksc0JBQXFCcUIsS0FBTTtBQUMvQyx1QkFBdUJDLFNBQVU7QUFDakMsQ0FGRTtFQUdBLE1BQU1DLFlBQVksR0FBRyxNQUFNQyxpQkFBUTFFLElBQVIsQ0FBYSxzQkFBYixDQUEzQjs7RUFDQW9CLGdCQUFJQyxLQUFKLENBQVcsZ0NBQStCb0QsWUFBYSxFQUF2RDs7RUFDQSxNQUFNdEIsWUFBR0csU0FBSCxDQUFhbUIsWUFBYixFQUEyQnZCLFFBQTNCLEVBQXFDLE1BQXJDLENBQU47RUFDQSxPQUFPdUIsWUFBUDtBQUNEOztBQTJCRCxlQUFlRSxnQkFBZixDQUFpQ0MsVUFBakMsRUFBNkNDLFVBQTdDLEVBQXlEQyxhQUF6RCxFQUF3RUMsYUFBeEUsRUFBdUY7RUFDckYsTUFBTUMsaUJBQWlCLEdBQUcsTUFBTUMsb0JBQW9CLENBQUNMLFVBQUQsRUFBYUMsVUFBYixFQUF5QkMsYUFBekIsQ0FBcEQ7RUFDQSxNQUFNSSxnQkFBZ0IsR0FBRyxNQUFNQyxlQUFNQyxjQUFOLENBQXFCSixpQkFBckIsQ0FBL0I7RUFDQSxNQUFNSyxhQUFhLEdBQUdDLHVCQUF1QixDQUFDVixVQUFVLENBQUNqQyxZQUFaLEVBQTBCb0MsYUFBMUIsQ0FBN0M7O0VBQ0EsTUFBTVEsbUJBQW1CLEdBQUd0RSxnQkFBRXVFLEtBQUYsQ0FBUU4sZ0JBQVIsRUFBMEJHLGFBQTFCLENBQTVCOztFQUNBLE1BQU1GLGVBQU1NLGVBQU4sQ0FBc0JULGlCQUF0QixFQUF5Q08sbUJBQXpDLEVBQThELElBQTlELENBQU47RUFFQSxPQUFPUCxpQkFBUDtBQUNEOztBQVFELFNBQVNNLHVCQUFULENBQWtDM0MsWUFBbEMsRUFBZ0RvQyxhQUFoRCxFQUErRDtFQUM3RCxNQUFNVyxNQUFNLEdBQUksdUJBQXNCaEQsTUFBTSxDQUFDQyxZQUFELENBQU4sR0FBdUIsT0FBdkIsR0FBaUMsRUFBRyxFQUExRTtFQUVBLE9BQU87SUFDTCxDQUFDK0MsTUFBRCxHQUFVO01BQ1JDLG9CQUFvQixFQUFFO1FBRXBCQyxRQUFRLEVBQUcsR0FBRWIsYUFBYztNQUZQO0lBRGQ7RUFETCxDQUFQO0FBUUQ7O0FBUUQsZUFBZUUsb0JBQWYsQ0FBcUNMLFVBQXJDLEVBQWlEQyxVQUFqRCxFQUE2REMsYUFBN0QsRUFBNEU7RUFFMUUsTUFBTWUsUUFBUSxHQUFHLENBQ2Y3RixjQUFLRyxPQUFMLENBQWEyRSxhQUFiLEVBQTZCLEdBQUVGLFVBQVUsQ0FBQ2tCLElBQUssSUFBR2pCLFVBQVcsWUFBN0QsQ0FEZSxFQUVmQSxVQUZlLENBQWpCO0VBS0EsTUFBTWtCLGFBQWEsR0FBRyxDQUNwQi9GLGNBQUtHLE9BQUwsQ0FBYTJFLGFBQWIsRUFBNkIsR0FBRUYsVUFBVSxDQUFDa0IsSUFBSyxJQUFHbEIsVUFBVSxDQUFDb0IsZUFBZ0IsWUFBN0UsQ0FEb0IsRUFFcEJwQixVQUFVLENBQUNvQixlQUZTLENBQXRCOztFQUtBLEtBQUssTUFBTSxDQUFDQyxRQUFELEVBQVdDLE9BQVgsQ0FBWCxJQUFrQyxDQUFDTCxRQUFELEVBQVdFLGFBQVgsQ0FBbEMsRUFBNkQ7SUFDM0QsSUFBSSxNQUFNNUMsWUFBR2MsTUFBSCxDQUFVZ0MsUUFBVixDQUFWLEVBQStCO01BQzdCN0UsZ0JBQUkrRSxJQUFKLENBQVUsVUFBU0YsUUFBUyxxQkFBNUI7O01BQ0EsT0FBT0EsUUFBUDtJQUNEOztJQUNELE1BQU1HLHFCQUFxQixHQUFHcEcsY0FBS0csT0FBTCxDQUFhMkUsYUFBYixFQUE0QnVCLG9CQUFvQixDQUFDekIsVUFBRCxFQUFhc0IsT0FBYixDQUFoRCxDQUE5Qjs7SUFDQSxJQUFJLE1BQU0vQyxZQUFHYyxNQUFILENBQVVtQyxxQkFBVixDQUFWLEVBQTRDO01BRzFDLE1BQU1qRCxZQUFHUSxRQUFILENBQVl5QyxxQkFBWixFQUFtQ0gsUUFBbkMsQ0FBTjs7TUFDQTdFLGdCQUFJK0UsSUFBSixDQUFVLFVBQVNGLFFBQVMsa0NBQWlDRyxxQkFBc0IsR0FBbkY7O01BQ0EsT0FBT0gsUUFBUDtJQUNEO0VBQ0Y7O0VBRUQ3RSxnQkFBSWtGLGFBQUosQ0FBbUIsMERBQUQsR0FDZiwyQ0FEZSxHQUVmLElBQUd0RyxjQUFLRyxPQUFMLENBQWEyRSxhQUFiLEVBQTRCdUIsb0JBQW9CLENBQUN6QixVQUFELEVBQWFDLFVBQWIsQ0FBaEQsQ0FBMEUsSUFGaEY7QUFHRDs7QUFTRCxTQUFTd0Isb0JBQVQsQ0FBK0J6QixVQUEvQixFQUEyQ3NCLE9BQTNDLEVBQW9EO0VBQ2xELE9BQU94RCxNQUFNLENBQUNrQyxVQUFVLENBQUNqQyxZQUFaLENBQU4sR0FDRixvQ0FBbUNpQyxVQUFVLENBQUMyQixZQUFYLEdBQTJCLEtBQUlMLE9BQVEsUUFBdkMsR0FBa0QsWUFBV0EsT0FBUSxTQUFTLFlBRC9HLEdBRUYsOEJBQTZCdEIsVUFBVSxDQUFDMkIsWUFBWCxHQUEyQixLQUFJTCxPQUFRLFFBQXZDLEdBQWtELFlBQVdBLE9BQVEsU0FBUyxZQUZoSDtBQUdEOztBQUVELGVBQWVNLFdBQWYsQ0FBNEJDLElBQTVCLEVBQWtDQyxJQUFsQyxFQUF3QztFQUN0QyxJQUFJLENBQUNBLElBQUQsSUFBUyxDQUFDQSxJQUFJLENBQUNDLFNBQW5CLEVBQThCO0lBQzVCO0VBQ0Q7O0VBRUR2RixnQkFBSStFLElBQUosQ0FBVSxrQkFBaUJNLElBQUssbUJBQWtCQyxJQUFJLENBQUNBLElBQUwsQ0FBVXpFLEdBQUksSUFBaEU7O0VBRUFiLGdCQUFJK0UsSUFBSixDQUFVLHNCQUFWOztFQUNBLElBQUk7SUFDRixNQUFNTyxJQUFJLENBQUNFLElBQUwsQ0FBVSxTQUFWLEVBQXFCLElBQXJCLENBQU47SUFDQTtFQUNELENBSEQsQ0FHRSxPQUFPekYsR0FBUCxFQUFZO0lBQ1osSUFBSSxDQUFDQSxHQUFHLENBQUNXLE9BQUosQ0FBWStFLFFBQVosQ0FBc0IsMEJBQXRCLENBQUwsRUFBdUQ7TUFDckQsTUFBTTFGLEdBQU47SUFDRDs7SUFDREMsZ0JBQUlDLEtBQUosQ0FBVyxHQUFFb0YsSUFBSyw4Q0FBNkN0RixHQUFHLENBQUNXLE9BQVEsSUFBM0U7RUFDRDs7RUFFRFYsZ0JBQUkrRSxJQUFKLENBQVUsc0JBQVY7O0VBQ0EsSUFBSTtJQUNGLE1BQU1PLElBQUksQ0FBQ0UsSUFBTCxDQUFVLFNBQVYsQ0FBTjtFQUNELENBRkQsQ0FFRSxPQUFPekYsR0FBUCxFQUFZO0lBQ1osSUFBSUEsR0FBRyxDQUFDVyxPQUFKLENBQVkrRSxRQUFaLENBQXFCLHVCQUFyQixDQUFKLEVBQW1EO01BRWpEO0lBQ0Q7O0lBQ0QsTUFBTTFGLEdBQU47RUFDRDtBQUNGOztBQU9ELFNBQVMyRixTQUFULENBQW9CQyxHQUFwQixFQUF5QkMsSUFBekIsRUFBK0I7RUFDN0IsT0FBT0MsSUFBSSxDQUFDQyxLQUFMLENBQVdELElBQUksQ0FBQ0UsTUFBTCxNQUFpQkgsSUFBSSxHQUFHRCxHQUF4QixJQUErQkEsR0FBMUMsQ0FBUDtBQUNEOztBQVFELGVBQWVLLHNCQUFmLEdBQXlDO0VBQ3ZDLE1BQU1DLGVBQWUsR0FBR3JILGNBQUtHLE9BQUwsQ0FBYUosUUFBYixFQUF1QixjQUF2QixDQUF4Qjs7RUFDQSxJQUFJLEVBQUMsTUFBTW9ELFlBQUdjLE1BQUgsQ0FBVW9ELGVBQVYsQ0FBUCxDQUFKLEVBQXVDO0lBQ3JDLE9BQU8sSUFBUDtFQUNEOztFQUNELE1BQU07SUFBQ0M7RUFBRCxJQUFVLE1BQU1uRSxZQUFHb0UsSUFBSCxDQUFRRixlQUFSLENBQXRCO0VBQ0EsT0FBT0MsS0FBSyxDQUFDRSxPQUFOLEVBQVA7QUFDRDs7QUFRRCxlQUFlQyxrQkFBZixDQUFtQzNCLElBQW5DLEVBQXlDNEIsV0FBekMsRUFBc0Q7RUFDcEQsTUFBTUMsZUFBZSxHQUFHLENBQUUsZUFBYzdCLElBQUssRUFBckIsQ0FBeEI7O0VBQ0EsSUFBSTRCLFdBQUosRUFBaUI7SUFDZkMsZUFBZSxDQUFDQyxJQUFoQixDQUFzQixHQUFFOUIsSUFBSyxhQUE3QjtJQUVBNkIsZUFBZSxDQUFDQyxJQUFoQixDQUFzQixXQUFVOUIsSUFBSyxFQUFyQztFQUNEOztFQUNEMUUsZ0JBQUlDLEtBQUosQ0FBVyw4QkFBNkJzRyxlQUFlLENBQUNyRyxJQUFoQixDQUFxQixJQUFyQixDQUEyQixvQkFBbUJ3RSxJQUFLLEtBQTNGOztFQUNBLE1BQU0xRCxrQkFBRUMsR0FBRixDQUFNc0YsZUFBZSxDQUFDOUcsR0FBaEIsQ0FBb0JXLG1CQUFwQixDQUFOLENBQU47QUFDRDs7QUFlRCxlQUFlcUcsc0JBQWYsQ0FBdUNDLElBQXZDLEVBQTZDQyxhQUFhLEdBQUcsSUFBN0QsRUFBbUU7RUFDakUsTUFBTUMsTUFBTSxHQUFHLEVBQWY7O0VBQ0EsSUFBSTtJQUVGLE1BQU07TUFBQ3JIO0lBQUQsSUFBVyxNQUFNLHdCQUFLLE1BQUwsRUFBYSxDQUFDLEtBQUQsRUFBUyxPQUFNbUgsSUFBSyxFQUFwQixDQUFiLENBQXZCO0lBQ0FFLE1BQU0sQ0FBQ0osSUFBUCxDQUFZLEdBQUlqSCxNQUFNLENBQUNzSCxJQUFQLEdBQWNySCxLQUFkLENBQW9CLEtBQXBCLENBQWhCO0VBQ0QsQ0FKRCxDQUlFLE9BQU9zSCxDQUFQLEVBQVU7SUFDVixJQUFJQSxDQUFDLENBQUMzRyxJQUFGLEtBQVcsQ0FBZixFQUFrQjtNQUVoQkgsZ0JBQUlDLEtBQUosQ0FBVyw4Q0FBNkN5RyxJQUFLLE1BQUtJLENBQUMsQ0FBQ0MsTUFBRixJQUFZRCxDQUFDLENBQUNwRyxPQUFRLEVBQXhGO0lBQ0Q7O0lBQ0QsT0FBT2tHLE1BQVA7RUFDRDs7RUFFRCxJQUFJLENBQUMvRyxnQkFBRW1ILFVBQUYsQ0FBYUwsYUFBYixDQUFMLEVBQWtDO0lBQ2hDLE9BQU9DLE1BQVA7RUFDRDs7RUFDRCxPQUFPLE1BQU01RixrQkFBRXBCLE1BQUYsQ0FBU2dILE1BQVQsRUFBaUIsTUFBTy9GLEdBQVAsSUFBZTtJQUMzQyxJQUFJdEIsTUFBSjs7SUFDQSxJQUFJO01BQ0YsQ0FBQztRQUFDQTtNQUFELElBQVcsTUFBTSx3QkFBSyxJQUFMLEVBQVcsQ0FBQyxJQUFELEVBQU9zQixHQUFQLEVBQVksSUFBWixFQUFrQixTQUFsQixDQUFYLENBQWxCO0lBQ0QsQ0FGRCxDQUVFLE9BQU9pRyxDQUFQLEVBQVU7TUFDVixJQUFJQSxDQUFDLENBQUMzRyxJQUFGLEtBQVcsQ0FBZixFQUFrQjtRQUVoQixPQUFPLEtBQVA7TUFDRDs7TUFDRCxNQUFNMkcsQ0FBTjtJQUNEOztJQUNELE9BQU8sTUFBTUgsYUFBYSxDQUFDcEgsTUFBRCxDQUExQjtFQUNELENBWlksQ0FBYjtBQWFEIn0=
