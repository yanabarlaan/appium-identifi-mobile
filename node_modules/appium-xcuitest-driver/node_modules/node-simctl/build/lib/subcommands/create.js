"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _logger = _interopRequireWildcard(require("../logger"));

var _asyncbox = require("asyncbox");

var _helpers = require("../helpers");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const SIM_RUNTIME_NAME_SUFFIX_IOS = 'iOS';
const DEFAULT_CREATE_SIMULATOR_TIMEOUT = 10000;
const commands = {};

commands.createDevice = async function createDevice(name, deviceTypeId, platformVersion, opts = {}) {
  const {
    platform = SIM_RUNTIME_NAME_SUFFIX_IOS,
    timeout = DEFAULT_CREATE_SIMULATOR_TIMEOUT
  } = opts;
  let runtimeIds = [];

  try {
    runtimeIds.push(await this.getRuntimeForPlatformVersionViaJson(platformVersion, platform));
  } catch (ign) {}

  if (_lodash.default.isEmpty(runtimeIds)) {
    let runtimeId;

    try {
      runtimeId = await this.getRuntimeForPlatformVersion(platformVersion, platform);
    } catch (err) {
      _logger.default.warn(`Unable to find runtime for iOS '${platformVersion}'. Continuing`);

      runtimeId = platformVersion;
    }

    let potentialRuntimeIds = [(0, _helpers.normalizeVersion)(runtimeId)];

    if (runtimeId.split('.').length === 3) {
      potentialRuntimeIds.push(runtimeId);
    }

    runtimeIds.push(...potentialRuntimeIds.map(id => `${_helpers.SIM_RUNTIME_NAME}${platform}-${id.replace(/\./g, '-')}`), ...potentialRuntimeIds);
  }

  let udid;

  for (const runtimeId of runtimeIds) {
    _logger.default.debug(_logger.LOG_PREFIX, `Creating simulator with name '${name}', device type id '${deviceTypeId}' and runtime id '${runtimeId}'`);

    try {
      const {
        stdout
      } = await this.exec('create', {
        args: [name, deviceTypeId, runtimeId]
      });
      udid = stdout.trim();
      break;
    } catch (ign) {}
  }

  if (!udid) {
    throw new Error(`Could not create simulator with name '${name}', device ` + `type id '${deviceTypeId}', with runtime ids ` + `${runtimeIds.map(id => `'${id}'`).join(', ')}`);
  }

  const retries = parseInt(timeout / 1000, 10);
  await (0, _asyncbox.retryInterval)(retries, 1000, async () => {
    const devices = _lodash.default.values(await this.getDevices());

    for (const deviceArr of _lodash.default.values(devices)) {
      for (const device of deviceArr) {
        if (device.udid === udid) {
          if (device.state === 'Creating') {
            throw new Error(`Device with udid '${udid}' still being created`);
          } else {
            return;
          }
        }
      }
    }

    throw new Error(`Device with udid '${udid}' not yet created`);
  });
  return udid;
};

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL3N1YmNvbW1hbmRzL2NyZWF0ZS5qcyIsIm5hbWVzIjpbIlNJTV9SVU5USU1FX05BTUVfU1VGRklYX0lPUyIsIkRFRkFVTFRfQ1JFQVRFX1NJTVVMQVRPUl9USU1FT1VUIiwiY29tbWFuZHMiLCJjcmVhdGVEZXZpY2UiLCJuYW1lIiwiZGV2aWNlVHlwZUlkIiwicGxhdGZvcm1WZXJzaW9uIiwib3B0cyIsInBsYXRmb3JtIiwidGltZW91dCIsInJ1bnRpbWVJZHMiLCJwdXNoIiwiZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvblZpYUpzb24iLCJpZ24iLCJfIiwiaXNFbXB0eSIsInJ1bnRpbWVJZCIsImdldFJ1bnRpbWVGb3JQbGF0Zm9ybVZlcnNpb24iLCJlcnIiLCJsb2ciLCJ3YXJuIiwicG90ZW50aWFsUnVudGltZUlkcyIsInNwbGl0IiwibGVuZ3RoIiwibWFwIiwiaWQiLCJTSU1fUlVOVElNRV9OQU1FIiwicmVwbGFjZSIsInVkaWQiLCJkZWJ1ZyIsIkxPR19QUkVGSVgiLCJzdGRvdXQiLCJleGVjIiwiYXJncyIsInRyaW0iLCJFcnJvciIsImpvaW4iLCJyZXRyaWVzIiwicGFyc2VJbnQiLCJkZXZpY2VzIiwidmFsdWVzIiwiZ2V0RGV2aWNlcyIsImRldmljZUFyciIsImRldmljZSIsInN0YXRlIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLiIsInNvdXJjZXMiOlsibGliL3N1YmNvbW1hbmRzL2NyZWF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGxvZywgeyBMT0dfUFJFRklYIH0gZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBTSU1fUlVOVElNRV9OQU1FLCBub3JtYWxpemVWZXJzaW9uIH0gZnJvbSAnLi4vaGVscGVycyc7XG5cblxuY29uc3QgU0lNX1JVTlRJTUVfTkFNRV9TVUZGSVhfSU9TID0gJ2lPUyc7XG5jb25zdCBERUZBVUxUX0NSRUFURV9TSU1VTEFUT1JfVElNRU9VVCA9IDEwMDAwO1xuXG5jb25zdCBjb21tYW5kcyA9IHt9O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNpbUNyZWF0aW9uT3B0c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHBsYXRmb3JtIFtpT1NdIC0gUGxhdGZvcm0gbmFtZSBpbiBvcmRlciB0byBzcGVjaWZ5IHJ1bnRpbWUgc3VjaCBhcyAnaU9TJywgJ3R2T1MnLCAnd2F0Y2hPUydcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lb3V0IFsxMDAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0IGRldmljZSBjcmVhdGlvbiBpcyBjb21wbGV0ZWQuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgU2ltdWxhdG9yIGRldmljZSB3aXRoIGdpdmVuIG5hbWUgZm9yIHRoZSBwYXJ0aWN1bGFyXG4gKiBwbGF0Zm9ybSB0eXBlIGFuZCB2ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRldmljZSBuYW1lIHRvIGJlIGNyZWF0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGV2aWNlVHlwZUlkIC0gRGV2aWNlIHR5cGUsIGZvciBleGFtcGxlICdpUGhvbmUgNicuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGxhdGZvcm1WZXJzaW9uIC0gUGxhdGZvcm0gdmVyc2lvbiwgZm9yIGV4YW1wbGUgJzEwLjMnLlxuICogQHBhcmFtIHs/U2ltQ3JlYXRpb25PcHRzfSBvcHRzIC0gU2ltdWxhdG9yIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGRldmljZXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVRElEIG9mIHRoZSBuZXdseSBjcmVhdGVkIGRldmljZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29ycmVzcG9uZGluZyBzaW1jdGwgc3ViY29tbWFuZCBjb21tYW5kXG4gKiAgICAgICAgICAgICAgICAgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuY29tbWFuZHMuY3JlYXRlRGV2aWNlID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGV2aWNlIChuYW1lLCBkZXZpY2VUeXBlSWQsIHBsYXRmb3JtVmVyc2lvbiwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBwbGF0Zm9ybSA9IFNJTV9SVU5USU1FX05BTUVfU1VGRklYX0lPUyxcbiAgICB0aW1lb3V0ID0gREVGQVVMVF9DUkVBVEVfU0lNVUxBVE9SX1RJTUVPVVRcbiAgfSA9IG9wdHM7XG5cbiAgbGV0IHJ1bnRpbWVJZHMgPSBbXTtcblxuICAvLyBUcnkgZ2V0dGluZyBydW50aW1lSWQgdXNpbmcgSlNPTiBmbGFnXG4gIHRyeSB7XG4gICAgcnVudGltZUlkcy5wdXNoKGF3YWl0IHRoaXMuZ2V0UnVudGltZUZvclBsYXRmb3JtVmVyc2lvblZpYUpzb24ocGxhdGZvcm1WZXJzaW9uLCBwbGF0Zm9ybSkpO1xuICB9IGNhdGNoIChpZ24pIHt9XG5cbiAgaWYgKF8uaXNFbXB0eShydW50aW1lSWRzKSkge1xuICAgIC8vIGF0IGZpcnN0IG1ha2Ugc3VyZSB0aGF0IHRoZSBydW50aW1lIGlkIGlzIHRoZSByaWdodCBvbmVcbiAgICAvLyBpbiBzb21lIHZlcnNpb25zIG9mIFhjb2RlIGl0IHdpbGwgYmUgYSBwYXRjaCB2ZXJzaW9uXG4gICAgbGV0IHJ1bnRpbWVJZDtcbiAgICB0cnkge1xuICAgICAgcnVudGltZUlkID0gYXdhaXQgdGhpcy5nZXRSdW50aW1lRm9yUGxhdGZvcm1WZXJzaW9uKHBsYXRmb3JtVmVyc2lvbiwgcGxhdGZvcm0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYFVuYWJsZSB0byBmaW5kIHJ1bnRpbWUgZm9yIGlPUyAnJHtwbGF0Zm9ybVZlcnNpb259Jy4gQ29udGludWluZ2ApO1xuICAgICAgcnVudGltZUlkID0gcGxhdGZvcm1WZXJzaW9uO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgcG9zc2libGUgcnVudGltZXMsIHdoaWNoIHdpbGwgYmUgaXRlcmF0ZWQgb3ZlclxuXG4gICAgLy8gc3RhcnQgd2l0aCBtYWpvci1taW5vciB2ZXJzaW9uXG4gICAgbGV0IHBvdGVudGlhbFJ1bnRpbWVJZHMgPSBbbm9ybWFsaXplVmVyc2lvbihydW50aW1lSWQpXTtcbiAgICBpZiAocnVudGltZUlkLnNwbGl0KCcuJykubGVuZ3RoID09PSAzKSB7XG4gICAgICAvLyBhZGQgcGF0Y2ggdmVyc2lvbiBpZiBpdCBleGlzdHNcbiAgICAgIHBvdGVudGlhbFJ1bnRpbWVJZHMucHVzaChydW50aW1lSWQpO1xuICAgIH1cblxuICAgIC8vIGFkZCBtb2RpZmllZCB2ZXJzaW9ucywgc2luY2UgbW9kZXJuIFhjb2RlcyB1c2UgdGhpcywgdGhlbiB0aGUgYmFyZVxuICAgIC8vIHZlcnNpb25zLCB0byBhY2NvbW9kYXRlIG9sZGVyIFhjb2Rlc1xuICAgIHJ1bnRpbWVJZHMucHVzaChcbiAgICAgIC4uLihwb3RlbnRpYWxSdW50aW1lSWRzLm1hcCgoaWQpID0+IGAke1NJTV9SVU5USU1FX05BTUV9JHtwbGF0Zm9ybX0tJHtpZC5yZXBsYWNlKC9cXC4vZywgJy0nKX1gKSksXG4gICAgICAuLi5wb3RlbnRpYWxSdW50aW1lSWRzXG4gICAgKTtcbiAgfVxuXG4gIC8vIGdvIHRocm91Z2ggdGhlIHJ1bnRpbWUgaWRzIGFuZCB0cnkgdG8gY3JlYXRlIGEgc2ltdWxhdG9yIHdpdGggZWFjaFxuICBsZXQgdWRpZDtcbiAgZm9yIChjb25zdCBydW50aW1lSWQgb2YgcnVudGltZUlkcykge1xuICAgIGxvZy5kZWJ1ZyhMT0dfUFJFRklYLFxuICAgICAgYENyZWF0aW5nIHNpbXVsYXRvciB3aXRoIG5hbWUgJyR7bmFtZX0nLCBkZXZpY2UgdHlwZSBpZCAnJHtkZXZpY2VUeXBlSWR9JyBhbmQgcnVudGltZSBpZCAnJHtydW50aW1lSWR9J2ApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHRoaXMuZXhlYygnY3JlYXRlJywge1xuICAgICAgICBhcmdzOiBbbmFtZSwgZGV2aWNlVHlwZUlkLCBydW50aW1lSWRdXG4gICAgICB9KTtcbiAgICAgIHVkaWQgPSBzdGRvdXQudHJpbSgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAoaWduKSB7XG4gICAgICAvLyB0aGUgZXJyb3IgZ2V0cyBsb2dnZWQgaW4gYHNpbUV4ZWNgXG4gICAgfVxuICB9XG5cbiAgaWYgKCF1ZGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgY3JlYXRlIHNpbXVsYXRvciB3aXRoIG5hbWUgJyR7bmFtZX0nLCBkZXZpY2UgYCArXG4gICAgICBgdHlwZSBpZCAnJHtkZXZpY2VUeXBlSWR9Jywgd2l0aCBydW50aW1lIGlkcyBgICtcbiAgICAgIGAke3J1bnRpbWVJZHMubWFwKChpZCkgPT4gYCcke2lkfSdgKS5qb2luKCcsICcpfWApO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHRoYXQgaXQgZ2V0cyBvdXQgb2YgdGhlIFwiQ3JlYXRpbmdcIiBzdGF0ZVxuICBjb25zdCByZXRyaWVzID0gcGFyc2VJbnQodGltZW91dCAvIDEwMDAsIDEwKTtcbiAgYXdhaXQgcmV0cnlJbnRlcnZhbChyZXRyaWVzLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZGV2aWNlcyA9IF8udmFsdWVzKGF3YWl0IHRoaXMuZ2V0RGV2aWNlcygpKTtcbiAgICBmb3IgKGNvbnN0IGRldmljZUFyciBvZiBfLnZhbHVlcyhkZXZpY2VzKSkge1xuICAgICAgZm9yIChjb25zdCBkZXZpY2Ugb2YgZGV2aWNlQXJyKSB7XG4gICAgICAgIGlmIChkZXZpY2UudWRpZCA9PT0gdWRpZCkge1xuICAgICAgICAgIGlmIChkZXZpY2Uuc3RhdGUgPT09ICdDcmVhdGluZycpIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gcmV0cnlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGV2aWNlIHdpdGggdWRpZCAnJHt1ZGlkfScgc3RpbGwgYmVpbmcgY3JlYXRlZGApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9wIGxvb2tpbmcsIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBEZXZpY2Ugd2l0aCB1ZGlkICcke3VkaWR9JyBub3QgeWV0IGNyZWF0ZWRgKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHVkaWQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb21tYW5kcztcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBR0EsTUFBTUEsMkJBQTJCLEdBQUcsS0FBcEM7QUFDQSxNQUFNQyxnQ0FBZ0MsR0FBRyxLQUF6QztBQUVBLE1BQU1DLFFBQVEsR0FBRyxFQUFqQjs7QUFxQkFBLFFBQVEsQ0FBQ0MsWUFBVCxHQUF3QixlQUFlQSxZQUFmLENBQTZCQyxJQUE3QixFQUFtQ0MsWUFBbkMsRUFBaURDLGVBQWpELEVBQWtFQyxJQUFJLEdBQUcsRUFBekUsRUFBNkU7RUFDbkcsTUFBTTtJQUNKQyxRQUFRLEdBQUdSLDJCQURQO0lBRUpTLE9BQU8sR0FBR1I7RUFGTixJQUdGTSxJQUhKO0VBS0EsSUFBSUcsVUFBVSxHQUFHLEVBQWpCOztFQUdBLElBQUk7SUFDRkEsVUFBVSxDQUFDQyxJQUFYLENBQWdCLE1BQU0sS0FBS0MsbUNBQUwsQ0FBeUNOLGVBQXpDLEVBQTBERSxRQUExRCxDQUF0QjtFQUNELENBRkQsQ0FFRSxPQUFPSyxHQUFQLEVBQVksQ0FBRTs7RUFFaEIsSUFBSUMsZ0JBQUVDLE9BQUYsQ0FBVUwsVUFBVixDQUFKLEVBQTJCO0lBR3pCLElBQUlNLFNBQUo7O0lBQ0EsSUFBSTtNQUNGQSxTQUFTLEdBQUcsTUFBTSxLQUFLQyw0QkFBTCxDQUFrQ1gsZUFBbEMsRUFBbURFLFFBQW5ELENBQWxCO0lB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
