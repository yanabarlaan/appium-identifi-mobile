"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearInternalCache = clearInternalCache;
exports.getAutomationTraceTemplatePath = void 0;
exports.getAutomationTraceTemplatePathWithoutRetry = getAutomationTraceTemplatePathWithoutRetry;
exports.getClangVersion = getClangVersion;
exports.getCommandLineToolsVersion = getCommandLineToolsVersion;
exports.getConnectedDevices = getConnectedDevices;
exports.getMaxIOSSDK = exports.getInstrumentsPath = void 0;
exports.getMaxIOSSDKWithoutRetry = getMaxIOSSDKWithoutRetry;
exports.getMaxTVOSSDK = void 0;
exports.getMaxTVOSSDKWithoutRetry = getMaxTVOSSDKWithoutRetry;
exports.getPath = void 0;
exports.getVersion = getVersion;

require("source-map-support/register");

var _support = require("@appium/support");

var _path = _interopRequireDefault(require("path"));

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

var _plist = require("plist");

var _teen_process = require("teen_process");

var _semver = _interopRequireDefault(require("semver"));

const env = process.env;
const XCRUN_TIMEOUT = 15000;
const XCODE_SUBDIR = '/Contents/Developer';
const DEFAULT_NUMBER_OF_RETRIES = 3;

const log = _support.logger.getLogger('Xcode');

function hasExpectedSubDir(path) {
  return path.substring(path.length - XCODE_SUBDIR.length) === XCODE_SUBDIR;
}

async function runXcrunCommand(args, timeout = XCRUN_TIMEOUT) {
  try {
    const res = await (0, _teen_process.exec)('xcrun', args, {
      timeout
    });

    if (_lodash.default.isUndefined(res)) {
      throw new Error(`Nothing returned from trying to run 'xcrun ${args.join(' ')}'`);
    }

    return res;
  } catch (err) {
    if (err.stderr) {
      err.message = `${err.message}: ${err.stderr}`;
    }

    throw err;
  }
}

async function getPathFromSymlink(failMessage) {
  log.warn(`Finding XcodePath by symlink because ${failMessage}`);
  const symlinkPath = '/var/db/xcode_select_link';
  const legacySymlinkPath = '/usr/share/xcode-select/xcode_dir_link';
  let xcodePath = null;

  if (_support.util.hasContent(env.DEVELOPER_DIR)) {
    const customPath = hasExpectedSubDir(env.DEVELOPER_DIR) ? env.DEVELOPER_DIR : env.DEVELOPER_DIR + XCODE_SUBDIR;

    if (await _support.fs.exists(customPath)) {
      xcodePath = customPath;
    } else {
      let mesg = `Could not find path to Xcode, environment variable ` + `DEVELOPER_DIR set to: ${env.DEVELOPER_DIR} ` + `but no Xcode found`;
      log.warn(mesg);
      throw new Error(mesg);
    }
  } else if (await _support.fs.exists(symlinkPath)) {
    xcodePath = await _support.fs.readlink(symlinkPath);
  } else if (await _support.fs.exists(legacySymlinkPath)) {
    xcodePath = await _support.fs.readlink(legacySymlinkPath);
  }

  if (xcodePath) {
    return xcodePath.replace(new RegExp('/$'), '').trim();
  }

  let msg = `Could not find path to Xcode by symlinks located in ${symlinkPath}, or ${legacySymlinkPath}`;
  log.warn(msg);
  throw new Error(msg);
}

async function getPathFromXcodeSelect(timeout = XCRUN_TIMEOUT) {
  let {
    stdout
  } = await (0, _teen_process.exec)('xcode-select', ['--print-path'], {
    timeout
  });
  const xcodeFolderPath = stdout.replace(/\/$/, '').trim();

  if (!_support.util.hasContent(xcodeFolderPath)) {
    log.errorAndThrow('xcode-select returned an empty string');
  }

  if (await _support.fs.exists(xcodeFolderPath)) {
    return xcodeFolderPath;
  } else {
    const msg = `xcode-select could not find xcode. Path '${xcodeFolderPath}' does not exist.`;
    log.errorAndThrow(msg);
  }
}

const getPath = _lodash.default.memoize(function getPath(timeout = XCRUN_TIMEOUT) {
  return getPathFromXcodeSelect(timeout).catch(getPathFromSymlink);
});

exports.getPath = getPath;

async function getVersionWithoutRetry(timeout = XCRUN_TIMEOUT) {
  const xcodePath = await getPath(timeout);

  const plistPath = _path.default.resolve(xcodePath, '..', 'Info.plist');

  if (!(await _support.fs.exists(plistPath))) {
    throw new Error(`Could not get Xcode version. ${plistPath} does not exist on disk.`);
  }

  const version = await _support.plist.parsePlistFile(plistPath);
  return _semver.default.coerce(version.CFBundleShortVersionString);
}

const getVersionMemoized = _lodash.default.memoize(function getVersionMemoized(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getVersionWithoutRetry, timeout);
});

async function getVersion(parse = false, retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  const version = await getVersionMemoized(retries, timeout);
  const versionString = version.patch > 0 ? version.version : `${version.major}.${version.minor}`;

  if (!parse) {
    return versionString;
  }

  return {
    versionString,
    versionFloat: parseFloat(versionString),
    major: version.major,
    minor: version.minor,
    patch: version.patch > 0 ? version.patch : undefined,

    toString() {
      return versionString;
    }

  };
}

async function getCommandLineToolsVersion() {
  const getVersionFunctions = [async () => {
    let pkg = (await (0, _teen_process.exec)('pkgutil', ['--pkgs=com.apple.pkg.DevSDK_.*'])).stdout;
    return (await (0, _teen_process.exec)('pkgutil', [`--pkg-info=${pkg.trim()}`])).stdout;
  }, async () => (await (0, _teen_process.exec)('pkgutil', [`--pkg-info=com.apple.pkg.CLTools_Executables`])).stdout, async () => (await (0, _teen_process.exec)('pkgutil', [`--pkg-info=com.apple.pkg.DeveloperToolsCLI`])).stdout];
  let stdout;

  for (let getVersion of getVersionFunctions) {
    try {
      stdout = await getVersion();
      break;
    } catch (ign) {
      stdout = '';
    }
  }

  let match = /^version: (.+)$/m.exec(stdout);
  return match ? match[1] : undefined;
}

async function getClangVersion() {
  try {
    await _support.fs.which('clang');
  } catch (e) {
    log.info('Cannot find clang executable on the local system. ' + 'Are Xcode Command Line Tools installed?');
    return null;
  }

  const {
    stdout
  } = await (0, _teen_process.exec)('clang', ['--version']);
  const match = /clang-([0-9.]+)/.exec(stdout);

  if (!match) {
    log.info(`Cannot parse clang version from ${stdout}`);
    return null;
  }

  return match[1];
}

async function getAutomationTraceTemplatePathWithoutRetry(timeout = XCRUN_TIMEOUT) {
  const xcodePath = await getPath(timeout);
  const extensions = ['xrplugin', 'bundle'];

  const pathPrefix = _path.default.resolve(xcodePath, '../Applications/Instruments.app/Contents/PlugIns');

  const pathSuffix = 'Contents/Resources/Automation.tracetemplate';
  let automationTraceTemplatePaths = [_path.default.resolve(pathPrefix, `AutomationInstrument.${extensions[0]}`, pathSuffix), _path.default.resolve(pathPrefix, `AutomationInstrument.${extensions[1]}`, pathSuffix)];

  if (await _support.fs.exists(automationTraceTemplatePaths[0])) {
    return automationTraceTemplatePaths[0];
  }

  if (await _support.fs.exists(automationTraceTemplatePaths[1])) {
    return automationTraceTemplatePaths[1];
  }

  const msg = 'Could not find Automation.tracetemplate in any of the following' + `locations ${automationTraceTemplatePaths.toString()}`;
  log.error(msg);
  throw new Error(msg);
}

const getAutomationTraceTemplatePath = _lodash.default.memoize(function getAutomationTraceTemplatePath(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getAutomationTraceTemplatePathWithoutRetry, timeout);
});

exports.getAutomationTraceTemplatePath = getAutomationTraceTemplatePath;

async function getMaxIOSSDKWithoutRetry(timeout = XCRUN_TIMEOUT) {
  const version = await getVersion(false, DEFAULT_NUMBER_OF_RETRIES, timeout);

  if (version[0] === '4') {
    return '6.1';
  }

  const args = ['--sdk', 'iphonesimulator', '--show-sdk-version'];
  const {
    stdout
  } = await runXcrunCommand(args, timeout);
  const sdkVersion = stdout.trim();
  const match = /\d.\d/.exec(stdout);

  if (!match) {
    throw new Error(`xcrun returned a non-numeric iOS SDK version: '${sdkVersion}'`);
  }

  return sdkVersion;
}

async function getMaxIOSSDKFromXcodeVersion(timeout = XCRUN_TIMEOUT) {
  const version = await getVersion(true, DEFAULT_NUMBER_OF_RETRIES, timeout);
  return `${version.major + 2}.${version.minor}`;
}

const getMaxIOSSDK = _lodash.default.memoize(function getMaxIOSSDK(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  try {
    return (0, _asyncbox.retry)(retries, getMaxIOSSDKWithoutRetry, timeout);
  } catch (err) {
    log.warn(`Unable to retrieve maximum iOS version: ${err.message}`);
    log.warn('Guessing from Xcode version');
    return getMaxIOSSDKFromXcodeVersion(timeout);
  }
});

exports.getMaxIOSSDK = getMaxIOSSDK;

async function getMaxTVOSSDKWithoutRetry(timeout = XCRUN_TIMEOUT) {
  const args = ['--sdk', 'appletvsimulator', '--show-sdk-version'];
  const {
    stdout
  } = await runXcrunCommand(args, timeout);
  const sdkVersion = stdout.trim();

  if (isNaN(parseFloat(sdkVersion))) {
    throw new Error(`xcrun returned a non-numeric tvOS SDK version: '${sdkVersion}'`);
  }

  return sdkVersion;
}

const getMaxTVOSSDK = _lodash.default.memoize(function getMaxTVOSSDK(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getMaxTVOSSDKWithoutRetry, timeout);
});

exports.getMaxTVOSSDK = getMaxTVOSSDK;

async function getConnectedDevices(timeout = XCRUN_TIMEOUT) {
  const cmd = '/usr/sbin/system_profiler';
  const args = ['-xml', 'SPUSBDataType'];
  let {
    stdout
  } = await (0, _teen_process.exec)(cmd, args, {
    timeout
  });
  let plistContent = (0, _plist.parse)(stdout);
  let devicesFound = [];
  let entriesToSearch = [plistContent[0]];

  while (entriesToSearch.length > 0) {
    let currentEntry = entriesToSearch.pop();

    if (currentEntry instanceof Array) {
      entriesToSearch = entriesToSearch.concat(currentEntry);
    } else if (currentEntry._name && currentEntry._name.substring(0, 4) === 'iPad' || currentEntry._name && currentEntry._name.substring(0, 6) === 'iPhone' || currentEntry._name && _lodash.default.includes(currentEntry._name, 'Apple TV')) {
      let deviceInfo = {
        name: currentEntry._name,
        udid: currentEntry.serial_num,
        productId: currentEntry.product_id,
        deviceVersion: currentEntry.bcd_device
      };
      devicesFound.push(deviceInfo);
    } else if (currentEntry._items) {
      entriesToSearch = entriesToSearch.concat(currentEntry._items);
    }
  }

  return devicesFound;
}

async function getInstrumentsPathWithoutRetry(timeout = XCRUN_TIMEOUT) {
  const args = ['-find', 'instruments'];
  let {
    stdout
  } = await runXcrunCommand(args, timeout);

  if (!stdout) {
    stdout = '';
  }

  let instrumentsPath = stdout.trim();

  if (!instrumentsPath) {
    throw new Error(`Could not find path to instruments binary using 'xcrun ${args.join(' ')}'`);
  }

  return instrumentsPath;
}

const getInstrumentsPath = _lodash.default.memoize(function getInstrumentsPath(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getInstrumentsPathWithoutRetry, timeout);
});

exports.getInstrumentsPath = getInstrumentsPath;

function clearInternalCache() {
  const memoized = [getPath, getVersionMemoized, getAutomationTraceTemplatePath, getMaxIOSSDK, getMaxTVOSSDK, getInstrumentsPath];
  memoized.forEach(f => {
    if (f.cache) {
      f.cache = new _lodash.default.memoize.Cache();
    }
  });
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi94Y29kZS5qcyJdLCJuYW1lcyI6WyJlbnYiLCJwcm9jZXNzIiwiWENSVU5fVElNRU9VVCIsIlhDT0RFX1NVQkRJUiIsIkRFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMiLCJsb2ciLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJoYXNFeHBlY3RlZFN1YkRpciIsInBhdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJydW5YY3J1bkNvbW1hbmQiLCJhcmdzIiwidGltZW91dCIsInJlcyIsIl8iLCJpc1VuZGVmaW5lZCIsIkVycm9yIiwiam9pbiIsImVyciIsInN0ZGVyciIsIm1lc3NhZ2UiLCJnZXRQYXRoRnJvbVN5bWxpbmsiLCJmYWlsTWVzc2FnZSIsIndhcm4iLCJzeW1saW5rUGF0aCIsImxlZ2FjeVN5bWxpbmtQYXRoIiwieGNvZGVQYXRoIiwidXRpbCIsImhhc0NvbnRlbnQiLCJERVZFTE9QRVJfRElSIiwiY3VzdG9tUGF0aCIsImZzIiwiZXhpc3RzIiwibWVzZyIsInJlYWRsaW5rIiwicmVwbGFjZSIsIlJlZ0V4cCIsInRyaW0iLCJtc2ciLCJnZXRQYXRoRnJvbVhjb2RlU2VsZWN0Iiwic3Rkb3V0IiwieGNvZGVGb2xkZXJQYXRoIiwiZXJyb3JBbmRUaHJvdyIsImdldFBhdGgiLCJtZW1vaXplIiwiY2F0Y2giLCJnZXRWZXJzaW9uV2l0aG91dFJldHJ5IiwicGxpc3RQYXRoIiwicmVzb2x2ZSIsInZlcnNpb24iLCJwbGlzdCIsInBhcnNlUGxpc3RGaWxlIiwic2VtdmVyIiwiY29lcmNlIiwiQ0ZCdW5kbGVTaG9ydFZlcnNpb25TdHJpbmciLCJnZXRWZXJzaW9uTWVtb2l6ZWQiLCJyZXRyaWVzIiwiZ2V0VmVyc2lvbiIsInBhcnNlIiwidmVyc2lvblN0cmluZyIsInBhdGNoIiwibWFqb3IiLCJtaW5vciIsInZlcnNpb25GbG9hdCIsInBhcnNlRmxvYXQiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsImdldENvbW1hbmRMaW5lVG9vbHNWZXJzaW9uIiwiZ2V0VmVyc2lvbkZ1bmN0aW9ucyIsInBrZyIsImlnbiIsIm1hdGNoIiwiZXhlYyIsImdldENsYW5nVmVyc2lvbiIsIndoaWNoIiwiZSIsImluZm8iLCJnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhXaXRob3V0UmV0cnkiLCJleHRlbnNpb25zIiwicGF0aFByZWZpeCIsInBhdGhTdWZmaXgiLCJhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzIiwiZXJyb3IiLCJnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGgiLCJnZXRNYXhJT1NTREtXaXRob3V0UmV0cnkiLCJzZGtWZXJzaW9uIiwiZ2V0TWF4SU9TU0RLRnJvbVhjb2RlVmVyc2lvbiIsImdldE1heElPU1NESyIsImdldE1heFRWT1NTREtXaXRob3V0UmV0cnkiLCJpc05hTiIsImdldE1heFRWT1NTREsiLCJnZXRDb25uZWN0ZWREZXZpY2VzIiwiY21kIiwicGxpc3RDb250ZW50IiwiZGV2aWNlc0ZvdW5kIiwiZW50cmllc1RvU2VhcmNoIiwiY3VycmVudEVudHJ5IiwicG9wIiwiQXJyYXkiLCJjb25jYXQiLCJfbmFtZSIsImluY2x1ZGVzIiwiZGV2aWNlSW5mbyIsIm5hbWUiLCJ1ZGlkIiwic2VyaWFsX251bSIsInByb2R1Y3RJZCIsInByb2R1Y3RfaWQiLCJkZXZpY2VWZXJzaW9uIiwiYmNkX2RldmljZSIsInB1c2giLCJfaXRlbXMiLCJnZXRJbnN0cnVtZW50c1BhdGhXaXRob3V0UmV0cnkiLCJpbnN0cnVtZW50c1BhdGgiLCJnZXRJbnN0cnVtZW50c1BhdGgiLCJjbGVhckludGVybmFsQ2FjaGUiLCJtZW1vaXplZCIsImZvckVhY2giLCJmIiwiY2FjaGUiLCJDYWNoZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLE1BQU1BLEdBQUcsR0FBR0MsT0FBTyxDQUFDRCxHQUFwQjtBQUVBLE1BQU1FLGFBQWEsR0FBRyxLQUF0QjtBQUNB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LElBQUFBLE1BQU0sR0FBRyxFQUFUO0FBQ0Q7O0FBRUQsTUFBSXlFLGVBQWUsR0FBR3pFLE1BQU0sQ0FBQ0gsSUFBUCxFQUF0Qjs7QUFFQSxNQUFJLENBQUM0RSxlQUFMLEVBQXNCO0FBQ3BCLFVBQU0sSUFBSWpHLEtBQUosQ0FBVywwREFBeURMLElBQUksQ0FBQ00sSUFBTCxDQUFVLEdBQVYsQ0FBZSxHQUFuRixDQUFOO0FBQ0Q7O0FBRUQsU0FBT2dHLGVBQVA7QUFDRDs7QUFFRCxNQUFNQyxrQkFBa0IsR0FBR3BHLGdCQUFFOEIsT0FBRixDQUN6QixTQUFTc0Usa0JBQVQsQ0FBNkIxRCxPQUFPLEdBQUd0RCx5QkFBdkMsRUFBa0VVLE9BQU8sR0FBR1osYUFBNUUsRUFBMkY7QUFDekYsU0FBTyxxQkFBTXdELE9BQU4sRUFBZXdELDhCQUFmLEVBQStDcEcsT0FBL0MsQ0FBUDtBQUNELENBSHdCLENBQTNCOzs7O0FBTUEsU0FBU3VHLGtCQUFULEdBQStCO0FBRzdCLFFBQU1DLFFBQVEsR0FBRyxDQUNmekUsT0FEZSxFQUNOWSxrQkFETSxFQUNjNEIsOEJBRGQsRUFDOENJLFlBRDlDLEVBRWZHLGFBRmUsRUFFQXdCLGtCQUZBLENBQWpCO0FBS0FFLEVBQUFBLFFBQVEsQ0FBQ0MsT0FBVCxDQUFrQkMsQ0FBRCxJQUFPO0FBQ3RCLFFBQUlBLENBQUMsQ0FBQ0MsS0FBTixFQUFhO0FBQ1hELE1BQUFBLENBQUMsQ0FBQ0MsS0FBRixHQUFVLElBQUl6RyxnQkFBRThCLE9BQUYsQ0FBVTRFLEtBQWQsRUFBVjtBQUNEO0FBQ0YsR0FKRDtBQUtEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXRpbCwgZnMsIHBsaXN0LCBsb2dnZXIgfSBmcm9tICdAYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyByZXRyeSB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBwYXJzZSBhcyBwYXJzZVBsaXN0RGF0YSB9IGZyb20gJ3BsaXN0JztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuXG5cbmNvbnN0IGVudiA9IHByb2Nlc3MuZW52O1xuXG5jb25zdCBYQ1JVTl9USU1FT1VUID0gMTUwMDA7XG5jb25zdCBYQ09ERV9TVUJESVIgPSAnL0NvbnRlbnRzL0RldmVsb3Blcic7XG5jb25zdCBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTID0gMztcblxuY29uc3QgbG9nID0gbG9nZ2VyLmdldExvZ2dlcignWGNvZGUnKTtcblxuXG5mdW5jdGlvbiBoYXNFeHBlY3RlZFN1YkRpciAocGF0aCkge1xuICByZXR1cm4gcGF0aC5zdWJzdHJpbmcocGF0aC5sZW5ndGggLSBYQ09ERV9TVUJESVIubGVuZ3RoKSA9PT0gWENPREVfU1VCRElSO1xufVxuXG5hc3luYyBmdW5jdGlvbiBydW5YY3J1bkNvbW1hbmQgKGFyZ3MsIHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZXhlYygneGNydW4nLCBhcmdzLCB7dGltZW91dH0pO1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHJlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm90aGluZyByZXR1cm5lZCBmcm9tIHRyeWluZyB0byBydW4gJ3hjcnVuICR7YXJncy5qb2luKCcgJyl9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyB0aGUgdHJ1ZSBlcnJvciBjYW4gYmUgaGlkZGVuIHdpdGhpbiB0aGUgc3RkZXJyXG4gICAgaWYgKGVyci5zdGRlcnIpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9OiAke2Vyci5zdGRlcnJ9YDtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UGF0aEZyb21TeW1saW5rIChmYWlsTWVzc2FnZSkge1xuICAvLyBOb2RlJ3MgaW52b2NhdGlvbiBvZiB4Y29kZS1zZWxlY3Qgc29tZXRpbWVzIGZsYWtlcyBhbmQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vIE5vdCBjbGVhciB3aHkuIEFzIGEgd29ya2Fyb3VuZCwgQXBwaXVtIGNhbiByZWxpYWJseSBkZWR1Y2UgdGhlIHZlcnNpb24gaW4gdXNlIGJ5IGNoZWNraW5nXG4gIC8vIHRoZSBsb2NhdGlvbnMgeGNvZGUtc2VsZWN0IHVzZXMgdG8gc3RvcmUgdGhlIHNlbGVjdGVkIHZlcnNpb24ncyBwYXRoLiBUaGlzIHNob3VsZCBiZSAxMDAlXG4gIC8vIHJlbGlhYmxlIHNvIGxvbmcgYXMgdGhlIGxpbmsgbG9jYXRpb25zIHJlbWFpbiB0aGUgc2FtZS4gSG93ZXZlciwgc2luY2Ugd2UncmUgcmVseWluZyBvblxuICAvLyBoYXJkY29kZWQgcGF0aHMsIHRoaXMgYXBwcm9hY2ggd2lsbCBicmVhayB0aGUgbmV4dCB0aW1lIEFwcGxlIGNoYW5nZXMgdGhlIHN5bWxpbmsgbG9jYXRpb24uXG4gIGxvZy53YXJuKGBGaW5kaW5nIFhjb2RlUGF0aCBieSBzeW1saW5rIGJlY2F1c2UgJHtmYWlsTWVzc2FnZX1gKTtcblxuICBjb25zdCBzeW1saW5rUGF0aCA9ICcvdmFyL2RiL3hjb2RlX3NlbGVjdF9saW5rJztcbiAgY29uc3QgbGVnYWN5U3ltbGlua1BhdGggPSAnL3Vzci9zaGFyZS94Y29kZS1zZWxlY3QveGNvZGVfZGlyX2xpbmsnOyAvLyAgWGNvZGUgPCA1LnhcbiAgbGV0IHhjb2RlUGF0aCA9IG51bGw7XG5cbiAgLy8geGNvZGUtc2VsZWN0IGFsbG93cyB1c2VycyB0byBvdmVycmlkZSBpdHMgc2V0dGluZ3Mgd2l0aCB0aGUgREVWRUxPUEVSX0RJUiBlbnYgdmFyLFxuICAvLyBzbyBjaGVjayB0aGF0IGZpcnN0XG4gIGlmICh1dGlsLmhhc0NvbnRlbnQoZW52LkRFVkVMT1BFUl9ESVIpKSB7XG4gICAgY29uc3QgY3VzdG9tUGF0aCA9IGhhc0V4cGVjdGVkU3ViRGlyKGVudi5ERVZFTE9QRVJfRElSKVxuICAgICAgPyBlbnYuREVWRUxPUEVSX0RJUlxuICAgICAgOiBlbnYuREVWRUxPUEVSX0RJUiArIFhDT0RFX1NVQkRJUjtcblxuICAgIGlmIChhd2FpdCBmcy5leGlzdHMoY3VzdG9tUGF0aCkpIHtcbiAgICAgIHhjb2RlUGF0aCA9IGN1c3RvbVBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtZXNnID0gYENvdWxkIG5vdCBmaW5kIHBhdGggdG8gWGNvZGUsIGVudmlyb25tZW50IHZhcmlhYmxlIGAgK1xuICAgICAgICAgICAgICAgICBgREVWRUxPUEVSX0RJUiBzZXQgdG86ICR7ZW52LkRFVkVMT1BFUl9ESVJ9IGAgK1xuICAgICAgICAgICAgICAgICBgYnV0IG5vIFhjb2RlIGZvdW5kYDtcbiAgICAgIGxvZy53YXJuKG1lc2cpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc2cpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhd2FpdCBmcy5leGlzdHMoc3ltbGlua1BhdGgpKSB7XG4gICAgeGNvZGVQYXRoID0gYXdhaXQgZnMucmVhZGxpbmsoc3ltbGlua1BhdGgpO1xuICB9IGVsc2UgaWYgKGF3YWl0IGZzLmV4aXN0cyhsZWdhY3lTeW1saW5rUGF0aCkpIHtcbiAgICB4Y29kZVBhdGggPSBhd2FpdCBmcy5yZWFkbGluayhsZWdhY3lTeW1saW5rUGF0aCk7XG4gIH1cblxuICBpZiAoeGNvZGVQYXRoKSB7XG4gICAgcmV0dXJuIHhjb2RlUGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJy8kJyksICcnKS50cmltKCk7XG4gIH1cblxuICAvLyBXZSBzaG91bGQgb25seSBnZXQgaGVyZSBpcyB3ZSBmYWlsZWQgdG8gY2FwdHVyZSB4Y29kZS1zZWxlY3QncyBzdGRvdXQgYW5kIG91clxuICAvLyBvdGhlciBjaGVja3MgZmFpbGVkLiBFaXRoZXIgQXBwbGUgaGFzIG1vdmVkIHRoZSBzeW1saW5rIHRvIGEgbmV3IGxvY2F0aW9uIG9yIHRoZSB1c2VyXG4gIC8vIGlzIG5vdCB1c2luZyB0aGUgZGVmYXVsdCBpbnN0YWxsLiA5OS45OTklIGNoYW5jZSBpdCdzIHRoZSBsYXR0ZXIsIHNvIGlzc3VlIGEgd2FybmluZ1xuICAvLyBzaG91bGQgd2UgZXZlciBoaXQgdGhlIGVkZ2UgY2FzZS5cbiAgbGV0IG1zZyA9IGBDb3VsZCBub3QgZmluZCBwYXRoIHRvIFhjb2RlIGJ5IHN5bWxpbmtzIGxvY2F0ZWQgaW4gJHtzeW1saW5rUGF0aH0sIG9yICR7bGVnYWN5U3ltbGlua1BhdGh9YDtcbiAgbG9nLndhcm4obXNnKTtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFBhdGhGcm9tWGNvZGVTZWxlY3QgKHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ3hjb2RlLXNlbGVjdCcsIFsnLS1wcmludC1wYXRoJ10sIHt0aW1lb3V0fSk7XG5cbiAgLy8gdHJpbSBhbmQgcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gIGNvbnN0IHhjb2RlRm9sZGVyUGF0aCA9IHN0ZG91dC5yZXBsYWNlKC9cXC8kLywgJycpLnRyaW0oKTtcblxuICBpZiAoIXV0aWwuaGFzQ29udGVudCh4Y29kZUZvbGRlclBhdGgpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coJ3hjb2RlLXNlbGVjdCByZXR1cm5lZCBhbiBlbXB0eSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChhd2FpdCBmcy5leGlzdHMoeGNvZGVGb2xkZXJQYXRoKSkge1xuICAgIHJldHVybiB4Y29kZUZvbGRlclBhdGg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbXNnID0gYHhjb2RlLXNlbGVjdCBjb3VsZCBub3QgZmluZCB4Y29kZS4gUGF0aCAnJHt4Y29kZUZvbGRlclBhdGh9JyBkb2VzIG5vdCBleGlzdC5gO1xuICAgIGxvZy5lcnJvckFuZFRocm93KG1zZyk7XG4gIH1cbn1cblxuY29uc3QgZ2V0UGF0aCA9IF8ubWVtb2l6ZShmdW5jdGlvbiBnZXRQYXRoICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAvLyBmaXJzdCB3ZSB0cnkgdXNpbmcgeGNvZGUtc2VsZWN0IHRvIGZpbmQgdGhlIHBhdGhcbiAgLy8gdGhlbiB3ZSB0cnkgdXNpbmcgdGhlIHN5bWxpbmtzIHRoYXQgQXBwbGUgaGFzIGJ5IGRlZmF1bHRcbiAgcmV0dXJuIGdldFBhdGhGcm9tWGNvZGVTZWxlY3QodGltZW91dCkuY2F0Y2goZ2V0UGF0aEZyb21TeW1saW5rKTtcbn0pO1xuXG5cblxuYXN5bmMgZnVuY3Rpb24gZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgeGNvZGVQYXRoID0gYXdhaXQgZ2V0UGF0aCh0aW1lb3V0KTtcblxuICAvLyB3ZSB3YW50IHRvIHJlYWQgdGhlIENGQnVuZGxlU2hvcnRWZXJzaW9uU3RyaW5nIGZyb20gWGNvZGUncyBwbGlzdC5cbiAgLy8gSXQgc2hvdWxkIGJlIGluIC9bcm9vdF0vWENvZGUuYXBwL0NvbnRlbnRzL1xuICBjb25zdCBwbGlzdFBhdGggPSBwYXRoLnJlc29sdmUoeGNvZGVQYXRoLCAnLi4nLCAnSW5mby5wbGlzdCcpO1xuXG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKHBsaXN0UGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBnZXQgWGNvZGUgdmVyc2lvbi4gJHtwbGlzdFBhdGh9IGRvZXMgbm90IGV4aXN0IG9uIGRpc2suYCk7XG4gIH1cblxuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgcGxpc3QucGFyc2VQbGlzdEZpbGUocGxpc3RQYXRoKTtcbiAgcmV0dXJuIHNlbXZlci5jb2VyY2UodmVyc2lvbi5DRkJ1bmRsZVNob3J0VmVyc2lvblN0cmluZyk7XG59XG5cbmNvbnN0IGdldFZlcnNpb25NZW1vaXplZCA9IF8ubWVtb2l6ZShcbiAgZnVuY3Rpb24gZ2V0VmVyc2lvbk1lbW9pemVkIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb24gKHBhcnNlID0gZmFsc2UsIHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbk1lbW9pemVkKHJldHJpZXMsIHRpbWVvdXQpO1xuICAvLyB4Y29kZSB2ZXJzaW9uIHN0cmluZ3MgYXJlIG5vdCBleGFjdGx5IHNlbXZlciBzdHJpbmc6IHBhdGNoIHZlcnNpb25zIG9mIDBcbiAgLy8gYXJlIHJlbW92ZWQgKGUuZy4sICcxMC4wLjAnID0+ICcxMC4wJylcbiAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24ucGF0Y2ggPiAwID8gdmVyc2lvbi52ZXJzaW9uIDogYCR7dmVyc2lvbi5tYWpvcn0uJHt2ZXJzaW9uLm1pbm9yfWA7XG4gIGlmICghcGFyc2UpIHtcbiAgICByZXR1cm4gdmVyc2lvblN0cmluZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvblN0cmluZyxcbiAgICB2ZXJzaW9uRmxvYXQ6IHBhcnNlRmxvYXQodmVyc2lvblN0cmluZyksXG4gICAgbWFqb3I6IHZlcnNpb24ubWFqb3IsXG4gICAgbWlub3I6IHZlcnNpb24ubWlub3IsXG4gICAgcGF0Y2g6IHZlcnNpb24ucGF0Y2ggPiAwID8gdmVyc2lvbi5wYXRjaCA6IHVuZGVmaW5lZCxcbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdmVyc2lvblN0cmluZztcbiAgICB9LFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRDb21tYW5kTGluZVRvb2xzVmVyc2lvbiAoKSB7XG4gIC8vIHRoZXJlIGFyZSBhIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB0aGF0IHRoZSBDTEkgdG9vbHMgdmVyc2lvbiBoYXMgYmVlblxuICAvLyByZXByZXNlbnRlZC4gVHJ5IHRoZW0gZnJvbSBtb3N0IHJlbGlhYmxlIHRvIGxlYXN0LCBmYWxsaW5nIGRvd24gdGhlIGNoYWluXG4gIGNvbnN0IGdldFZlcnNpb25GdW5jdGlvbnMgPSBbXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHBrZyA9IChhd2FpdCBleGVjKCdwa2d1dGlsJywgWyctLXBrZ3M9Y29tLmFwcGxlLnBrZy5EZXZTREtfLionXSkpLnN0ZG91dDtcbiAgICAgIHJldHVybiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz0ke3BrZy50cmltKCl9YF0pKS5zdGRvdXQ7XG4gICAgfSxcbiAgICBhc3luYyAoKSA9PiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz1jb20uYXBwbGUucGtnLkNMVG9vbHNfRXhlY3V0YWJsZXNgXSkpLnN0ZG91dCxcbiAgICBhc3luYyAoKSA9PiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz1jb20uYXBwbGUucGtnLkRldmVsb3BlclRvb2xzQ0xJYF0pKS5zdGRvdXQsXG4gIF07XG4gIGxldCBzdGRvdXQ7XG4gIGZvciAobGV0IGdldFZlcnNpb24gb2YgZ2V0VmVyc2lvbkZ1bmN0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBzdGRvdXQgPSBhd2FpdCBnZXRWZXJzaW9uKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoIChpZ24pIHtcbiAgICAgIHN0ZG91dCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIC8vIHN0ZG91dCBzaG91bGQgaGF2ZSBhIGxpbmUgbGlrZSBgdmVyc2lvbjogOC4wLjAuMC4xLjE0NzI0MzU4ODFgXG4gIGxldCBtYXRjaCA9IC9edmVyc2lvbjogKC4rKSQvbS5leGVjKHN0ZG91dCk7IC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvSFYzeDRkLzFcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaHR0cHM6Ly90cmFjLm1hY3BvcnRzLm9yZy93aWtpL1hjb2RlVmVyc2lvbkluZm9cbiAqIHRvIHNlZSB0aGUgYWN0dWFsIG1hcHBpbmcgYmV0d2VlbiBjbGFuZyBhbmQgb3RoZXIgY29tcG9uZW50cy5cbiAqXG4gKiBAcmV0dXJucyB7P3N0cmluZ30gVGhlIGFjdHVhbCBDbGFuZyB2ZXJzaW9uIGluIHgueC54Lnggb3IgeC54LnggZm9ybWF0LFxuICogd2hpY2ggaXMgc3VwcGxpZWQgd2l0aCBDb21tYW5kIExpbmUgVG9vbHMuIGBudWxsYCBpcyByZXR1cm5lZFxuICogaWYgQ0xUIGFyZSBub3QgaW5zdGFsbGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRDbGFuZ1ZlcnNpb24gKCkge1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndoaWNoKCdjbGFuZycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmluZm8oJ0Nhbm5vdCBmaW5kIGNsYW5nIGV4ZWN1dGFibGUgb24gdGhlIGxvY2FsIHN5c3RlbS4gJyArXG4gICAgICAnQXJlIFhjb2RlIENvbW1hbmQgTGluZSBUb29scyBpbnN0YWxsZWQ/Jyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdjbGFuZycsIFsnLS12ZXJzaW9uJ10pO1xuICBjb25zdCBtYXRjaCA9IC9jbGFuZy0oWzAtOS5dKykvLmV4ZWMoc3Rkb3V0KTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIGxvZy5pbmZvKGBDYW5ub3QgcGFyc2UgY2xhbmcgdmVyc2lvbiBmcm9tICR7c3Rkb3V0fWApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBtYXRjaFsxXTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoV2l0aG91dFJldHJ5ICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCB4Y29kZVBhdGggPSBhd2FpdCBnZXRQYXRoKHRpbWVvdXQpO1xuXG4gIC8vIGZvciBpb3MgOCBhbmQgdXAsIHRoZSBmaWxlIGV4dGVuc2lvbiBmb3IgQXV0aW9tYXRpb25JbnN0cnVtZW50IGNoYW5nZWQuXG4gIC8vIHJhdGhlciB0aGFuIHdhc3RlIHRpbWUgZ2V0dGluZyB0aGUgaU9TU0RLVmVyc2lvbiwganVzdCBnZXQgYm90aCBwYXRocyBhbmQgc2VlIHdoaWNoIG9uZSBleGlzdHNcbiAgY29uc3QgZXh0ZW5zaW9ucyA9IFsneHJwbHVnaW4nLCAnYnVuZGxlJ107XG4gIGNvbnN0IHBhdGhQcmVmaXggPSBwYXRoLnJlc29sdmUoeGNvZGVQYXRoLCAnLi4vQXBwbGljYXRpb25zL0luc3RydW1lbnRzLmFwcC9Db250ZW50cy9QbHVnSW5zJyk7XG4gIGNvbnN0IHBhdGhTdWZmaXggPSAnQ29udGVudHMvUmVzb3VyY2VzL0F1dG9tYXRpb24udHJhY2V0ZW1wbGF0ZSc7XG4gIGxldCBhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzID0gW1xuICAgIHBhdGgucmVzb2x2ZShwYXRoUHJlZml4LCBgQXV0b21hdGlvbkluc3RydW1lbnQuJHtleHRlbnNpb25zWzBdfWAsIHBhdGhTdWZmaXgpLFxuICAgIHBhdGgucmVzb2x2ZShwYXRoUHJlZml4LCBgQXV0b21hdGlvbkluc3RydW1lbnQuJHtleHRlbnNpb25zWzFdfWAsIHBhdGhTdWZmaXgpXG4gIF07XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyhhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzBdKSkge1xuICAgIHJldHVybiBhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzBdO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyhhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzFdKSkge1xuICAgIHJldHVybiBhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzFdO1xuICB9XG5cbiAgY29uc3QgbXNnID0gJ0NvdWxkIG5vdCBmaW5kIEF1dG9tYXRpb24udHJhY2V0ZW1wbGF0ZSBpbiBhbnkgb2YgdGhlIGZvbGxvd2luZycgK1xuICAgICAgICAgICAgICBgbG9jYXRpb25zICR7YXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRocy50b1N0cmluZygpfWA7XG4gIGxvZy5lcnJvcihtc2cpO1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcblxufVxuXG5jb25zdCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGggPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aCAocmV0cmllcyA9IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMsIHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gICAgcmV0dXJuIHJldHJ5KHJldHJpZXMsIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE1heElPU1NES1dpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IGdldFZlcnNpb24oZmFsc2UsIERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMsIHRpbWVvdXQpO1xuICBpZiAodmVyc2lvblswXSA9PT0gJzQnKSB7XG4gICAgcmV0dXJuICc2LjEnO1xuICB9XG5cbiAgY29uc3QgYXJncyA9IFsnLS1zZGsnLCAnaXBob25lc2ltdWxhdG9yJywgJy0tc2hvdy1zZGstdmVyc2lvbiddO1xuICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHJ1blhjcnVuQ29tbWFuZChhcmdzLCB0aW1lb3V0KTtcblxuICBjb25zdCBzZGtWZXJzaW9uID0gc3Rkb3V0LnRyaW0oKTtcbiAgY29uc3QgbWF0Y2ggPSAvXFxkLlxcZC8uZXhlYyhzdGRvdXQpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHhjcnVuIHJldHVybmVkIGEgbm9uLW51bWVyaWMgaU9TIFNESyB2ZXJzaW9uOiAnJHtzZGtWZXJzaW9ufSdgKTtcbiAgfVxuXG4gIHJldHVybiBzZGtWZXJzaW9uO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRNYXhJT1NTREtGcm9tWGNvZGVWZXJzaW9uICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbih0cnVlLCBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0KTtcbiAgLy8gYXMgb2Ygbm93LCB0aGUgaU9TIHZlcnNpb24gYXNzb2NpYXRlZCB3aXRoIGFuIFhjb2RlIHZlcnNpb24gaXNcbiAgLy8ganVzdCB0aGUgWGNvZGUgdmVyc2lvbiArIDJcbiAgcmV0dXJuIGAke3ZlcnNpb24ubWFqb3IgKyAyfS4ke3ZlcnNpb24ubWlub3J9YDtcbn1cblxuY29uc3QgZ2V0TWF4SU9TU0RLID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiBnZXRNYXhJT1NTREsgKHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5LCB0aW1lb3V0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBVbmFibGUgdG8gcmV0cmlldmUgbWF4aW11bSBpT1MgdmVyc2lvbjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIGxvZy53YXJuKCdHdWVzc2luZyBmcm9tIFhjb2RlIHZlcnNpb24nKTtcbiAgICAgIHJldHVybiBnZXRNYXhJT1NTREtGcm9tWGNvZGVWZXJzaW9uKHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0TWF4VFZPU1NES1dpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgYXJncyA9IFsnLS1zZGsnLCAnYXBwbGV0dnNpbXVsYXRvcicsICctLXNob3ctc2RrLXZlcnNpb24nXTtcbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBydW5YY3J1bkNvbW1hbmQoYXJncywgdGltZW91dCk7XG5cbiAgY29uc3Qgc2RrVmVyc2lvbiA9IHN0ZG91dC50cmltKCk7XG5cbiAgaWYgKGlzTmFOKHBhcnNlRmxvYXQoc2RrVmVyc2lvbikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB4Y3J1biByZXR1cm5lZCBhIG5vbi1udW1lcmljIHR2T1MgU0RLIHZlcnNpb246ICcke3Nka1ZlcnNpb259J2ApO1xuICB9XG5cbiAgcmV0dXJuIHNka1ZlcnNpb247XG59XG5cbmNvbnN0IGdldE1heFRWT1NTREsgPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIGdldE1heFRWT1NTREsgKHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAgIHJldHVybiByZXRyeShyZXRyaWVzLCBnZXRNYXhUVk9TU0RLV2l0aG91dFJldHJ5LCB0aW1lb3V0KTtcbiAgfVxuKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRGV2aWNlcyAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgY21kID0gJy91c3Ivc2Jpbi9zeXN0ZW1fcHJvZmlsZXInO1xuICBjb25zdCBhcmdzID0gWycteG1sJywgJ1NQVVNCRGF0YVR5cGUnXTtcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjbWQsIGFyZ3MsIHt0aW1lb3V0fSk7XG4gIGxldCBwbGlzdENvbnRlbnQgPSBwYXJzZVBsaXN0RGF0YShzdGRvdXQpO1xuXG4gIGxldCBkZXZpY2VzRm91bmQgPSBbXTtcbiAgbGV0IGVudHJpZXNUb1NlYXJjaCA9IFtwbGlzdENvbnRlbnRbMF1dO1xuICB3aGlsZSAoZW50cmllc1RvU2VhcmNoLmxlbmd0aCA+IDApIHtcbiAgICBsZXQgY3VycmVudEVudHJ5ID0gZW50cmllc1RvU2VhcmNoLnBvcCgpO1xuICAgIGlmIChjdXJyZW50RW50cnkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZW50cmllc1RvU2VhcmNoID0gZW50cmllc1RvU2VhcmNoLmNvbmNhdChjdXJyZW50RW50cnkpO1xuICAgIH0gZWxzZSBpZiAoKGN1cnJlbnRFbnRyeS5fbmFtZSAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbnRyeS5fbmFtZS5zdWJzdHJpbmcoMCwgNCkgPT09ICdpUGFkJykgfHxcbiAgICAgICAgICAgICAgIChjdXJyZW50RW50cnkuX25hbWUgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50RW50cnkuX25hbWUuc3Vic3RyaW5nKDAsIDYpID09PSAnaVBob25lJykgfHxcbiAgICAgICAgICAgICAgIChjdXJyZW50RW50cnkuX25hbWUgJiYgXy5pbmNsdWRlcyhjdXJyZW50RW50cnkuX25hbWUsICdBcHBsZSBUVicpKSkge1xuICAgICAgbGV0IGRldmljZUluZm8gPSB7XG4gICAgICAgIG5hbWU6IGN1cnJlbnRFbnRyeS5fbmFtZSxcbiAgICAgICAgdWRpZDogY3VycmVudEVudHJ5LnNlcmlhbF9udW0sXG4gICAgICAgIHByb2R1Y3RJZDogY3VycmVudEVudHJ5LnByb2R1Y3RfaWQsXG4gICAgICAgIGRldmljZVZlcnNpb246IGN1cnJlbnRFbnRyeS5iY2RfZGV2aWNlXG4gICAgICB9O1xuICAgICAgZGV2aWNlc0ZvdW5kLnB1c2goZGV2aWNlSW5mbyk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50RW50cnkuX2l0ZW1zKSB7XG4gICAgICBlbnRyaWVzVG9TZWFyY2ggPSBlbnRyaWVzVG9TZWFyY2guY29uY2F0KGN1cnJlbnRFbnRyeS5faXRlbXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGV2aWNlc0ZvdW5kO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRJbnN0cnVtZW50c1BhdGhXaXRob3V0UmV0cnkgKHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gIGNvbnN0IGFyZ3MgPSBbJy1maW5kJywgJ2luc3RydW1lbnRzJ107XG4gIGxldCB7c3Rkb3V0fSA9IGF3YWl0IHJ1blhjcnVuQ29tbWFuZChhcmdzLCB0aW1lb3V0KTtcblxuICBpZiAoIXN0ZG91dCkge1xuICAgIHN0ZG91dCA9ICcnO1xuICB9XG5cbiAgbGV0IGluc3RydW1lbnRzUGF0aCA9IHN0ZG91dC50cmltKCk7XG5cbiAgaWYgKCFpbnN0cnVtZW50c1BhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBhdGggdG8gaW5zdHJ1bWVudHMgYmluYXJ5IHVzaW5nICd4Y3J1biAke2FyZ3Muam9pbignICcpfSdgKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0cnVtZW50c1BhdGg7XG59XG5cbmNvbnN0IGdldEluc3RydW1lbnRzUGF0aCA9IF8ubWVtb2l6ZShcbiAgZnVuY3Rpb24gZ2V0SW5zdHJ1bWVudHNQYXRoIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0SW5zdHJ1bWVudHNQYXRoV2l0aG91dFJldHJ5LCB0aW1lb3V0KTtcbiAgfVxuKTtcblxuZnVuY3Rpb24gY2xlYXJJbnRlcm5hbENhY2hlICgpIHtcblxuICAvLyBtZW1vaXplZCBmdW5jdGlvbnNcbiAgY29uc3QgbWVtb2l6ZWQgPSBbXG4gICAgZ2V0UGF0aCwgZ2V0VmVyc2lvbk1lbW9pemVkLCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGgsIGdldE1heElPU1NESyxcbiAgICBnZXRNYXhUVk9TU0RLLCBnZXRJbnN0cnVtZW50c1BhdGgsXG4gIF07XG5cbiAgbWVtb2l6ZWQuZm9yRWFjaCgoZikgPT4ge1xuICAgIGlmIChmLmNhY2hlKSB7XG4gICAgICBmLmNhY2hlID0gbmV3IF8ubWVtb2l6ZS5DYWNoZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7XG4gIGdldFBhdGgsIGdldFZlcnNpb24sIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aCwgZ2V0TWF4SU9TU0RLLFxuICBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhXaXRob3V0UmV0cnksIGdldE1heElPU1NES1dpdGhvdXRSZXRyeSxcbiAgZ2V0Q29ubmVjdGVkRGV2aWNlcywgY2xlYXJJbnRlcm5hbENhY2hlLCBnZXRJbnN0cnVtZW50c1BhdGgsXG4gIGdldENvbW1hbmRMaW5lVG9vbHNWZXJzaW9uLCBnZXRNYXhUVk9TU0RLLCBnZXRNYXhUVk9TU0RLV2l0aG91dFJldHJ5LFxuICBnZXRDbGFuZ1ZlcnNpb24sXG59O1xuIl0sImZpbGUiOiJsaWIveGNvZGUuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
