"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TrustStore = exports.Certificate = void 0;

require("source-map-support/register");

var _crypto = _interopRequireDefault(require("crypto"));

var _teen_process = require("teen_process");

var _path = _interopRequireDefault(require("path"));

var _support = require("@appium/support");

var _utils = require("./utils");

var _logger = _interopRequireDefault(require("./logger"));

var _lodash = _interopRequireDefault(require("lodash"));

const tset = `<?xml version="1.0" encoding="UTF-8"?>\n
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <array/>
</plist>`;

class Certificate {
  constructor(pemFilename) {
    this.pemFilename = pemFilename;
    this.opensslBinary = null;
    this.fingerprint = null;
    this.data = null;
    this.subject = null;
  }

  async openssl(...args) {
    if (!this.opensslBinary) {
      try {
        this.opensslBinary = await _support.fs.which('openssl');
      } catch (e) {
        throw new Error('openssl executable cannot be found in PATH. Make sure it is installed');
      }
    }

    _logger.default.debug(`Executing ${this.opensslBinary} with arguments: ${args}`);

    let result;

    try {
      const {
        stdout
      } = await (0, _teen_process.exec)(this.opensslBinary, args);
      result = stdout;
    } catch (e) {
      if (e.stderr) {
        throw new Error(e.stderr);
      }

      throw e;
    }

    return result;
  }

  async add(dir) {
    let data = (await this.getDerData(this.pemFilename)).toString('hex');
    let subject = await this.getSubject(this.pemFilename);
    let sha1 = (await this.getFingerPrint(this.data)).toString('hex');
    let trustStore = new TrustStore(dir);
    return await trustStore.addRecord(sha1, tset, subject, data);
  }

  async has(dir) {
    let subject = await this.getSubject(this.pemFilename);
    let trustStore = new TrustStore(dir);

    if (!(await trustStore.hasRecords(subject))) {
      return false;
    }

    let previousFingerprint = await trustStore.getFingerPrintFromRecord(subject);
    let currentFingerprint = await this.getFingerPrint();
    return previousFingerprint.toString() === currentFingerprint.toString();
  }

  async remove(dir) {
    let subject = await this.getSubject(this.pemFilename);
    let trustStore = new TrustStore(dir);
    return await trustStore.removeRecord(subject);
  }

  async getDerData() {
    if (this.data) {
      return this.data;
    }

    const output = await this.openssl('x509', '-outform', 'der', '-in', this.pemFilename);
    this.data = Buffer.from(_lodash.default.trim(output));
    return this.data;
  }

  async getFingerPrint() {
    if (this.fingerprint) {
      return this.fingerprint;
    }

    let data = await this.getDerData();

    let shasum = _crypto.default.createHash('sha1');

    shasum.update(data);
    this.fingerprint = shasum.digest();
    return this.fingerprint;
  }

  async getSubject() {
    if (this.subject) {
      return this.subject;
    }

    const subject = await this.openssl('x509', '-noout', '-subject', '-in', this.pemFilename);
    const match = /^\s*subject=.*\bCN\b\s*=\s*([^\n]+)$/m.exec(subject);

    if (!match) {
      _logger.default.debug(subject);

      throw new Error(`Cannot parse certificate subject from the openssl output`);
    }

    this.subject = match[1];
    return this.subject;
  }

}

exports.Certificate = Certificate;

class TrustStore {
  constructor(sharedResourceDir) {
    this.sharedResourceDir = sharedResourceDir;
  }

  async getDB() {
    if (this.db) {
      return this.db;
    }

    let keychainsPath = _path.default.resolve(this.sharedResourceDir, 'Library', 'Keychains');

    if (!(await _support.fs.exists(keychainsPath))) {
      await (0, _support.mkdirp)(keychainsPath);
    }

    this.db = _path.default.resolve(keychainsPath, 'TrustStore.sqlite3');
    await (0, _utils.execSQLiteQuery)(this.db, `CREATE TABLE IF NOT EXISTS tsettings (sha1 BLOB NOT NULL DEFAULT '', subj BLOB NOT NULL DEFAULT '', tset BLOB, data BLOB, PRIMARY KEY(sha1));`);

    try {
      await (0, _utils.execSQLiteQuery)(this.db, 'CREATE INDEX isubj ON tsettings(subj);');
    } catch (e) {}

    return this.db;
  }

  async addRecord(sha1, tset, subj, data) {
    let db = await this.getDB();

    if (await this.hasRecords(subj)) {
      return await (0, _utils.execSQLiteQuery)(db, `UPDATE tsettings SET sha1=x'?', tset='?', data=x'?' WHERE subj='?'`, sha1, tset, data, subj);
    } else {
      return await (0, _utils.execSQLiteQuery)(db, `INSERT INTO tsettings (sha1, subj, tset, data) VALUES (x'?', '?', '?', x'?')`, sha1, subj, tset, data);
    }
  }

  async removeRecord(subj) {
    return await (0, _utils.execSQLiteQuery)(await this.getDB(), `DELETE FROM tsettings WHERE subj = '?'`, subj);
  }

  async hasRecords(subj) {
    return (await this.getRecordCount(subj)) > 0;
  }

  async getRecordCount(subj) {
    let result = await (0, _utils.execSQLiteQuery)(await this.getDB(), `SELECT count(*) FROM tsettings WHERE subj = '?'`, subj);
    return parseInt(result.split('=')[1], 10);
  }

  async getFingerPrintFromRecord(subj) {
    let result = await (0, _utils.execSQLiteQuery)(await this.getDB(), `SELECT sha1 FROM tsettings WHERE subj='?'`, subj);

    if (result) {
      return Buffer.from(result.split('=')[1].trim());
    }
  }

}

exports.TrustStore = TrustStore;
var _default = Certificate;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL2NlcnRpZmljYXRlLmpzIiwibmFtZXMiOlsidHNldCIsIkNlcnRpZmljYXRlIiwiY29uc3RydWN0b3IiLCJwZW1GaWxlbmFtZSIsIm9wZW5zc2xCaW5hcnkiLCJmaW5nZXJwcmludCIsImRhdGEiLCJzdWJqZWN0Iiwib3BlbnNzbCIsImFyZ3MiLCJmcyIsIndoaWNoIiwiZSIsIkVycm9yIiwibG9nIiwiZGVidWciLCJyZXN1bHQiLCJzdGRvdXQiLCJleGVjIiwic3RkZXJyIiwiYWRkIiwiZGlyIiwiZ2V0RGVyRGF0YSIsInRvU3RyaW5nIiwiZ2V0U3ViamVjdCIsInNoYTEiLCJnZXRGaW5nZXJQcmludCIsInRydXN0U3RvcmUiLCJUcnVzdFN0b3JlIiwiYWRkUmVjb3JkIiwiaGFzIiwiaGFzUmVjb3JkcyIsInByZXZpb3VzRmluZ2VycHJpbnQiLCJnZXRGaW5nZXJQcmludEZyb21SZWNvcmQiLCJjdXJyZW50RmluZ2VycHJpbnQiLCJyZW1vdmUiLCJyZW1vdmVSZWNvcmQiLCJvdXRwdXQiLCJCdWZmZXIiLCJmcm9tIiwiXyIsInRyaW0iLCJzaGFzdW0iLCJjcnlwdG8iLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwibWF0Y2giLCJzaGFyZWRSZXNvdXJjZURpciIsImdldERCIiwiZGIiLCJrZXljaGFpbnNQYXRoIiwicGF0aCIsInJlc29sdmUiLCJleGlzdHMiLCJta2RpcnAiLCJleGVjU1FMaXRlUXVlcnkiLCJzdWJqIiwiZ2V0UmVjb3JkQ291bnQiLCJwYXJzZUludCIsInNwbGl0Il0sInNvdXJjZVJvb3QiOiIuLi8uLiIsInNvdXJjZXMiOlsibGliL2NlcnRpZmljYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBmcywgbWtkaXJwIH0gZnJvbSAnQGFwcGl1bS9zdXBwb3J0JztcbmltcG9ydCB7IGV4ZWNTUUxpdGVRdWVyeSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCB0c2V0ID0gYDw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/PlxcblxuICAgIDwhRE9DVFlQRSBwbGlzdCBQVUJMSUMgXCItLy9BcHBsZS8vRFREIFBMSVNUIDEuMC8vRU5cIiBcImh0dHA6Ly93d3cuYXBwbGUuY29tL0RURHMvUHJvcGVydHlMaXN0LTEuMC5kdGRcIj5cbiAgICA8cGxpc3QgdmVyc2lvbj1cIjEuMFwiPlxuICAgIDxhcnJheS8+XG48L3BsaXN0PmA7XG5cbi8qKlxuICogTGlicmFyeSBmb3IgcHJvZ3JhbWF0aWNhbGx5IGFkZGluZyBjZXJ0aWZpY2F0ZXNcbiAqL1xuY2xhc3MgQ2VydGlmaWNhdGUge1xuXG4gIGNvbnN0cnVjdG9yIChwZW1GaWxlbmFtZSkge1xuICAgIHRoaXMucGVtRmlsZW5hbWUgPSBwZW1GaWxlbmFtZTtcbiAgICB0aGlzLm9wZW5zc2xCaW5hcnkgPSBudWxsO1xuICAgIHRoaXMuZmluZ2VycHJpbnQgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5zdWJqZWN0ID0gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIG9wZW5zc2wgKC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMub3BlbnNzbEJpbmFyeSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5vcGVuc3NsQmluYXJ5ID0gYXdhaXQgZnMud2hpY2goJ29wZW5zc2wnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcGVuc3NsIGV4ZWN1dGFibGUgY2Fubm90IGJlIGZvdW5kIGluIFBBVEguIE1ha2Ugc3VyZSBpdCBpcyBpbnN0YWxsZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsb2cuZGVidWcoYEV4ZWN1dGluZyAke3RoaXMub3BlbnNzbEJpbmFyeX0gd2l0aCBhcmd1bWVudHM6ICR7YXJnc31gKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5vcGVuc3NsQmluYXJ5LCBhcmdzKTtcbiAgICAgIHJlc3VsdCA9IHN0ZG91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5zdGRlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUuc3RkZXJyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY2VydGlmaWNhdGUgdG8gdGhlIFRydXN0U3RvcmVcbiAgICovXG4gIGFzeW5jIGFkZCAoZGlyKSB7XG4gICAgbGV0IGRhdGEgPSAoYXdhaXQgdGhpcy5nZXREZXJEYXRhKHRoaXMucGVtRmlsZW5hbWUpKS50b1N0cmluZygnaGV4Jyk7XG4gICAgbGV0IHN1YmplY3QgPSAoYXdhaXQgdGhpcy5nZXRTdWJqZWN0KHRoaXMucGVtRmlsZW5hbWUpKTtcbiAgICBsZXQgc2hhMSA9IChhd2FpdCB0aGlzLmdldEZpbmdlclByaW50KHRoaXMuZGF0YSkpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIGxldCB0cnVzdFN0b3JlID0gbmV3IFRydXN0U3RvcmUoZGlyKTtcbiAgICByZXR1cm4gYXdhaXQgdHJ1c3RTdG9yZS5hZGRSZWNvcmQoc2hhMSwgdHNldCwgc3ViamVjdCwgZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGtleWNoYWluIGF0IGdpdmVuIGRpcmVjdG9yeSBoYXMgdGhpcyBjZXJ0aWZpY2F0ZVxuICAgKi9cbiAgYXN5bmMgaGFzIChkaXIpIHtcbiAgICBsZXQgc3ViamVjdCA9IGF3YWl0IHRoaXMuZ2V0U3ViamVjdCh0aGlzLnBlbUZpbGVuYW1lKTtcbiAgICBsZXQgdHJ1c3RTdG9yZSA9IG5ldyBUcnVzdFN0b3JlKGRpcik7XG5cbiAgICAvLyBSZXR1cm4gZmFsc2UgaWYgcmVjb3JkIHdpdGggdGhpcyBzdWJqZWN0IGlzIG5vdCBmb3VuZFxuICAgIGlmICghYXdhaXQgdHJ1c3RTdG9yZS5oYXNSZWNvcmRzKHN1YmplY3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgcmVjb3JkIGlzIGZvdW5kLCBjaGVjayBmaW5nZXJwcmludHMgdG8gdmVyaWZ5IHRoYXQgdGhleSBkaWRuJ3QgY2hhbmdlXG4gICAgbGV0IHByZXZpb3VzRmluZ2VycHJpbnQgPSBhd2FpdCB0cnVzdFN0b3JlLmdldEZpbmdlclByaW50RnJvbVJlY29yZChzdWJqZWN0KTtcbiAgICBsZXQgY3VycmVudEZpbmdlcnByaW50ID0gYXdhaXQgdGhpcy5nZXRGaW5nZXJQcmludCgpO1xuICAgIHJldHVybiBwcmV2aW91c0ZpbmdlcnByaW50LnRvU3RyaW5nKCkgPT09IGN1cnJlbnRGaW5nZXJwcmludC50b1N0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjZXJ0aWZpY2F0ZSBmcm9tIHRoZSBUcnVzdFN0b3JlXG4gICAqL1xuICBhc3luYyByZW1vdmUgKGRpcikge1xuICAgIGxldCBzdWJqZWN0ID0gYXdhaXQgdGhpcy5nZXRTdWJqZWN0KHRoaXMucGVtRmlsZW5hbWUpO1xuICAgIGxldCB0cnVzdFN0b3JlID0gbmV3IFRydXN0U3RvcmUoZGlyKTtcbiAgICByZXR1cm4gYXdhaXQgdHJ1c3RTdG9yZS5yZW1vdmVSZWNvcmQoc3ViamVjdCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNsYXRlIFBFTSBmaWxlIHRvIERFUiBidWZmZXJcbiAgICovXG4gIGFzeW5jIGdldERlckRhdGEgKCkge1xuICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCAncGVtJyBmaWxlIHRvICdkZXInXG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5vcGVuc3NsKCd4NTA5JyxcbiAgICAgICctb3V0Zm9ybScsICdkZXInLFxuICAgICAgJy1pbicsIHRoaXMucGVtRmlsZW5hbWVcbiAgICApO1xuICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKF8udHJpbShvdXRwdXQpKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBTSEExIGZpbmdlcnByaW50IGZyb20gZGVyIGRhdGEgYmVmb3JlXG4gICAqL1xuICBhc3luYyBnZXRGaW5nZXJQcmludCAoKSB7XG4gICAgaWYgKHRoaXMuZmluZ2VycHJpbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmdlcnByaW50O1xuICAgIH1cblxuICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy5nZXREZXJEYXRhKCk7XG4gICAgbGV0IHNoYXN1bSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG4gICAgc2hhc3VtLnVwZGF0ZShkYXRhKTtcbiAgICB0aGlzLmZpbmdlcnByaW50ID0gc2hhc3VtLmRpZ2VzdCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmdlcnByaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBzdWJqZWN0IGZyb20gdGhlIGRlciBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRTdWJqZWN0ICgpIHtcbiAgICBpZiAodGhpcy5zdWJqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdWJqZWN0O1xuICAgIH1cblxuICAgIGNvbnN0IHN1YmplY3QgPSBhd2FpdCB0aGlzLm9wZW5zc2woJ3g1MDknLFxuICAgICAgJy1ub291dCcsICctc3ViamVjdCcsXG4gICAgICAnLWluJywgdGhpcy5wZW1GaWxlbmFtZSxcbiAgICApO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vYXBwaXVtL2lzc3Vlcy8xNDY2NlxuICAgIGNvbnN0IG1hdGNoID0gL15cXHMqc3ViamVjdD0uKlxcYkNOXFxiXFxzKj1cXHMqKFteXFxuXSspJC9tLmV4ZWMoc3ViamVjdCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgbG9nLmRlYnVnKHN1YmplY3QpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgY2VydGlmaWNhdGUgc3ViamVjdCBmcm9tIHRoZSBvcGVuc3NsIG91dHB1dGApO1xuICAgIH1cbiAgICB0aGlzLnN1YmplY3QgPSBtYXRjaFsxXTtcbiAgICByZXR1cm4gdGhpcy5zdWJqZWN0O1xuICB9XG5cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVjb3JkcyB0byBUcnVzdFN0b3JlLnNxbGl0ZTMgZGF0YWJhc2VzIHRoYXQgS2V5Y2hhaW5zIHVzZVxuICovXG5jbGFzcyBUcnVzdFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKHNoYXJlZFJlc291cmNlRGlyKSB7XG4gICAgdGhpcy5zaGFyZWRSZXNvdXJjZURpciA9IHNoYXJlZFJlc291cmNlRGlyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBUcnVzdFN0b3JlIGRhdGFiYXNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNpbXVsYXRvclxuICAgKi9cbiAgYXN5bmMgZ2V0REIgKCkge1xuICAgIGlmICh0aGlzLmRiKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2ltIGRvZXNuJ3QgaGF2ZSBhIGtleWNoYWlucyBkaXJlY3RvcnksIGNyZWF0ZSBvbmVcbiAgICBsZXQga2V5Y2hhaW5zUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLnNoYXJlZFJlc291cmNlRGlyLCAnTGlicmFyeScsICdLZXljaGFpbnMnKTtcbiAgICBpZiAoIShhd2FpdCBmcy5leGlzdHMoa2V5Y2hhaW5zUGF0aCkpKSB7XG4gICAgICBhd2FpdCBta2RpcnAoa2V5Y2hhaW5zUGF0aCk7XG4gICAgfVxuXG4gICAgLy8gT3BlbiBzcWxpdGUgZGF0YWJhc2VcbiAgICB0aGlzLmRiID0gcGF0aC5yZXNvbHZlKGtleWNoYWluc1BhdGgsICdUcnVzdFN0b3JlLnNxbGl0ZTMnKTtcblxuICAgIC8vIElmIGl0IGRvZXNuJ3QgaGF2ZSBhIHRzZXR0aW5ncyB0YWJsZSwgY3JlYXRlIG9uZVxuICAgIGF3YWl0IGV4ZWNTUUxpdGVRdWVyeSh0aGlzLmRiLCBgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgdHNldHRpbmdzIChzaGExIEJMT0IgTk9UIE5VTEwgREVGQVVMVCAnJywgc3ViaiBCTE9CIE5PVCBOVUxMIERFRkFVTFQgJycsIHRzZXQgQkxPQiwgZGF0YSBCTE9CLCBQUklNQVJZIEtFWShzaGExKSk7YCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4ZWNTUUxpdGVRdWVyeSh0aGlzLmRiLCAnQ1JFQVRFIElOREVYIGlzdWJqIE9OIHRzZXR0aW5ncyhzdWJqKTsnKTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuXG4gICAgcmV0dXJuIHRoaXMuZGI7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHJlY29yZCB0byB0c2V0dGluZ3NcbiAgICovXG4gIGFzeW5jIGFkZFJlY29yZCAoc2hhMSwgdHNldCwgc3ViaiwgZGF0YSkge1xuICAgIGxldCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICBpZiAoYXdhaXQgdGhpcy5oYXNSZWNvcmRzKHN1YmopKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZXhlY1NRTGl0ZVF1ZXJ5KGRiLCBgVVBEQVRFIHRzZXR0aW5ncyBTRVQgc2hhMT14Jz8nLCB0c2V0PSc/JywgZGF0YT14Jz8nIFdIRVJFIHN1Ymo9Jz8nYCwgc2hhMSwgdHNldCwgZGF0YSwgc3Viaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhd2FpdCBleGVjU1FMaXRlUXVlcnkoZGIsIGBJTlNFUlQgSU5UTyB0c2V0dGluZ3MgKHNoYTEsIHN1YmosIHRzZXQsIGRhdGEpIFZBTFVFUyAoeCc/JywgJz8nLCAnPycsIHgnPycpYCwgc2hhMSwgc3ViaiwgdHNldCwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSByZWNvcmQgZnJvbSB0c2V0dGluZ3MgdGhhdCBtYXRjaGVzIHRoZSBzdWJqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJqXG4gICAqL1xuICBhc3luYyByZW1vdmVSZWNvcmQgKHN1YmopIHtcbiAgICByZXR1cm4gYXdhaXQgZXhlY1NRTGl0ZVF1ZXJ5KGF3YWl0IHRoaXMuZ2V0REIoKSwgYERFTEVURSBGUk9NIHRzZXR0aW5ncyBXSEVSRSBzdWJqID0gJz8nYCwgc3Viaik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVjb3JkIGZyb20gdHNldHRpbmdzIHRoYXQgbWF0Y2hlcyB0aGUgc3VialxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3VialxuICAgKi9cbiAgYXN5bmMgaGFzUmVjb3JkcyAoc3Viaikge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRSZWNvcmRDb3VudChzdWJqKSkgPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb3VudCBvZiBob3cgbWFueSByZWNvcmRzIGhhdmUgdGhpcyBzdWJqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJqXG4gICAqL1xuICBhc3luYyBnZXRSZWNvcmRDb3VudCAoc3Viaikge1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBleGVjU1FMaXRlUXVlcnkoYXdhaXQgdGhpcy5nZXREQigpLCBgU0VMRUNUIGNvdW50KCopIEZST00gdHNldHRpbmdzIFdIRVJFIHN1YmogPSAnPydgLCBzdWJqKTtcbiAgICByZXR1cm4gcGFyc2VJbnQocmVzdWx0LnNwbGl0KCc9JylbMV0sIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFNIQTEgZmluZ2VycHJpbnQgZm9yIHRoZSByZWNvcmQgdGhhdCBoYXMgdGhpcyBzdWJqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJqXG4gICAqL1xuICBhc3luYyBnZXRGaW5nZXJQcmludEZyb21SZWNvcmQgKHN1YmopIHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgZXhlY1NRTGl0ZVF1ZXJ5KGF3YWl0IHRoaXMuZ2V0REIoKSwgYFNFTEVDVCBzaGExIEZST00gdHNldHRpbmdzIFdIRVJFIHN1Ymo9Jz8nYCwgc3Viaik7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlc3VsdC5zcGxpdCgnPScpWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENlcnRpZmljYXRlO1xuZXhwb3J0IHsgQ2VydGlmaWNhdGUsIFRydXN0U3RvcmUgfTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxJQUFJLEdBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUpBOztBQVNBLE1BQU1DLFdBQU4sQ0FBa0I7RUFFaEJDLFdBQVcsQ0FBRUMsV0FBRixFQUFlO0lBQ3hCLEtBQUtBLFdBQUwsR0FBbUJBLFdBQW5CO0lBQ0EsS0FBS0MsYUFBTCxHQUFxQixJQUFyQjtJQUNBLEtBQUtDLFdBQUwsR0FBbUIsSUFBbkI7SUFDQSxLQUFLQyxJQUFMLEdBQVksSUFBWjtJQUNBLEtBQUtDLE9BQUwsR0FBZSxJQUFmO0VBQ0Q7O0VBRVksTUFBUEMsT0FBTyxDQUFFLEdBQUdDLElBQUwsRUFBVztJQUN0QixJQUFJLENBQUMsS0FBS0wsYUFBVixFQUF5QjtNQUN2QixJQUFJO1FBQ0YsS0FBS0EsYUFBTCxHQUFxQixNQUFNTSxXQUFBLENBQUdDLEtBQUgsQ0FBUyxTQUFULENBQTNCO01BQ0QsQ0FGRCxDQUVFLE9BQU9DLENBQVAsRUFBVTtRQUNWLE1BQU0sSUFBSUMsS0FBSixDQUFVLHVFQUFWLENBQU47TUFDRDtJQUNGOztJQUVEQyxlQUFBLENBQUlDLEtBQUosQ0FBVyxhQUFZLEtBQUtYLGFBQWMsb0JBQW1CSyxJQUFLLEVBQWxFOztJQUNBLElBQUlPLE1BQUo7O0lBQ0EsSUFBSTtNQUNGLE1BQU07UUFBQ0M7TUFBRCxJQUFXLE1BQU0sSUFBQUMsa0JBQUEsRUFB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
