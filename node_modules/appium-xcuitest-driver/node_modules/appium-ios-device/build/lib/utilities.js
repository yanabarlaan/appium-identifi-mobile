"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectPort = connectPort;
exports.connectPortSSL = connectPortSSL;
exports.getConnectedDevices = getConnectedDevices;
exports.getDeviceInfo = getDeviceInfo;
exports.getDeviceName = getDeviceName;
exports.getDeviceTime = getDeviceTime;
exports.getOSVersion = getOSVersion;
exports.startLockdownSession = startLockdownSession;

require("source-map-support/register");

var _usbmux = _interopRequireWildcard(require("./usbmux"));

var _sslHelper = require("./ssl-helper");

var _lodash = _interopRequireDefault(require("lodash"));

var _logger = _interopRequireDefault(require("./logger"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const LOCKDOWN_REQUEST = {
  DEVICE_TIME: {
    Key: 'TimeIntervalSince1970'
  },
  DEVICE_UTC_OFFSET: {
    Key: 'TimeZoneOffsetFromUTC'
  },
  DEVICE_TIME_ZONE: {
    Key: 'TimeZone'
  },
  DEVICE_VERSION: {
    Key: 'ProductVersion'
  },
  DEVICE_NAME: {
    Key: 'DeviceName'
  }
};

async function getConnectedDevices(socket = null) {
  let usbmux;

  try {
    usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));
  } catch (e) {
    _logger.default.debug(e);

    return [];
  }

  try {
    const devices = await usbmux.listDevices();
    const udids = devices.map(device => device.Properties.SerialNumber);
    return _lodash.default.uniq(udids);
  } finally {
    usbmux.close();
  }
}

async function getOSVersion(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const lockdown = await usbmux.connectLockdown(udid);
    return await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_VERSION);
  } finally {
    usbmux.close();
  }
}

async function getDeviceName(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const lockdown = await usbmux.connectLockdown(udid);
    return await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_NAME);
  } finally {
    usbmux.close();
  }
}

async function getDeviceInfo(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const lockdown = await usbmux.connectLockdown(udid);
    return await lockdown.getValue();
  } finally {
    usbmux.close();
  }
}

async function getDeviceTime(udid, socket = null) {
  const lockdown = await startLockdownSession(udid, socket);

  try {
    return {
      timestamp: await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_TIME),
      utcOffset: (await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_UTC_OFFSET)) / 60,
      timeZone: await lockdown.getValue(LOCKDOWN_REQUEST.DEVICE_TIME_ZONE)
    };
  } finally {
    lockdown.close();
  }
}

async function startLockdownSession(udid, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const pairRecord = await usbmux.readPairRecord(udid);

    if (!pairRecord) {
      throw new Error(`Could not find a pair record for device '${udid}'. Please first pair with the device`);
    }

    const lockdown = await usbmux.connectLockdown(udid);
    await lockdown.startSession(pairRecord.HostID, pairRecord.SystemBUID);
    lockdown.enableSessionSSL(pairRecord.HostPrivateKey, pairRecord.HostCertificate);
    return lockdown;
  } catch (e) {
    usbmux.close();
    throw e;
  }
}

async function connectPortSSL(udid, port, socket = null, handshakeOnly = false) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const device = await usbmux.findDevice(udid);

    if (!device) {
      throw new Error(`Could not find the expected device '${udid}'`);
    }

    const pairRecord = await usbmux.readPairRecord(udid);

    if (!pairRecord) {
      throw new Error(`Could not find a pair record for device '${udid}'. Please first pair with the device`);
    }

    const socket = await usbmux.connect(device.Properties.DeviceID, port, undefined);
    return handshakeOnly ? await (0, _sslHelper.enableSSLHandshakeOnly)(socket, pairRecord.HostPrivateKey, pairRecord.HostCertificate) : (0, _sslHelper.upgradeToSSL)(socket, pairRecord.HostPrivateKey, pairRecord.HostCertificate);
  } catch (e) {
    usbmux.close();
    throw e;
  }
}

async function connectPort(udid, port, socket = null) {
  const usbmux = new _usbmux.default(socket || (await (0, _usbmux.getDefaultSocket)()));

  try {
    const device = await usbmux.findDevice(udid);

    if (!device) {
      throw new Error(`Could not find the expected device ${udid}`);
    }

    return await usbmux.connect(device.Properties.DeviceID, port, undefined);
  } catch (e) {
    usbmux.close();
    throw e;
  }
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL3V0aWxpdGllcy5qcyIsIm5hbWVzIjpbIkxPQ0tET1dOX1JFUVVFU1QiLCJERVZJQ0VfVElNRSIsIktleSIsIkRFVklDRV9VVENfT0ZGU0VUIiwiREVWSUNFX1RJTUVfWk9ORSIsIkRFVklDRV9WRVJTSU9OIiwiREVWSUNFX05BTUUiLCJnZXRDb25uZWN0ZWREZXZpY2VzIiwic29ja2V0IiwidXNibXV4IiwiVXNibXV4IiwiZSIsImxvZyIsImRlYnVnIiwiZGV2aWNlcyIsImxpc3REZXZpY2VzIiwidWRpZHMiLCJtYXAiLCJkZXZpY2UiLCJQcm9wZXJ0aWVzIiwiU2VyaWFsTnVtYmVyIiwiXyIsInVuaXEiLCJjbG9zZSIsImdldE9TVmVyc2lvbiIsInVkaWQiLCJsb2NrZG93biIsImNvbm5lY3RMb2NrZG93biIsImdldFZhbHVlIiwiZ2V0RGV2aWNlTmFtZSIsImdldERldmljZUluZm8iLCJnZXREZXZpY2VUaW1lIiwic3RhcnRMb2NrZG93blNlc3Npb24iLCJ0aW1lc3RhbXAiLCJ1dGNPZmZzZXQiLCJ0aW1lWm9uZSIsInBhaXJSZWNvcmQiLCJyZWFkUGFpclJlY29yZCIsIkVycm9yIiwic3RhcnRTZXNzaW9uIiwiSG9zdElEIiwiU3lzdGVtQlVJRCIsImVuYWJsZVNlc3Npb25TU0wiLCJIb3N0UHJpdmF0ZUtleSIsIkhvc3RDZXJ0aWZpY2F0ZSIsImNvbm5lY3RQb3J0U1NMIiwicG9ydCIsImhhbmRzaGFrZU9ubHkiLCJmaW5kRGV2aWNlIiwiY29ubmVjdCIsIkRldmljZUlEIiwidW5kZWZpbmVkIiwiY29ubmVjdFBvcnQiXSwic291cmNlUm9vdCI6Ii4uLy4uIiwic291cmNlcyI6WyJsaWIvdXRpbGl0aWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBVc2JtdXgsIHsgZ2V0RGVmYXVsdFNvY2tldCB9IGZyb20gJy4vdXNibXV4JztcbmltcG9ydCB7IHVwZ3JhZGVUb1NTTCwgZW5hYmxlU1NMSGFuZHNoYWtlT25seSB9IGZyb20gJy4vc3NsLWhlbHBlcic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW1kbWFyc2hhbGwvaU9TLUludGVybmFscy9ibG9iL21hc3Rlci9sb2NrYm90L2xvY2tib3QvbG9ja2Rvd25fa2V5cy5oXG5jb25zdCBMT0NLRE9XTl9SRVFVRVNUID0ge1xuICBERVZJQ0VfVElNRTogeyBLZXk6ICdUaW1lSW50ZXJ2YWxTaW5jZTE5NzAnIH0sXG4gIERFVklDRV9VVENfT0ZGU0VUOiB7IEtleTogJ1RpbWVab25lT2Zmc2V0RnJvbVVUQycgfSxcbiAgREVWSUNFX1RJTUVfWk9ORTogeyBLZXk6ICdUaW1lWm9uZScgfSxcbiAgREVWSUNFX1ZFUlNJT046IHsgS2V5OiAnUHJvZHVjdFZlcnNpb24nIH0sXG4gIERFVklDRV9OQU1FOiB7IEtleTogJ0RldmljZU5hbWUnIH1cbn07XG5cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHVkaWRzIG9mIHRoZSBjb25uZWN0ZWQgZGV2aWNlc1xuICpcbiAqIEBwYXJhbSB7P25ldC5Tb2NrZXR9IHNvY2tldCB0aGUgc29ja2V0IG9mIHVzYm11eGQuIEl0IHdpbGwgZGVmYXVsdCB0byAvdmFyL3J1bi91c2JtdXhkIGlmIGl0IGlzIG5vdCBwYXNzZWRcbiAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gVGhlIGxpc3Qgb2YgZGV2aWNlIHNlcmlhbCBudW1iZXJzICh1ZGlkKSBvclxuICogYW4gZW1wdHkgbGlzdCBpZiBubyBkZXZpY2VzIGFyZSBjb25uZWN0ZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRGV2aWNlcyAoc29ja2V0ID0gbnVsbCkge1xuICBsZXQgdXNibXV4O1xuICB0cnkge1xuICAgIHVzYm11eCA9IG5ldyBVc2JtdXgoc29ja2V0IHx8IGF3YWl0IGdldERlZmF1bHRTb2NrZXQoKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZGVidWcoZSk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IHVzYm11eC5saXN0RGV2aWNlcygpO1xuICAgIGNvbnN0IHVkaWRzID0gZGV2aWNlcy5tYXAoKGRldmljZSkgPT4gZGV2aWNlLlByb3BlcnRpZXMuU2VyaWFsTnVtYmVyKTtcbiAgICByZXR1cm4gXy51bmlxKHVkaWRzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1c2JtdXguY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgb3MgdmVyc2lvbiBvZiB0aGUgZGV2aWNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgRGV2aWNlIFVESURcbiAqIEBwYXJhbSB7P25ldC5Tb2NrZXR9IHNvY2tldCB0aGUgc29ja2V0IG9mIHVzYm11eGQuIEl0IHdpbGwgZGVmYXVsdCB0byAvdmFyL3J1bi91c2JtdXhkIGlmIGl0IGlzIG5vdCBwYXNzZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldE9TVmVyc2lvbiAodWRpZCwgc29ja2V0ID0gbnVsbCkge1xuICBjb25zdCB1c2JtdXggPSBuZXcgVXNibXV4KHNvY2tldCB8fCBhd2FpdCBnZXREZWZhdWx0U29ja2V0KCkpO1xuICB0cnkge1xuICAgIC8vIGxvY2tkb3duIGRvZXNuJ3QgbmVlZCB0byBiZSBjbG9zZWQgc2luY2UgaXQgdXNlcyB0aGUgc2FtZSBzb2NrZXQgdXNibXV4IHVzZXNcbiAgICBjb25zdCBsb2NrZG93biA9IGF3YWl0IHVzYm11eC5jb25uZWN0TG9ja2Rvd24odWRpZCk7XG4gICAgcmV0dXJuIGF3YWl0IGxvY2tkb3duLmdldFZhbHVlKExPQ0tET1dOX1JFUVVFU1QuREVWSUNFX1ZFUlNJT04pO1xuICB9IGZpbmFsbHkge1xuICAgIHVzYm11eC5jbG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBuYW1lIG9mIHRoZSBkZXZpY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCBEZXZpY2UgVURJRFxuICogQHBhcmFtIHs/bmV0LlNvY2tldH0gc29ja2V0IHRoZSBzb2NrZXQgb2YgdXNibXV4ZC4gSXQgd2lsbCBkZWZhdWx0IHRvIC92YXIvcnVuL3VzYm11eGQgaWYgaXQgaXMgbm90IHBhc3NlZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlTmFtZSAodWRpZCwgc29ja2V0ID0gbnVsbCkge1xuICBjb25zdCB1c2JtdXggPSBuZXcgVXNibXV4KHNvY2tldCB8fCBhd2FpdCBnZXREZWZhdWx0U29ja2V0KCkpO1xuICB0cnkge1xuICAgIC8vIGxvY2tkb3duIGRvZXNuJ3QgbmVlZCB0byBiZSBjbG9zZWQgc2luY2UgaXQgdXNlcyB0aGUgc2FtZSBzb2NrZXQgdXNibXV4IHVzZXNcbiAgICBjb25zdCBsb2NrZG93biA9IGF3YWl0IHVzYm11eC5jb25uZWN0TG9ja2Rvd24odWRpZCk7XG4gICAgcmV0dXJuIGF3YWl0IGxvY2tkb3duLmdldFZhbHVlKExPQ0tET1dOX1JFUVVFU1QuREVWSUNFX05BTUUpO1xuICB9IGZpbmFsbHkge1xuICAgIHVzYm11eC5jbG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGRldmljZSB2YWx1ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIERldmljZSBVRElEXG4gKiBAcGFyYW0gez9uZXQuU29ja2V0fSBzb2NrZXQgdGhlIHNvY2tldCBvZiB1c2JtdXhkLiBJdCB3aWxsIGRlZmF1bHQgdG8gL3Zhci9ydW4vdXNibXV4ZCBpZiBpdCBpcyBub3QgcGFzc2VkXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBSZXR1cm5zIGF2YWlsYWJsZSBkZWZhdWx0IGRldmljZSB2YWx1ZXMgdmlhIGxvY2tkb3duLlxuICogZS5nLlxuICoge1xuICogICBcIkJhc2ViYW5kQ2VydElkXCI9PjM4NDAxNDk1MjgsXG4gKiAgIFwiQmFzZWJhbmRLZXlIYXNoSW5mb3JtYXRpb25cIj0+XG4gKiAgICAge1wiQUtleVN0YXR1c1wiPT4yLFxuICogICAgIFwiU0tleUhhc2hcIj0+e1xuICogICAgICAgXCJ0eXBlXCI9PlwiQnVmZmVyXCIsXG4gKiAgICAgICBcImRhdGFcIj0+WzE4NywgMjM5LCAuLi4uXX0sXG4gKiAgICAgXCJTS2V5U3RhdHVzXCI9PjB9LFxuICogICBcIkJhc2ViYW5kU2VyaWFsTnVtYmVyXCI9PntcInR5cGVcIj0+XCJCdWZmZXJcIiwgXCJkYXRhXCI9PlsuLi5dfSxcbiAqICAgXCJCYXNlYmFuZFZlcnNpb25cIj0+XCIxMS4wMS4wMlwiLFxuICogICBcIkJvYXJkSWRcIj0+MixcbiAqICAgXCJCdWlsZFZlcnNpb25cIj0+XCIxOUM1NlwiLFxuICogICBcIkNQVUFyY2hpdGVjdHVyZVwiPT5cImFybTY0XCIsXG4gKiAgIFwiQ2hpcElEXCI9PjMyNzY4LFxuICogICBcIkRldmljZUNsYXNzXCI9PlwiaVBob25lXCIsXG4gKiAgIFwiRGV2aWNlQ29sb3JcIj0+XCIjYzhjYWNhXCIsXG4gKiAgIFwiRGV2aWNlTmFtZVwiPT5cImthenVcIixcbiAqICAgXCJEaWVJRFwiPT4xMTExMTExMTExMTExLFxuICogICBcIkhhcmR3YXJlTW9kZWxcIj0+XCJONjl1QVBcIixcbiAqICAgXCJIYXNTaURQXCI9PnRydWUsXG4gKiAgIFwiUGFydGl0aW9uVHlwZVwiPT5cIkdVSURfcGFydGl0aW9uX3NjaGVtZVwiLFxuICogICBcIlByb2R1Y3ROYW1lXCI9PlwiaVBob25lIE9TXCIsXG4gKiAgIFwiUHJvZHVjdFR5cGVcIj0+XCJpUGhvbmU4LDRcIixcbiAqICAgXCJQcm9kdWN0VmVyc2lvblwiPT5cIjE1LjJcIixcbiAqICAgXCJQcm9kdWN0aW9uU09DXCI9PnRydWUsXG4gKiAgIFwiUHJvdG9jb2xWZXJzaW9uXCI9PlwiMlwiLFxuICogICBcIlN1cHBvcnRlZERldmljZUZhbWlsaWVzXCI9PlsxXSxcbiAqICAgXCJUZWxlcGhvbnlDYXBhYmlsaXR5XCI9PnRydWUsXG4gKiAgIFwiVW5pcXVlQ2hpcElEXCI9PjExMTExMTExMTExMTEsXG4gKiAgIFwiVW5pcXVlRGV2aWNlSURcIj0+XCJhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhXCIsXG4gKiAgIFwiV2lGaUFkZHJlc3NcIj0+XCIwMDowMDowMDowMDowMDowMFwiXG4gKiB9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldERldmljZUluZm8gKHVkaWQsIHNvY2tldCA9IG51bGwpIHtcbiAgY29uc3QgdXNibXV4ID0gbmV3IFVzYm11eChzb2NrZXQgfHwgYXdhaXQgZ2V0RGVmYXVsdFNvY2tldCgpKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBsb2NrZG93biA9IGF3YWl0IHVzYm11eC5jb25uZWN0TG9ja2Rvd24odWRpZCk7XG4gICAgcmV0dXJuIGF3YWl0IGxvY2tkb3duLmdldFZhbHVlKCk7XG4gIH0gZmluYWxseSB7XG4gICAgdXNibXV4LmNsb3NlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZXZpY2VUaW1lXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVzdGFtcCBVbml4IHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIDE5NzAtMDEtMDFUMDA6MDA6MDBaXG4gKiBAcHJvcGVydHkge251bWJlcn0gdXRjT2Zmc2V0IFRoZSBkaWZmZXJlbmNlIGluIG1pbnV0ZXMgYmV0d2VlbiB0aGUgVVRDIHRpbWUgYW5kIHRoZSBsb2NhbCBkZXZpY2UgdGltZS5cbiAqIENhbiBiZSBuZWdhdGl2ZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aW1lWm9uZSBUaW1lIHpvbmUgbmFtZSBjb25maWd1cmVkIG9uIHRoZSBkZXZpY2UsIGZvciBleGFtcGxlIGBFdXJvcGUvUGFyaXNgXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGxvY2FsIHRpbWUgZnJvbSB0aGUgZGV2aWNlIHVuZGVyIHRlc3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCBEZXZpY2UgVURJRFxuICogQHBhcmFtIHs/bmV0LlNvY2tldH0gc29ja2V0IHRoZSBzb2NrZXQgb2YgdXNibXV4ZC4gSXQgd2lsbCBkZWZhdWx0IHRvIC92YXIvcnVuL3VzYm11eGQgaWYgaXQgaXMgbm90IHBhc3NlZFxuICogQHJldHVybnMge0RldmljZVRpbWV9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldERldmljZVRpbWUgKHVkaWQsIHNvY2tldCA9IG51bGwpIHtcbiAgY29uc3QgbG9ja2Rvd24gPSBhd2FpdCBzdGFydExvY2tkb3duU2Vzc2lvbih1ZGlkLCBzb2NrZXQpO1xuICB0cnkge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lc3RhbXA6IGF3YWl0IGxvY2tkb3duLmdldFZhbHVlKExPQ0tET1dOX1JFUVVFU1QuREVWSUNFX1RJTUUpLFxuICAgICAgLy8gQXBwbGUgcmV0dXJucyB1dGNPZmZzZXQgaW4gc2Vjb25kcyB3aGljaCBkb2VzbnQgY29tcGx5IHdpdGggdGhlIGdlbmVyYWwgc3RhbmRhcmRcbiAgICAgIHV0Y09mZnNldDogYXdhaXQgbG9ja2Rvd24uZ2V0VmFsdWUoTE9DS0RPV05fUkVRVUVTVC5ERVZJQ0VfVVRDX09GRlNFVCkgLyA2MCxcbiAgICAgIHRpbWVab25lOiBhd2FpdCBsb2NrZG93bi5nZXRWYWx1ZShMT0NLRE9XTl9SRVFVRVNULkRFVklDRV9USU1FX1pPTkUpLFxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgbG9ja2Rvd24uY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFN0YXJ0cyBhIGxvY2tkb3duIHNlc3Npb24gb24gdGhlIGdpdmVuIGRldmljZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIERldmljZSBVRElEXG4gKiBAcGFyYW0gez9uZXQuU29ja2V0fSBzb2NrZXQgdGhlIHNvY2tldCBvZiB1c2JtdXhkLiBJdCB3aWxsIGRlZmF1bHQgdG8gL3Zhci9ydW4vdXNibXV4ZCBpZiBpdCBpcyBub3QgcGFzc2VkXG4gKiBAcmV0dXJucyB7TG9ja2Rvd259XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN0YXJ0TG9ja2Rvd25TZXNzaW9uICh1ZGlkLCBzb2NrZXQgPSBudWxsKSB7XG4gIGNvbnN0IHVzYm11eCA9IG5ldyBVc2JtdXgoc29ja2V0IHx8IGF3YWl0IGdldERlZmF1bHRTb2NrZXQoKSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFpclJlY29yZCA9IGF3YWl0IHVzYm11eC5yZWFkUGFpclJlY29yZCh1ZGlkKTtcbiAgICBpZiAoIXBhaXJSZWNvcmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBwYWlyIHJlY29yZCBmb3IgZGV2aWNlICcke3VkaWR9Jy4gUGxlYXNlIGZpcnN0IHBhaXIgd2l0aCB0aGUgZGV2aWNlYCk7XG4gICAgfVxuICAgIC8vIGxvY2tkb3duIGRvZXNuJ3QgbmVlZCB0byBiZSBjbG9zZWQgc2luY2UgaXQgdXNlcyB0aGUgc2FtZSBzb2NrZXQgdXNibXV4IHVzZXNcbiAgICBjb25zdCBsb2NrZG93biA9IGF3YWl0IHVzYm11eC5jb25uZWN0TG9ja2Rvd24odWRpZCk7XG4gICAgYXdhaXQgbG9ja2Rvd24uc3RhcnRTZXNzaW9uKHBhaXJSZWNvcmQuSG9zdElELCBwYWlyUmVjb3JkLlN5c3RlbUJVSUQpO1xuICAgIGxvY2tkb3duLmVuYWJsZVNlc3Npb25TU0wocGFpclJlY29yZC5Ib3N0UHJpdmF0ZUtleSwgcGFpclJlY29yZC5Ib3N0Q2VydGlmaWNhdGUpO1xuICAgIHJldHVybiBsb2NrZG93bjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHVzYm11eC5jbG9zZSgpO1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25uZWN0cyB0byBhIGdpdmVuIHBvcnQgd2l0aCB0aGUgY2VydHMgYW5kIGtleXMgdXNlZCBpbiB0aGUgcGFpcmluZyBwcm9jZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgRGV2aWNlIFVESURcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3J0IFBvcnQgdG8gY29ubmVjdFxuICogQHBhcmFtIHs/bmV0LlNvY2tldH0gc29ja2V0IHRoZSBzb2NrZXQgb2YgdXNibXV4ZC4gSXQgd2lsbCBkZWZhdWx0IHRvIC92YXIvcnVuL3VzYm11eGQgaWYgaXQgaXMgbm90IHBhc3NlZFxuICogQHBhcmFtIHtib29sZWFufSBoYW5kc2hha2VPbmx5IG9ubHkgaGFuZHNoYWtlIGFuZCByZXR1cm4gdGhlIGluaXRpYWwgc29ja2V0XG4gKiBAcmV0dXJucyB7dGxzLlRMU1NvY2tldHxPYmplY3R9IFRoZSBzb2NrZXQgb3IgdGhlIG9iamVjdCByZXR1cm5lZCBpbiB0aGUgY2FsbGJhY2sgaWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4aXN0c1xuICovXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0UG9ydFNTTCAodWRpZCwgcG9ydCwgc29ja2V0ID0gbnVsbCwgaGFuZHNoYWtlT25seSA9IGZhbHNlKSB7XG4gIGNvbnN0IHVzYm11eCA9IG5ldyBVc2JtdXgoc29ja2V0IHx8IGF3YWl0IGdldERlZmF1bHRTb2NrZXQoKSk7XG4gIHRyeSB7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgdXNibXV4LmZpbmREZXZpY2UodWRpZCk7XG4gICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdGhlIGV4cGVjdGVkIGRldmljZSAnJHt1ZGlkfSdgKTtcbiAgICB9XG4gICAgY29uc3QgcGFpclJlY29yZCA9IGF3YWl0IHVzYm11eC5yZWFkUGFpclJlY29yZCh1ZGlkKTtcbiAgICBpZiAoIXBhaXJSZWNvcmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBwYWlyIHJlY29yZCBmb3IgZGV2aWNlICcke3VkaWR9Jy4gUGxlYXNlIGZpcnN0IHBhaXIgd2l0aCB0aGUgZGV2aWNlYCk7XG4gICAgfVxuICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IHVzYm11eC5jb25uZWN0KGRldmljZS5Qcm9wZXJ0aWVzLkRldmljZUlELCBwb3J0LCB1bmRlZmluZWQpO1xuICAgIHJldHVybiBoYW5kc2hha2VPbmx5ID9cbiAgICAgIGF3YWl0IGVuYWJsZVNTTEhhbmRzaGFrZU9ubHkoc29ja2V0LCBwYWlyUmVjb3JkLkhvc3RQcml2YXRlS2V5LCBwYWlyUmVjb3JkLkhvc3RDZXJ0aWZpY2F0ZSkgOlxuICAgICAgdXBncmFkZVRvU1NMKHNvY2tldCwgcGFpclJlY29yZC5Ib3N0UHJpdmF0ZUtleSwgcGFpclJlY29yZC5Ib3N0Q2VydGlmaWNhdGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXNibXV4LmNsb3NlKCk7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIENvbm5lY3RzIHRvIGEgZ2l2ZW4gcG9ydFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIERldmljZSBVRElEXG4gKiBAcGFyYW0ge251bWJlcn0gcG9ydCBQb3J0IHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7P25ldC5Tb2NrZXR9IHNvY2tldCB0aGUgc29ja2V0IG9mIHVzYm11eGQuIEl0IHdpbGwgZGVmYXVsdCB0byAvdmFyL3J1bi91c2JtdXhkIGlmIGl0IGlzIG5vdCBwYXNzZWRcbiAqIEByZXR1cm5zIHtuZXQuU29ja2V0fE9iamVjdH0gVGhlIHNvY2tldCBvciB0aGUgb2JqZWN0IHJldHVybmVkIGluIHRoZSBjYWxsYmFjayBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhpc3RzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3RQb3J0ICh1ZGlkLCBwb3J0LCBzb2NrZXQgPSBudWxsKSB7XG4gIGNvbnN0IHVzYm11eCA9IG5ldyBVc2JtdXgoc29ja2V0IHx8IGF3YWl0IGdldERlZmF1bHRTb2NrZXQoKSk7XG4gIHRyeSB7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgdXNibXV4LmZpbmREZXZpY2UodWRpZCk7XG4gICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdGhlIGV4cGVjdGVkIGRldmljZSAke3VkaWR9YCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB1c2JtdXguY29ubmVjdChkZXZpY2UuUHJvcGVydGllcy5EZXZpY2VJRCwgcG9ydCwgdW5kZWZpbmVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHVzYm11eC5jbG9zZSgpO1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgZ2V0Q29ubmVjdGVkRGV2aWNlcywgZ2V0T1NWZXJzaW9uLCBnZXREZXZpY2VOYW1lLCBnZXREZXZpY2VUaW1lLFxuICBzdGFydExvY2tkb3duU2Vzc2lvbiwgY29ubmVjdFBvcnQsIGNvbm5lY3RQb3J0U1NMLCBnZXREZXZpY2VJbmZvXG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBR0EsTUFBTUEsZ0JBQWdCLEdBQUc7RUFDdkJDLFdBQVcsRUFBRTtJQUFFQyxHQUFHLEVBQUU7RUFBUCxDQURVO0VBRXZCQyxpQkFBaUIsRUFBRTtJQUFFRCxHQUFHLEVBQUU7RUFBUCxDQUZJO0VBR3ZCRSxnQkFBZ0IsRUFBRTtJQUFFRixHQUFHLEVBQUU7RUFBUCxDQUhLO0VBSXZCRyxjQUFjLEVBQUU7SUFBRUgsR0FBRyxFQUFFO0VBQVAsQ0FKTztFQUt2QkksV0FBVyxFQUFFO0lBQUVKLEdBQUcsRUFBRTtFQUFQO0FBTFUsQ0FBekI7O0FBZ0JBLGVBQWVLLG1CQUFmLENBQW9DQyxNQUFNLEdBQUcsSUFBN0MsRUFBbUQ7RUFDakQsSUFBSUMsTUFBSjs7RUFDQSxJQUFJO0lBQ0ZBLE1BQU0sR0FBRyxJQUFJQyxlQUFKLENBQVdGLE1BQU0sS0FBSSxNQUFNLCtCQUFWLENBQWpCLENBQVQ7RUFDRCxDQUZELENBRUUsT0FBT0csQ0FBUCxFQUFVO0lBQ1ZDLGdCQUFJQyxLQUFKLENBQVVGLENBQVY7O0lBQ0EsT0FBTyxFQUFQO0VBQ0Q7O0VBQ0QsSUFBSTtJQUNGLE1BQU1HLE9BQU8sR0FBRyxNQUFNTCxNQUFNLENBQUNNLFdBQVAsRUFBdEI7SUFDQSxNQUFN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
