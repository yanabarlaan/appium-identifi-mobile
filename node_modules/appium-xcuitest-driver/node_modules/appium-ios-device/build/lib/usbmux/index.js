"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Usbmux = void 0;
exports.getDefaultSocket = getDefaultSocket;

require("source-map-support/register");

var _net = _interopRequireDefault(require("net"));

var _os = _interopRequireDefault(require("os"));

var _lodash = _interopRequireDefault(require("lodash"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _support = require("@appium/support");

var _lengthBasedSplitter = _interopRequireDefault(require("../util/transformer/length-based-splitter"));

var _usbmuxDecoder = _interopRequireDefault(require("./transformer/usbmux-decoder.js"));

var _usbmuxEncoder = _interopRequireDefault(require("./transformer/usbmux-encoder.js"));

var _path = _interopRequireDefault(require("path"));

var _plistService = _interopRequireDefault(require("../plist-service"));

var _lockdown = require("../lockdown");

var _baseService = require("../base-service");

var _constants = require("../constants");

const MAX_FRAME_SIZE = 1 * _constants.MB;
const USBMUX_RESULT = {
  OK: 0,
  BADCOMMAND: 1,
  BADDEV: 2,
  CONNREFUSED: 3
};
let name, version;

try {
  ({
    name,
    version
  } = require(_path.default.resolve(__dirname, '..', '..', '..', 'package.json')));
} catch (err) {
  ({
    name,
    version
  } = require(_path.default.resolve(__dirname, '..', '..', 'package.json')));
}

const DEFAULT_USBMUXD_SOCKET = '/var/run/usbmuxd';
const DEFAULT_USBMUXD_PORT = 27015;
const DEFAULT_USBMUXD_HOST = '127.0.0.1';
const PROG_NAME = name;
const CLIENT_VERSION_STRING = `${name}-${version}`;

function swap16(val) {
  return (val & 0xFF) << 8 | val >> 8 & 0xFF;
}

async function getDefaultSocket(opts = {}) {
  const {
    socketPath = DEFAULT_USBMUXD_SOCKET,
    socketPort = DEFAULT_USBMUXD_PORT,
    socketHost = DEFAULT_USBMUXD_HOST,
    timeout = 5000
  } = opts;
  let socket;

  if (await _support.fs.exists(socketPath)) {
    socket = _net.default.createConnection(socketPath);
  } else if (process.platform === 'win32' || process.platform === 'linux' && /microsoft/i.test(_os.default.release())) {
    socket = _net.default.createConnection(socketPort, socketHost);
  } else {
    throw new Error(`The usbmuxd socket at '${socketPath}' does not exist or is not accessible`);
  }

  return await new _bluebird.default((resolve, reject) => {
    socket.once('error', reject);
    socket.once('connect', () => resolve(socket));
  }).timeout(timeout);
}

class Usbmux extends _baseService.BaseServiceSocket {
  constructor(socketClient) {
    super(socketClient);
    this._decoder = new _usbmuxDecoder.default();
    this._splitter = new _lengthBasedSplitter.default({
      readableStream: socketClient,
      littleEndian: true,
      maxFrameLength: MAX_FRAME_SIZE,
      lengthFieldOffset: 0,
      lengthFieldLength: 4,
      lengthAdjustment: 0
    });

    this._socketClient.pipe(this._splitter).pipe(this._decoder);

    this._encoder = new _usbmuxEncoder.default();

    this._encoder.pipe(this._socketClient);

    this._assignClientFailureHandlers(this._encoder);

    this._tag = 0;
    this._responseCallbacks = {};

    this._decoder.on('data', this._handleData.bind(this));
  }

  _handleData(data) {
    const cb = this._responseCallbacks[data.header.tag] || _lodash.default.noop;
    cb(data);
  }

  async readBUID(timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (data.payload.BUID) {
        return data.payload.BUID;
      }

      throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'ReadBUID',
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING
      }
    });

    return await receivePromise;
  }

  async readPairRecord(udid, timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (!data.payload.PairRecordData) {
        return null;
      }

      try {
        return _support.plist.parsePlist(data.payload.PairRecordData);
      } catch (err) {
        throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
      }
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'ReadPairRecord',
        PairRecordID: udid,
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING
      }
    });

    return await receivePromise;
  }

  _sendPlist(json) {
    this._encoder.write(json);
  }

  _receivePlistPromise(timeout = 5000, responseCallback) {
    const tag = this._tag++;
    const receivePromise = new _bluebird.default((resolve, reject) => {
      this._responseCallbacks[tag] = data => {
        try {
          resolve(responseCallback(data));
        } catch (e) {
          reject(e);
        }
      };

      setTimeout(() => reject(new Error(`Failed to receive any data within the timeout: ${timeout}`)), timeout);
    });
    return {
      tag,
      receivePromise
    };
  }

  async listDevices(timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (data.payload.DeviceList) {
        return data.payload.DeviceList;
      }

      throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'ListDevices',
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING
      }
    });

    return await receivePromise;
  }

  async findDevice(udid, timeout = 5000) {
    const devices = await this.listDevices(timeout);
    return _lodash.default.find(devices, device => device.Properties.SerialNumber === udid);
  }

  async connectLockdown(udid, timeout = 5000) {
    const device = await this.findDevice(udid, timeout);

    if (!device) {
      throw new Error(`Could not find the expected device '${udid}'`);
    }

    const socket = await this.connect(device.Properties.DeviceID, _lockdown.LOCKDOWN_PORT, timeout);
    return new _lockdown.Lockdown(new _plistService.default(socket));
  }

  async connect(deviceID, port, timeout = 5000) {
    const {
      tag,
      receivePromise
    } = this._receivePlistPromise(timeout, data => {
      if (data.payload.MessageType !== 'Result') {
        throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
      }

      if (data.payload.Number === USBMUX_RESULT.OK) {
        this._splitter.shutdown();

        this._socketClient.unpipe(this._splitter);

        this._splitter.unpipe(this._decoder);

        return this._socketClient;
      } else if (data.payload.Number === USBMUX_RESULT.CONNREFUSED) {
        throw new Error(`Connection was refused to port ${port}`);
      } else {
        throw new Error(`Unexpected data: ${JSON.stringify(data)}`);
      }
    });

    this._sendPlist({
      tag,
      payload: {
        MessageType: 'Connect',
        ProgName: PROG_NAME,
        ClientVersionString: CLIENT_VERSION_STRING,
        DeviceID: deviceID,
        PortNumber: swap16(port)
      }
    });

    return await receivePromise;
  }

}

exports.Usbmux = Usbmux;
var _default = Usbmux;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL3VzYm11eC9pbmRleC5qcyIsIm5hbWVzIjpbIk1BWF9GUkFNRV9TSVpFIiwiTUIiLCJVU0JNVVhfUkVTVUxUIiwiT0siLCJCQURDT01NQU5EIiwiQkFEREVWIiwiQ09OTlJFRlVTRUQiLCJuYW1lIiwidmVyc2lvbiIsInJlcXVpcmUiLCJwYXRoIiwicmVzb2x2ZSIsIl9fZGlybmFtZSIsImVyciIsIkRFRkFVTFRfVVNCTVVYRF9TT0NLRVQiLCJERUZBVUxUX1VTQk1VWERfUE9SVCIsIkRFRkFVTFRfVVNCTVVYRF9IT1NUIiwiUFJPR19OQU1FIiwiQ0xJRU5UX1ZFUlNJT05fU1RSSU5HIiwic3dhcDE2IiwidmFsIiwiZ2V0RGVmYXVsdFNvY2tldCIsIm9wdHMiLCJzb2NrZXRQYXRoIiwic29ja2V0UG9ydCIsInNvY2tldEhvc3QiLCJ0aW1lb3V0Iiwic29ja2V0IiwiZnMiLCJleGlzdHMiLCJuZXQiLCJjcmVhdGVDb25uZWN0aW9uIiwicHJvY2VzcyIsInBsYXRmb3JtIiwidGVzdCIsIm9zIiwicmVsZWFzZSIsIkVycm9yIiwiQiIsInJlamVjdCIsIm9uY2UiLCJVc2JtdXgiLCJCYXNlU2VydmljZVNvY2tldCIsImNvbnN0cnVjdG9yIiwic29ja2V0Q2xpZW50IiwiX2RlY29kZXIiLCJVc2JtdXhEZWNvZGVyIiwiX3NwbGl0dGVyIiwiTGVuZ3RoQmFzZWRTcGxpdHRlciIsInJlYWRhYmxlU3RyZWFtIiwibGl0dGxlRW5kaWFuIiwibWF4RnJhbWVMZW5ndGgiLCJsZW5ndGhGaWVsZE9mZnNldCIsImxlbmd0aEZpZWxkTGVuZ3RoIiwibGVuZ3RoQWRqdXN0bWVudCIsIl9zb2NrZXRDbGllbnQiLCJwaXBlIiwiX2VuY29kZXIiLCJVc2JtdXhFbmNvZGVyIiwiX2Fzc2lnbkNsaWVudEZhaWx1cmVIYW5kbGVycyIsIl90YWciLCJfcmVzcG9uc2VDYWxsYmFja3MiLCJvbiIsIl9oYW5kbGVEYXRhIiwiYmluZCIsImRhdGEiLCJjYiIsImhlYWRlciIsInRhZyIsIl8iLCJub29wIiwicmVhZEJVSUQiLCJyZWNlaXZlUHJvbWlzZSIsIl9yZWNlaXZlUGxpc3RQcm9taXNlIiwicGF5bG9hZCIsIkJVSUQiLCJKU09OIiwic3RyaW5naWZ5IiwiX3NlbmRQbGlzdCIsIk1lc3NhZ2VUeXBlIiwiUHJvZ05hbWUiLCJDbGllbnRWZXJzaW9uU3RyaW5nIiwicmVhZFBhaXJSZWNvcmQiLCJ1ZGlkIiwiUGFpclJlY29yZERhdGEiLCJwbGlzdCIsInBhcnNlUGxpc3QiLCJQYWlyUmVjb3JkSUQiLCJqc29uIiwid3JpdGUiLCJyZXNwb25zZUNhbGxiYWNrIiwiZSIsInNldFRpbWVvdXQiLCJsaXN0RGV2aWNlcyIsIkRldmljZUxpc3QiLCJmaW5kRGV2aWNlIiwiZGV2aWNlcyIsImZpbmQiLCJkZXZpY2UiLCJQcm9wZXJ0aWVzIiwiU2VyaWFsTnVtYmVyIiwiY29ubmVjdExvY2tkb3duIiwiY29ubmVjdCIsIkRldmljZUlEIiwiTE9DS0RPV05fUE9SVCIsIkxvY2tkb3duIiwiUGxpc3RTZXJ2aWNlIiwiZGV2aWNlSUQiLCJwb3J0IiwiTnVtYmVyIiwic2h1dGRvd24iLCJ1bnBpcGUiLCJQb3J0TnVtYmVyIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLiIsInNvdXJjZXMiOlsibGliL3VzYm11eC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmV0IGZyb20gJ25ldCc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHBsaXN0LCBmcyB9IGZyb20gJ0BhcHBpdW0vc3VwcG9ydCc7XG5pbXBvcnQgTGVuZ3RoQmFzZWRTcGxpdHRlciBmcm9tICcuLi91dGlsL3RyYW5zZm9ybWVyL2xlbmd0aC1iYXNlZC1zcGxpdHRlcic7XG5pbXBvcnQgVXNibXV4RGVjb2RlciBmcm9tICcuL3RyYW5zZm9ybWVyL3VzYm11eC1kZWNvZGVyLmpzJztcbmltcG9ydCBVc2JtdXhFbmNvZGVyIGZyb20gJy4vdHJhbnNmb3JtZXIvdXNibXV4LWVuY29kZXIuanMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgUGxpc3RTZXJ2aWNlIGZyb20gJy4uL3BsaXN0LXNlcnZpY2UnO1xuaW1wb3J0IHsgTG9ja2Rvd24sIExPQ0tET1dOX1BPUlQgfSBmcm9tICcuLi9sb2NrZG93bic7XG5pbXBvcnQgeyBCYXNlU2VydmljZVNvY2tldCB9IGZyb20gJy4uL2Jhc2Utc2VydmljZSc7XG5pbXBvcnQgeyBNQiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cblxuY29uc3QgTUFYX0ZSQU1FX1NJWkUgPSAxICogTUI7XG5cbmNvbnN0IFVTQk1VWF9SRVNVTFQgPSB7XG4gIE9LOiAwLFxuICBCQURDT01NQU5EOiAxLFxuICBCQURERVY6IDIsXG4gIENPTk5SRUZVU0VEOiAzLFxufTtcblxubGV0IG5hbWUsIHZlcnNpb247XG50cnkge1xuICAvLyBmaXJzdCB0cnkgYXNzdW1pbmcgdGhpcyBpcyBpbiB0aGUgYGJ1aWxkYCBmb2xkZXJcbiAgKHsgbmFtZSwgdmVyc2lvbiB9ID0gcmVxdWlyZShwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAncGFja2FnZS5qc29uJykpKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyB0aGVuIHRyeSBhc3N1bWluZyBpdCBpcyBub3RcbiAgKHsgbmFtZSwgdmVyc2lvbiB9ID0gcmVxdWlyZShwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAncGFja2FnZS5qc29uJykpKTtcbn1cblxuY29uc3QgREVGQVVMVF9VU0JNVVhEX1NPQ0tFVCA9ICcvdmFyL3J1bi91c2JtdXhkJztcbmNvbnN0IERFRkFVTFRfVVNCTVVYRF9QT1JUID0gMjcwMTU7XG5jb25zdCBERUZBVUxUX1VTQk1VWERfSE9TVCA9ICcxMjcuMC4wLjEnO1xuY29uc3QgUFJPR19OQU1FID0gbmFtZTtcbmNvbnN0IENMSUVOVF9WRVJTSU9OX1NUUklORyA9IGAke25hbWV9LSR7dmVyc2lvbn1gO1xuXG5mdW5jdGlvbiBzd2FwMTYgKHZhbCkge1xuICByZXR1cm4gKCh2YWwgJiAweEZGKSA8PCA4KSB8ICgodmFsID4+IDgpICYgMHhGRik7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU29ja2V0T3B0aW9uc1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSBzb2NrZXRQYXRoIFsvdmFyL3J1bi91c2JtdXhkXSBUaGUgZnVsbCBwYXRoIHRvIHRoZSB1c2JtdXhkIFVuaXggc29ja2V0XG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IHNvY2tldFBvcnQgWzI3MDE1XSBUaGUgcG9ydCBudW1iZXIgdG8gY29ubmVjdCB0byBpZiBydW5uaW5nIG9uIFdpbmRvd3NcbiAqIG9yIGluIFdTTDEgbW9kZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBzb2NrZXRIb3N0IFsxMjcuMC4wLjFdIFRoZSBob3N0IG5hbWUgdG8gY29ubmVjdCB0byBpZiBydW5uaW5nIG9uIFdpbmRvd3NcbiAqIG9yIGluIFdTTDEgbW9kZVxuICogQHByb3BlcnR5IHs/bnVtYmVyfSB0aW1lb3V0IFs1MDAwXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IHVudGlsXG4gKiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZFxuICovXG5cbi8qKlxuICogQ29ubmVjdHMgYSBzb2NrZXQgdG8gdXNibXV4ZCBzZXJ2aWNlXG4gKlxuICogQHBhcmFtIHs/U29ja2V0T3B0aW9uc30gb3B0c1xuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBhY2Nlc3NpbmcgdGhlIHNvY2tldCBvclxuICogYSBjb25uZWN0aW9uIGVycm9yIGhhcHBlbmVkXG4gKiBAdGhyb3dzIHtCLlRpbWVvdXRFcnJvcn0gaWYgY29ubmVjdGlvbiB0aW1lb3V0IGhhcHBlbmVkXG4gKiBAcmV0dXJucyB7bmV0LlNvY2tldH0gQ29ubmVjdGVkIHNvY2tldCBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXREZWZhdWx0U29ja2V0IChvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNvY2tldFBhdGggPSBERUZBVUxUX1VTQk1VWERfU09DS0VULFxuICAgIHNvY2tldFBvcnQgPSBERUZBVUxUX1VTQk1VWERfUE9SVCxcbiAgICBzb2NrZXRIb3N0ID0gREVGQVVMVF9VU0JNVVhEX0hPU1QsXG4gICAgdGltZW91dCA9IDUwMDAsXG4gIH0gPSBvcHRzO1xuXG4gIGxldCBzb2NrZXQ7XG4gIGlmIChhd2FpdCBmcy5leGlzdHMoc29ja2V0UGF0aCkpIHtcbiAgICBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbihzb2NrZXRQYXRoKTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgICB8fCAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyAmJiAvbWljcm9zb2Z0L2kudGVzdChvcy5yZWxlYXNlKCkpKSkge1xuICAgIC8vIENvbm5lY3QgdG8gdXNibXV4ZCB3aGVuIHJ1bm5pbmcgb24gV1NMMVxuICAgIHNvY2tldCA9IG5ldC5jcmVhdGVDb25uZWN0aW9uKHNvY2tldFBvcnQsIHNvY2tldEhvc3QpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHVzYm11eGQgc29ja2V0IGF0ICcke3NvY2tldFBhdGh9JyBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYWNjZXNzaWJsZWApO1xuICB9XG5cbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzb2NrZXQub25jZSgnZXJyb3InLCByZWplY3QpO1xuICAgIHNvY2tldC5vbmNlKCdjb25uZWN0JywgKCkgPT4gcmVzb2x2ZShzb2NrZXQpKTtcbiAgfSkudGltZW91dCh0aW1lb3V0KTtcbn1cblxuXG5jbGFzcyBVc2JtdXggZXh0ZW5kcyBCYXNlU2VydmljZVNvY2tldCB7XG4gIGNvbnN0cnVjdG9yIChzb2NrZXRDbGllbnQpIHtcbiAgICBzdXBlcihzb2NrZXRDbGllbnQpO1xuXG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBVc2JtdXhEZWNvZGVyKCk7XG4gICAgdGhpcy5fc3BsaXR0ZXIgPSBuZXcgTGVuZ3RoQmFzZWRTcGxpdHRlcih7XG4gICAgICByZWFkYWJsZVN0cmVhbTogc29ja2V0Q2xpZW50LFxuICAgICAgbGl0dGxlRW5kaWFuOiB0cnVlLFxuICAgICAgbWF4RnJhbWVMZW5ndGg6IE1BWF9GUkFNRV9TSVpFLFxuICAgICAgbGVuZ3RoRmllbGRPZmZzZXQ6IDAsXG4gICAgICBsZW5ndGhGaWVsZExlbmd0aDogNCxcbiAgICAgIGxlbmd0aEFkanVzdG1lbnQ6IDAsXG4gICAgfSk7XG4gICAgdGhpcy5fc29ja2V0Q2xpZW50LnBpcGUodGhpcy5fc3BsaXR0ZXIpLnBpcGUodGhpcy5fZGVjb2Rlcik7XG5cbiAgICB0aGlzLl9lbmNvZGVyID0gbmV3IFVzYm11eEVuY29kZXIoKTtcbiAgICB0aGlzLl9lbmNvZGVyLnBpcGUodGhpcy5fc29ja2V0Q2xpZW50KTtcbiAgICB0aGlzLl9hc3NpZ25DbGllbnRGYWlsdXJlSGFuZGxlcnModGhpcy5fZW5jb2Rlcik7XG5cbiAgICB0aGlzLl90YWcgPSAwO1xuICAgIHRoaXMuX3Jlc3BvbnNlQ2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5fZGVjb2Rlci5vbignZGF0YScsIHRoaXMuX2hhbmRsZURhdGEuYmluZCh0aGlzKSk7XG4gIH1cblxuICBfaGFuZGxlRGF0YSAoZGF0YSkge1xuICAgIGNvbnN0IGNiID0gdGhpcy5fcmVzcG9uc2VDYWxsYmFja3NbZGF0YS5oZWFkZXIudGFnXSB8fCBfLm5vb3A7XG4gICAgY2IoZGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tY2FsbGJhY2tzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQlVJRCBvZiB0aGUgaG9zdCBjb21wdXRlciBmcm9tIHVzYm11eGRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0PTUwMDBdIHRoZSB0aW1lb3V0IG9mIHJlY2VpdmluZyBhIHJlc3BvbnNlIGZyb20gdXNibXV4ZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgYXN5bmMgcmVhZEJVSUQgKHRpbWVvdXQgPSA1MDAwKSB7XG4gICAgY29uc3Qge3RhZywgcmVjZWl2ZVByb21pc2V9ID0gdGhpcy5fcmVjZWl2ZVBsaXN0UHJvbWlzZSh0aW1lb3V0LCAoZGF0YSkgPT4ge1xuICAgICAgaWYgKGRhdGEucGF5bG9hZC5CVUlEKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnBheWxvYWQuQlVJRDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2VuZFBsaXN0KHtcbiAgICAgIHRhZyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgTWVzc2FnZVR5cGU6ICdSZWFkQlVJRCcsXG4gICAgICAgIFByb2dOYW1lOiBQUk9HX05BTUUsXG4gICAgICAgIENsaWVudFZlcnNpb25TdHJpbmc6IENMSUVOVF9WRVJTSU9OX1NUUklOR1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHJlY2VpdmVQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBwYWlyIHJlY29yZCBvZiBhIGRldmljZS4gSXQgd2lsbCByZXR1cm4gbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdWRpZCB0aGUgdWRpZCBvZiB0aGUgZGV2aWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dD01MDAwXSB0aGUgdGltZW91dCBvZiByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIHVzYm11eGRcbiAgICogQHJldHVybnMgez9PYmplY3R9XG4gICAqL1xuICBhc3luYyByZWFkUGFpclJlY29yZCAodWRpZCwgdGltZW91dCA9IDUwMDApIHtcbiAgICBjb25zdCB7dGFnLCByZWNlaXZlUHJvbWlzZX0gPSB0aGlzLl9yZWNlaXZlUGxpc3RQcm9taXNlKHRpbWVvdXQsIChkYXRhKSA9PiB7XG4gICAgICBpZiAoIWRhdGEucGF5bG9hZC5QYWlyUmVjb3JkRGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwbGlzdC5wYXJzZVBsaXN0KGRhdGEucGF5bG9hZC5QYWlyUmVjb3JkRGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZW5kUGxpc3Qoe1xuICAgICAgdGFnLFxuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBNZXNzYWdlVHlwZTogJ1JlYWRQYWlyUmVjb3JkJyxcbiAgICAgICAgUGFpclJlY29yZElEOiB1ZGlkLFxuICAgICAgICBQcm9nTmFtZTogUFJPR19OQU1FLFxuICAgICAgICBDbGllbnRWZXJzaW9uU3RyaW5nOiBDTElFTlRfVkVSU0lPTl9TVFJJTkdcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVjZWl2ZVByb21pc2U7XG4gIH1cblxuICBfc2VuZFBsaXN0IChqc29uKSB7XG4gICAgdGhpcy5fZW5jb2Rlci53cml0ZShqc29uKTtcbiAgfVxuXG4gIF9yZWNlaXZlUGxpc3RQcm9taXNlICh0aW1lb3V0ID0gNTAwMCwgcmVzcG9uc2VDYWxsYmFjaykge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuX3RhZysrO1xuICAgIGNvbnN0IHJlY2VpdmVQcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcmVzcG9uc2VDYWxsYmFja3NbdGFnXSA9IChkYXRhKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwb25zZUNhbGxiYWNrKGRhdGEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlY2VpdmUgYW55IGRhdGEgd2l0aGluIHRoZSB0aW1lb3V0OiAke3RpbWVvdXR9YCkpLCB0aW1lb3V0KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge3RhZywgcmVjZWl2ZVByb21pc2V9O1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBkZXZpY2VzIGNvbm5lY3RlZCB0byB0aGUgaG9zdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXQ9NTAwMF0gdGhlIHRpbWVvdXQgb2YgcmVjZWl2aW5nIGEgcmVzcG9uc2UgZnJvbSB1c2JtdXhkXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGFzeW5jIGxpc3REZXZpY2VzICh0aW1lb3V0ID0gNTAwMCkge1xuICAgIGNvbnN0IHt0YWcsIHJlY2VpdmVQcm9taXNlfSA9IHRoaXMuX3JlY2VpdmVQbGlzdFByb21pc2UodGltZW91dCwgKGRhdGEpID0+IHtcbiAgICAgIGlmIChkYXRhLnBheWxvYWQuRGV2aWNlTGlzdCkge1xuICAgICAgICByZXR1cm4gZGF0YS5wYXlsb2FkLkRldmljZUxpc3Q7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3NlbmRQbGlzdCh7XG4gICAgICB0YWcsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIE1lc3NhZ2VUeXBlOiAnTGlzdERldmljZXMnLFxuICAgICAgICBQcm9nTmFtZTogUFJPR19OQU1FLFxuICAgICAgICBDbGllbnRWZXJzaW9uU3RyaW5nOiBDTElFTlRfVkVSU0lPTl9TVFJJTkdcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhd2FpdCByZWNlaXZlUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rcyBmb3IgYSBkZXZpY2Ugd2l0aCB0aGUgcGFzc2VkIHVkaWQuIEl0IHdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgZGV2aWNlIGlzIG5vdCBmb3VuZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdWRpZCB0aGUgdWRpZCBvZiB0aGUgZGV2aWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dD01MDAwXSB0aGUgdGltZW91dCBvZiByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIHVzYm11eGRcbiAgICogQHJldHVybnMgez9PYmplY3R9XG4gICAqL1xuICBhc3luYyBmaW5kRGV2aWNlICh1ZGlkLCB0aW1lb3V0ID0gNTAwMCkge1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCB0aGlzLmxpc3REZXZpY2VzKHRpbWVvdXQpO1xuICAgIHJldHVybiBfLmZpbmQoZGV2aWNlcywgKGRldmljZSkgPT4gZGV2aWNlLlByb3BlcnRpZXMuU2VyaWFsTnVtYmVyID09PSB1ZGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgbG9ja2Rvd25kIG9uIHRoZSBkZXZpY2UgYW5kIHJldHVybnMgYSBMb2NrZG93biBjbGllbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgdGhlIHVkaWQgb2YgdGhlIGRldmljZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXQ9NTAwMF0gdGhlIHRpbWVvdXQgb2YgcmVjZWl2aW5nIGEgcmVzcG9uc2UgZnJvbSB1c2JtdXhkXG4gICAqIEByZXR1cm5zIHtMb2NrZG93bn1cbiAgICovXG4gIGFzeW5jIGNvbm5lY3RMb2NrZG93biAodWRpZCwgdGltZW91dCA9IDUwMDApIHtcbiAgICBjb25zdCBkZXZpY2UgPSBhd2FpdCB0aGlzLmZpbmREZXZpY2UodWRpZCwgdGltZW91dCk7XG4gICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdGhlIGV4cGVjdGVkIGRldmljZSAnJHt1ZGlkfSdgKTtcbiAgICB9XG4gICAgY29uc3Qgc29ja2V0ID0gYXdhaXQgdGhpcy5jb25uZWN0KGRldmljZS5Qcm9wZXJ0aWVzLkRldmljZUlELCBMT0NLRE9XTl9QT1JULCB0aW1lb3V0KTtcbiAgICByZXR1cm4gbmV3IExvY2tkb3duKG5ldyBQbGlzdFNlcnZpY2Uoc29ja2V0KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gYSBjZXJ0YWluIHBvcnQgb24gdGhlIGRldmljZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGV2aWNlSUQgdGhlIGRldmljZSBpZCB3aGljaCBjYW4gYmUgcmV0cmlldmVkIGZyb20gdGhlIHByb3BlcnRpZXMgb2YgYSBkZXZpY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnQgdGhlIHBvcnQgbnVtYmVyIHRoYXQgd2FudHMgdG8gYmUgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dD01MDAwXSB0aGUgdGltZW91dCBvZiByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIHVzYm11eGRcbiAgICogQHJldHVybnMge25ldC5Tb2NrZXR8T2JqZWN0fSBUaGUgc29ja2V0IG9yIHRoZSBvYmplY3QgcmV0dXJuZWQgaW4gdGhlIGNhbGxiYWNrIGlmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBleGlzdHNcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QgKGRldmljZUlELCBwb3J0LCB0aW1lb3V0ID0gNTAwMCkge1xuICAgIGNvbnN0IHt0YWcsIHJlY2VpdmVQcm9taXNlfSA9IHRoaXMuX3JlY2VpdmVQbGlzdFByb21pc2UodGltZW91dCwgKGRhdGEpID0+IHtcbiAgICAgIGlmIChkYXRhLnBheWxvYWQuTWVzc2FnZVR5cGUgIT09ICdSZXN1bHQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWApO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucGF5bG9hZC5OdW1iZXIgPT09IFVTQk1VWF9SRVNVTFQuT0spIHtcbiAgICAgICAgdGhpcy5fc3BsaXR0ZXIuc2h1dGRvd24oKTtcbiAgICAgICAgdGhpcy5fc29ja2V0Q2xpZW50LnVucGlwZSh0aGlzLl9zcGxpdHRlcik7XG4gICAgICAgIHRoaXMuX3NwbGl0dGVyLnVucGlwZSh0aGlzLl9kZWNvZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvY2tldENsaWVudDtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5wYXlsb2FkLk51bWJlciA9PT0gVVNCTVVYX1JFU1VMVC5DT05OUkVGVVNFRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gd2FzIHJlZnVzZWQgdG8gcG9ydCAke3BvcnR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3NlbmRQbGlzdCh7XG4gICAgICB0YWcsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIE1lc3NhZ2VUeXBlOiAnQ29ubmVjdCcsXG4gICAgICAgIFByb2dOYW1lOiBQUk9HX05BTUUsXG4gICAgICAgIENsaWVudFZlcnNpb25TdHJpbmc6IENMSUVOVF9WRVJTSU9OX1NUUklORyxcbiAgICAgICAgRGV2aWNlSUQ6IGRldmljZUlELFxuICAgICAgICBQb3J0TnVtYmVyOiBzd2FwMTYocG9ydClcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhd2FpdCByZWNlaXZlUHJvbWlzZTtcbiAgfVxufVxuXG5leHBvcnQgeyBVc2JtdXgsIGdldERlZmF1bHRTb2NrZXQgfTtcbmV4cG9ydCBkZWZhdWx0IFVzYm11eDtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FB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
