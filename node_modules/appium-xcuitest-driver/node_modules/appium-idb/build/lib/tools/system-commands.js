"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _support = require("@appium/support");

var _teen_process = require("teen_process");

var _lodash = _interopRequireDefault(require("lodash"));

var _asyncbox = require("asyncbox");

var _helpers = require("../helpers");

var _logger = _interopRequireDefault(require("../logger.js"));

const PROCESS_INIT_TIMEOUT = 5000;

const COMPANION_PGREP_PATTERN = udid => `${_helpers.IDB_COMPANION_EXECUTABLE}.*--udid[[:space:]]+${udid}`;

const COMPANION_STARTUP_REGEXP = /Started GRPC server on port (\d+)/;
const COMPANION_STARTUP_ERROR_REGEXP = /New Error Built ==> (.+)/;

function buildDaemonArgs(opts = {}) {
  const {
    port,
    grpcPort
  } = opts;
  const result = ['daemon'];

  if (port) {
    result.push('--port', port);
  }

  if (grpcPort) {
    result.push('--grpc-port', grpcPort);
  }

  return result;
}

const systemCallMethods = {};

systemCallMethods.connect = async function connect(opts = {}) {
  const {
    onlineTimeout
  } = opts;

  _logger.default.debug(`Connecting ${_helpers.IDB_EXECUTABLE} service to '${this.udid}'`);

  const binaryPaths = {};

  for (const binary of [_helpers.IDB_EXECUTABLE, _helpers.IDB_COMPANION_EXECUTABLE]) {
    try {
      binaryPaths[binary] = await _support.fs.which(binary);
    } catch (e) {
      throw new Error(`'${binary}' has not been found in PATH. ` + `Is it installed? Read https://www.fbidb.io for more details`);
    }
  }

  let grpcPort = _helpers.DEFAULT_COMPANION_GRPC_PORT;

  _logger.default.debug(`Starting companion: '${binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE]}'`);

  const companionProc = new _teen_process.SubProcess(binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE], ['--udid', this.udid]);
  let listeners = {
    'lines-stdout': null,
    'lines-stderr': null,
    exit: null
  };

  const cleanupListeners = () => {
    _lodash.default.toPairs(listeners).filter(([, v]) => _lodash.default.isFunction(v)).map(([k, v]) => companionProc.removeListener(k, v));

    listeners = {};
  };

  try {
    await companionProc.start(0);
    await new _bluebird.default((resolve, reject) => {
      for (const outType of ['stderr', 'stdout']) {
        const eventName = `lines-${outType}`;

        listeners[eventName] = lines => {
          for (const line of lines) {
            if (_lodash.default.isEmpty(_lodash.default.trim(line))) {
              continue;
            }

            if (this.verbose) {
              _logger.default.debug(`[${_helpers.IDB_COMPANION_EXECUTABLE} ${outType}] ${line}`);
            }

            const readyMatch = COMPANION_STARTUP_REGEXP.exec(line);

            if (readyMatch) {
              grpcPort = readyMatch[1];
              resolve();
            } else {
              const errorMatch = COMPANION_STARTUP_ERROR_REGEXP.exec(line);

              if (errorMatch) {
                reject(new Error(errorMatch[1]));
              }
            }
          }
        };

        companionProc.on(eventName, listeners[eventName]);
      }

      listeners.exit = (code, signal) => {
        cleanupListeners();
        const message = `${_helpers.IDB_COMPANION_EXECUTABLE} exited with code '${code}' from signal '${signal}'`;

        _logger.default.debug(message);

        reject(new Error(message));
      };

      companionProc.once('exit', listeners.exit);
    }).timeout(60000, 'Was unable to acquire a GRPC port after 60 seconds timeout');
  } catch (err) {
    cleanupListeners();

    if (companionProc.isRunning) {
      try {
        await companionProc.stop();
      } catch (ign) {}
    }

    _logger.default.error(`Failed to start ${_helpers.IDB_COMPANION_EXECUTABLE}: ${err.message}`);

    throw err;
  }

  _logger.default.debug(`${_helpers.IDB_COMPANION_EXECUTABLE} is listening on GRPC port '${grpcPort}'`);

  try {
    try {
      await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['connect', '127.0.0.1', grpcPort]);
    } catch (connectionError) {
      await (0, _asyncbox.retryInterval)(2, 100, async () => {
        await this.disconnect();

        try {
          await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['kill']);
        } catch (ign) {}

        let isStartupMonitorEnabled = true;

        try {
          const daemon = new _teen_process.SubProcess(_helpers.IDB_EXECUTABLE, buildDaemonArgs({
            port: this.executable.port,
            grpcPort
          }));
          let daemonOutput = '';
          daemon.on('output', (stdout, stderr) => {
            if (isStartupMonitorEnabled && _lodash.default.trim(stdout || stderr)) {
              daemonOutput += `[daemon] ${stdout || stderr}\n`;
            }
          });

          try {
            await daemon.start(null, PROCESS_INIT_TIMEOUT);
            await _bluebird.default.delay(300);
          } catch (ign) {}

          if (daemon.isRunning) {
            _logger.default.debug(`${_helpers.IDB_EXECUTABLE} daemon started on port ${this.executable.port || _helpers.DEFAULT_IDB_PORT}`);
          } else {
            if (!daemonOutput.includes('address already in use')) {
              const message = `${_helpers.IDB_EXECUTABLE} daemon has failed to start: ${daemonOutput}`;

              _logger.default.warn(message);

              throw new Error(message);
            }

            _logger.default.debug(`The port ${this.executable.port || _helpers.DEFAULT_IDB_PORT} is already in use. ` + `Assuming it is used by ${_helpers.IDB_EXECUTABLE} daemon`);
          }

          await (0, _teen_process.exec)(_helpers.IDB_EXECUTABLE, ['connect', '127.0.0.1', grpcPort]);
        } catch (connectionError2) {
          if (connectionError2.stderr || connectionError2.stdout) {
            _logger.default.debug(connectionError2.stderr || connectionError2.stdout);
          }

          throw connectionError2;
        } finally {
          isStartupMonitorEnabled = false;
        }
      });
    }
  } catch (e) {
    if (e.stderr) {
      _logger.default.debug(e.stderr);
    }

    throw new Error(`Cannot start ${_helpers.IDB_EXECUTABLE} service for '${this.udid}'. ` + `Check the server log for more details.`);
  }

  _logger.default.info(`Successfully established the connection to ${_helpers.IDB_EXECUTABLE} service for '${this.udid}'`);

  if (onlineTimeout) {
    await this.waitForDevice(onlineTimeout);
  }

  this.executable.path = binaryPaths[_helpers.IDB_EXECUTABLE];
  this.companion.path = binaryPaths[_helpers.IDB_COMPANION_EXECUTABLE];
};

systemCallMethods.waitForDevice = async function waitForDevice(timeoutMs = 10000) {
  if (!timeoutMs) {
    _logger.default.debug('No timeout is provided, so not waiting until the device is online');

    return;
  }

  _logger.default.debug(`Waiting up to ${timeoutMs}ms for the device to be online`);

  const timer = new _support.timing.Timer().start();

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        await this.exec(['ui', 'describe-all']);
        return true;
      } catch (e) {
        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 300
    });
  } catch (e) {
    throw new Error(`The device '${this.udid}' is not responding to idb requests after ${timeoutMs}ms timeout. ` + `Original error: ${e.stderr || e.message}`);
  }

  _logger.default.debug(`The device '${this.udid}' is online and ready to accept idb commands in ` + `${timer.getDuration().asSeconds.toFixed(3)}s`);
};

systemCallMethods.disconnect = async function disconnect() {
  _logger.default.debug(`Disconnecting ${_helpers.IDB_EXECUTABLE} service from '${this.udid}'`);

  try {
    await (0, _teen_process.exec)(this.executable.path, ['disconnect', this.udid]);
  } catch (ign) {}

  const companionPids = await (0, _helpers.getPids)(COMPANION_PGREP_PATTERN(this.udid));

  if (_lodash.default.isEmpty(companionPids)) {
    return;
  }

  _logger.default.debug(`Cleaning up ${companionPids.length} obsolete ${_helpers.IDB_COMPANION_EXECUTABLE} ` + `process${companionPids.length === 1 ? '' : 'es'}`);

  await (0, _teen_process.exec)('kill', ['-2', ...companionPids]);
};

systemCallMethods.exec = async function exec(cmd, args = [], opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to exec()');
  }

  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  opts = _lodash.default.cloneDeep(opts);
  opts.timeout = opts.timeout || this.execTimeout || _helpers.DEFAULT_IDB_EXEC_TIMEOUT;
  opts.timeoutCapName = opts.timeoutCapName || 'execTimeout';
  const fullArgs = [...cmd, ...this.executable.defaultArgs, ...args];

  _logger.default.debug(`Running '${this.executable.path} ${_support.util.quote(fullArgs)}'`);

  try {
    const {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, fullArgs, opts);
    return stdout;
  } catch (e) {
    if (_support.util.hasValue(e.code)) {
      e.message = `Error executing ${_helpers.IDB_EXECUTABLE}. Original error: '${e.message}'; ` + `Stdout: '${(e.stdout || '').trim()}'; ` + `Stderr: '${(e.stderr || '').trim()}'; ` + `Code: '${e.code}'`;
    } else {
      e.message = `Error executing ${_helpers.IDB_EXECUTABLE}. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms ${_helpers.IDB_EXECUTABLE} execution timeout represented by '${opts.timeoutCapName}' capability`;
    }

    throw e;
  }
};

systemCallMethods.createSubProcess = function createSubProcess(command = [], args = [], opts = {}) {
  const idbArgs = [...command, ...this.executable.defaultArgs, ...args];

  _logger.default.debug(`Creating ${_helpers.IDB_EXECUTABLE} subprocess with args: ${_support.util.quote(args)}`);

  return new _teen_process.SubProcess(this.executable.path, idbArgs, opts);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL3Rvb2xzL3N5c3RlbS1jb21tYW5kcy5qcyIsIm5hbWVzIjpbIlBST0NFU1NfSU5JVF9USU1FT1VUIiwiQ09NUEFOSU9OX1BHUkVQX1BBVFRFUk4iLCJ1ZGlkIiwiSURCX0NPTVBBTklPTl9FWEVDVVRBQkxFIiwiQ09NUEFOSU9OX1NUQVJUVVBfUkVHRVhQIiwiQ09NUEFOSU9OX1NUQVJUVVBfRVJST1JfUkVHRVhQIiwiYnVpbGREYWVtb25BcmdzIiwib3B0cyIsInBvcnQiLCJncnBjUG9ydCIsInJlc3VsdCIsInB1c2giLCJzeXN0ZW1DYWxsTWV0aG9kcyIsImNvbm5lY3QiLCJvbmxpbmVUaW1lb3V0IiwibG9nIiwiZGVidWciLCJJREJfRVhFQ1VUQUJMRSIsImJpbmFyeVBhdGhzIiwiYmluYXJ5IiwiZnMiLCJ3aGljaCIsImUiLCJFcnJvciIsIkRFRkFVTFRfQ09NUEFOSU9OX0dSUENfUE9SVCIsImNvbXBhbmlvblByb2MiLCJTdWJQcm9jZXNzIiwibGlzdGVuZXJzIiwiZXhpdCIsImNsZWFudXBMaXN0ZW5lcnMiLCJfIiwidG9QYWlycyIsImZpbHRlciIsInYiLCJpc0Z1bmN0aW9uIiwibWFwIiwiayIsInJlbW92ZUxpc3RlbmVyIiwic3RhcnQiLCJCIiwicmVzb2x2ZSIsInJlamVjdCIsIm91dFR5cGUiLCJldmVudE5hbWUiLCJsaW5lcyIsImxpbmUiLCJpc0VtcHR5IiwidHJpbSIsInZlcmJvc2UiLCJyZWFkeU1hdGNoIiwiZXhlYyIsImVycm9yTWF0Y2giLCJvbiIsImNvZGUiLCJzaWduYWwiLCJtZXNzYWdlIiwib25jZSIsInRpbWVvdXQiLCJlcnIiLCJpc1J1bm5pbmciLCJzdG9wIiwiaWduIiwiZXJyb3IiLCJjb25uZWN0aW9uRXJyb3IiLCJkaXNjb25uZWN0IiwiaXNTdGFydHVwTW9uaXRvckVuYWJsZWQiLCJkYWVtb24iLCJleGVjdXRhYmxlIiwiZGFlbW9uT3V0cHV0Iiwic3Rkb3V0Iiwic3RkZXJyIiwiZGVsYXkiLCJERUZBVUxUX0lEQl9QT1JUIiwiaW5jbHVkZXMiLCJ3YXJuIiwiY29ubmVjdGlvbkVycm9yMiIsImluZm8iLCJ3YWl0Rm9yRGV2aWNlIiwicGF0aCIsImNvbXBhbmlvbiIsInRpbWVvdXRNcyIsInRpbWVyIiwidGltaW5nIiwiVGltZXIiLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwiZ2V0RHVyYXRpb24iLCJhc1NlY29uZHMiLCJ0b0ZpeGVkIiwiY29tcGFuaW9uUGlkcyIsImxlbmd0aCIsImNtZCIsImFyZ3MiLCJpc0FycmF5IiwiY2xvbmVEZWVwIiwiZXhlY1RpbWVvdXQiLCJERUZBVUxUX0lEQl9FWEVDX1RJTUVPVVQiLCJ0aW1lb3V0Q2FwTmFtZSIsImZ1bGxBcmdzIiwiZGVmYXVsdEFyZ3MiLCJ1dGlsIiwicXVvdGUiLCJoYXNWYWx1ZSIsImNyZWF0ZVN1YlByb2Nlc3MiLCJjb21tYW5kIiwiaWRiQXJncyJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4iLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY29tbWFuZHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgZnMsIHV0aWwsIHRpbWluZyB9IGZyb20gJ0BhcHBpdW0vc3VwcG9ydCc7XG5pbXBvcnQgeyBleGVjIGFzIHRwRXhlYywgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcmV0cnlJbnRlcnZhbCwgd2FpdEZvckNvbmRpdGlvbiB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCB7XG4gIGdldFBpZHMsIERFRkFVTFRfSURCX0VYRUNfVElNRU9VVCwgSURCX0VYRUNVVEFCTEUsXG4gIElEQl9DT01QQU5JT05fRVhFQ1VUQUJMRSwgREVGQVVMVF9JREJfUE9SVCwgREVGQVVMVF9DT01QQU5JT05fR1JQQ19QT1JULFxufSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyLmpzJztcblxuXG5jb25zdCBQUk9DRVNTX0lOSVRfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBDT01QQU5JT05fUEdSRVBfUEFUVEVSTiA9ICh1ZGlkKSA9PlxuICBgJHtJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEV9LiotLXVkaWRbWzpzcGFjZTpdXSske3VkaWR9YDtcbmNvbnN0IENPTVBBTklPTl9TVEFSVFVQX1JFR0VYUCA9IC9TdGFydGVkIEdSUEMgc2VydmVyIG9uIHBvcnQgKFxcZCspLztcbmNvbnN0IENPTVBBTklPTl9TVEFSVFVQX0VSUk9SX1JFR0VYUCA9IC9OZXcgRXJyb3IgQnVpbHQgPT0+ICguKykvO1xuXG5mdW5jdGlvbiBidWlsZERhZW1vbkFyZ3MgKG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcG9ydCxcbiAgICBncnBjUG9ydCxcbiAgfSA9IG9wdHM7XG5cbiAgY29uc3QgcmVzdWx0ID0gWydkYWVtb24nXTtcbiAgaWYgKHBvcnQpIHtcbiAgICByZXN1bHQucHVzaCgnLS1wb3J0JywgcG9ydCk7XG4gIH1cbiAgaWYgKGdycGNQb3J0KSB7XG4gICAgcmVzdWx0LnB1c2goJy0tZ3JwYy1wb3J0JywgZ3JwY1BvcnQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuY29uc3Qgc3lzdGVtQ2FsbE1ldGhvZHMgPSB7fTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb25uZWN0T3B0aW9uc1xuICpcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gb25saW5lVGltZW91dCAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqIHVudGlsIHRoZSBkZXZpY2UgdW5kZXIgdGVzdHMgaXMgb25saW5lLiBObyB3YWl0IGlzIGdvaW5nIHRvIGJlIHBlcmZvcm1lZFxuICogaWYgdGhlIHRpbWVvdXQgaXMgbm90IHNldC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gcHJvdmlkZSB0aGlzIHZhbHVlIGlmXG4gKiBgY29ubmVjdGAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIGRldmljZSBpcyBib290ZWQsIHNvIG5vdCBhbGwgdGhlIHJlcXVpcmVkXG4gKiBkZXZpY2Ugc2VydmljZXMgaGF2ZSBiZWVuIHN0YXJ0ZWQgeWV0LlxuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgaWRiIGFuZCBjb21wYW5pb24gcHJvY2Vzc2VzIGlmIG5lY2Vzc2FyeSBhbmRcbiAqIGFzc2lnbnMgcGF0aCBwcm9wZXJ0aWVzLiBJdCBpcyBtYW5kYXRvcnkgdG8gY2FsbCB0aGlzIG1ldGhvZCBiZWZvcmVcbiAqIG9uZSBjYW4gc3RhcnQgdXNpbmcgSURCIGluc3RhbmNlLFxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBtYW5kYXRvcnkgaWRiIGV4ZWN1dGFibGVzIGFyZSBub3QgcHJlc2VudCBvbiB0aGVcbiAqIGxvY2FsaG9zdCBvciB0aGVyZSB3YXMgYSBmYWlsdXJlIHdoaWxlIHN0YXJ0aW5nL2RldGVjdGluZyB0aGVtXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmNvbm5lY3QgPSBhc3luYyBmdW5jdGlvbiBjb25uZWN0IChvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG9ubGluZVRpbWVvdXQsXG4gIH0gPSBvcHRzO1xuXG4gIGxvZy5kZWJ1ZyhgQ29ubmVjdGluZyAke0lEQl9FWEVDVVRBQkxFfSBzZXJ2aWNlIHRvICcke3RoaXMudWRpZH0nYCk7XG5cbiAgY29uc3QgYmluYXJ5UGF0aHMgPSB7fTtcbiAgZm9yIChjb25zdCBiaW5hcnkgb2YgW0lEQl9FWEVDVVRBQkxFLCBJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEVdKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJpbmFyeVBhdGhzW2JpbmFyeV0gPSBhd2FpdCBmcy53aGljaChiaW5hcnkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7YmluYXJ5fScgaGFzIG5vdCBiZWVuIGZvdW5kIGluIFBBVEguIGAgK1xuICAgICAgICBgSXMgaXQgaW5zdGFsbGVkPyBSZWFkIGh0dHBzOi8vd3d3LmZiaWRiLmlvIGZvciBtb3JlIGRldGFpbHNgKTtcbiAgICB9XG4gIH1cblxuICBsZXQgZ3JwY1BvcnQgPSBERUZBVUxUX0NPTVBBTklPTl9HUlBDX1BPUlQ7XG4gIGxvZy5kZWJ1ZyhgU3RhcnRpbmcgY29tcGFuaW9uOiAnJHtiaW5hcnlQYXRoc1tJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEVdfSdgKTtcbiAgY29uc3QgY29tcGFuaW9uUHJvYyA9IG5ldyBTdWJQcm9jZXNzKGJpbmFyeVBhdGhzW0lEQl9DT01QQU5JT05fRVhFQ1VUQUJMRV0sIFsnLS11ZGlkJywgdGhpcy51ZGlkXSk7XG4gIGxldCBsaXN0ZW5lcnMgPSB7XG4gICAgJ2xpbmVzLXN0ZG91dCc6IG51bGwsXG4gICAgJ2xpbmVzLXN0ZGVycic6IG51bGwsXG4gICAgZXhpdDogbnVsbCxcbiAgfTtcbiAgY29uc3QgY2xlYW51cExpc3RlbmVycyA9ICgpID0+IHtcbiAgICBfLnRvUGFpcnMobGlzdGVuZXJzKVxuICAgICAgLmZpbHRlcigoWywgdl0pID0+IF8uaXNGdW5jdGlvbih2KSlcbiAgICAgIC5tYXAoKFtrLCB2XSkgPT4gY29tcGFuaW9uUHJvYy5yZW1vdmVMaXN0ZW5lcihrLCB2KSk7XG4gICAgbGlzdGVuZXJzID0ge307XG4gIH07XG4gIHRyeSB7XG4gICAgYXdhaXQgY29tcGFuaW9uUHJvYy5zdGFydCgwKTtcblxuICAgIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZvciAoY29uc3Qgb3V0VHlwZSBvZiBbJ3N0ZGVycicsICdzdGRvdXQnXSkge1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBgbGluZXMtJHtvdXRUeXBlfWA7XG4gICAgICAgIGxpc3RlbmVyc1tldmVudE5hbWVdID0gKGxpbmVzKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0VtcHR5KF8udHJpbShsaW5lKSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgbG9nLmRlYnVnKGBbJHtJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEV9ICR7b3V0VHlwZX1dICR7bGluZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG1hcmtlciB0aGF0IHRoaW5ncyBhcmUgcmVhZHkgdG8gZ29cbiAgICAgICAgICAgIGNvbnN0IHJlYWR5TWF0Y2ggPSBDT01QQU5JT05fU1RBUlRVUF9SRUdFWFAuZXhlYyhsaW5lKTtcbiAgICAgICAgICAgIGlmIChyZWFkeU1hdGNoKSB7XG4gICAgICAgICAgICAgIC8vIGZpbmQgdGhlIHBvcnQgYW5kIHNhdmUsIHNvIGlkYiBjYW4gY29ubmVjdFxuICAgICAgICAgICAgICBncnBjUG9ydCA9IHJlYWR5TWF0Y2hbMV07XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGhhcyBiZWVuIGFuIGVycm9yXG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yTWF0Y2ggPSBDT01QQU5JT05fU1RBUlRVUF9FUlJPUl9SRUdFWFAuZXhlYyhsaW5lKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yTWF0Y2hbMV0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29tcGFuaW9uUHJvYy5vbihldmVudE5hbWUsIGxpc3RlbmVyc1tldmVudE5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzLmV4aXQgPSAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lcnMoKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke0lEQl9DT01QQU5JT05fRVhFQ1VUQUJMRX0gZXhpdGVkIHdpdGggY29kZSAnJHtjb2RlfScgZnJvbSBzaWduYWwgJyR7c2lnbmFsfSdgO1xuICAgICAgICBsb2cuZGVidWcobWVzc2FnZSk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgICAgfTtcbiAgICAgIGNvbXBhbmlvblByb2Mub25jZSgnZXhpdCcsIGxpc3RlbmVycy5leGl0KTtcbiAgICB9KS50aW1lb3V0KDYwMDAwLCAnV2FzIHVuYWJsZSB0byBhY3F1aXJlIGEgR1JQQyBwb3J0IGFmdGVyIDYwIHNlY29uZHMgdGltZW91dCcpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjbGVhbnVwTGlzdGVuZXJzKCk7XG4gICAgaWYgKGNvbXBhbmlvblByb2MuaXNSdW5uaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjb21wYW5pb25Qcm9jLnN0b3AoKTtcbiAgICAgIH0gY2F0Y2ggKGlnbikge31cbiAgICB9XG4gICAgbG9nLmVycm9yKGBGYWlsZWQgdG8gc3RhcnQgJHtJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgJHtJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEV9IGlzIGxpc3RlbmluZyBvbiBHUlBDIHBvcnQgJyR7Z3JwY1BvcnR9J2ApO1xuXG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRwRXhlYyhJREJfRVhFQ1VUQUJMRSwgWydjb25uZWN0JywgJzEyNy4wLjAuMScsIGdycGNQb3J0XSk7XG4gICAgfSBjYXRjaCAoY29ubmVjdGlvbkVycm9yKSB7XG4gICAgICBhd2FpdCByZXRyeUludGVydmFsKDIsIDEwMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0cEV4ZWMoSURCX0VYRUNVVEFCTEUsIFsna2lsbCddKTtcbiAgICAgICAgfSBjYXRjaCAoaWduKSB7fVxuICAgICAgICBsZXQgaXNTdGFydHVwTW9uaXRvckVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRhZW1vbiA9IG5ldyBTdWJQcm9jZXNzKElEQl9FWEVDVVRBQkxFLCBidWlsZERhZW1vbkFyZ3Moe1xuICAgICAgICAgICAgcG9ydDogdGhpcy5leGVjdXRhYmxlLnBvcnQsXG4gICAgICAgICAgICBncnBjUG9ydCxcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgbGV0IGRhZW1vbk91dHB1dCA9ICcnO1xuICAgICAgICAgIGRhZW1vbi5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTdGFydHVwTW9uaXRvckVuYWJsZWQgJiYgXy50cmltKHN0ZG91dCB8fCBzdGRlcnIpKSB7XG4gICAgICAgICAgICAgIGRhZW1vbk91dHB1dCArPSBgW2RhZW1vbl0gJHtzdGRvdXQgfHwgc3RkZXJyfVxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGRhZW1vbi5zdGFydChudWxsLCBQUk9DRVNTX0lOSVRfVElNRU9VVCk7XG4gICAgICAgICAgICBhd2FpdCBCLmRlbGF5KDMwMCk7XG4gICAgICAgICAgfSBjYXRjaCAoaWduKSB7fVxuXG4gICAgICAgICAgaWYgKGRhZW1vbi5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgJHtJREJfRVhFQ1VUQUJMRX0gZGFlbW9uIHN0YXJ0ZWQgb24gcG9ydCAke3RoaXMuZXhlY3V0YWJsZS5wb3J0IHx8IERFRkFVTFRfSURCX1BPUlR9YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZGFlbW9uT3V0cHV0LmluY2x1ZGVzKCdhZGRyZXNzIGFscmVhZHkgaW4gdXNlJykpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke0lEQl9FWEVDVVRBQkxFfSBkYWVtb24gaGFzIGZhaWxlZCB0byBzdGFydDogJHtkYWVtb25PdXRwdXR9YDtcbiAgICAgICAgICAgICAgbG9nLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgVGhlIHBvcnQgJHt0aGlzLmV4ZWN1dGFibGUucG9ydCB8fCBERUZBVUxUX0lEQl9QT1JUfSBpcyBhbHJlYWR5IGluIHVzZS4gYCArXG4gICAgICAgICAgICAgIGBBc3N1bWluZyBpdCBpcyB1c2VkIGJ5ICR7SURCX0VYRUNVVEFCTEV9IGRhZW1vbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCB0cEV4ZWMoSURCX0VYRUNVVEFCTEUsIFsnY29ubmVjdCcsICcxMjcuMC4wLjEnLCBncnBjUG9ydF0pO1xuICAgICAgICB9IGNhdGNoIChjb25uZWN0aW9uRXJyb3IyKSB7XG4gICAgICAgICAgaWYgKGNvbm5lY3Rpb25FcnJvcjIuc3RkZXJyIHx8IGNvbm5lY3Rpb25FcnJvcjIuc3Rkb3V0KSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoY29ubmVjdGlvbkVycm9yMi5zdGRlcnIgfHwgY29ubmVjdGlvbkVycm9yMi5zdGRvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uRXJyb3IyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlzU3RhcnR1cE1vbml0b3JFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLnN0ZGVycikge1xuICAgICAgbG9nLmRlYnVnKGUuc3RkZXJyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3RhcnQgJHtJREJfRVhFQ1VUQUJMRX0gc2VydmljZSBmb3IgJyR7dGhpcy51ZGlkfScuIGAgK1xuICAgICAgYENoZWNrIHRoZSBzZXJ2ZXIgbG9nIGZvciBtb3JlIGRldGFpbHMuYCk7XG4gIH1cbiAgbG9nLmluZm8oYFN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCB0aGUgY29ubmVjdGlvbiB0byAke0lEQl9FWEVDVVRBQkxFfSBzZXJ2aWNlIGZvciAnJHt0aGlzLnVkaWR9J2ApO1xuXG4gIGlmIChvbmxpbmVUaW1lb3V0KSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRGV2aWNlKG9ubGluZVRpbWVvdXQpO1xuICB9XG5cbiAgdGhpcy5leGVjdXRhYmxlLnBhdGggPSBiaW5hcnlQYXRoc1tJREJfRVhFQ1VUQUJMRV07XG4gIHRoaXMuY29tcGFuaW9uLnBhdGggPSBiaW5hcnlQYXRoc1tJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEVdO1xufTtcblxuLyoqXG4gKiBCbG9ja3MgdW50aWwgdGhlIGRldmljZSB1bmRlciB0ZXN0IHN0YXJ0cyByZXNwb25kaW5nIHRvIGlkYiBjb21tYW5kcy5cbiAqIFRoZSBkZXZpY2UgbXVzdCBiZSBib290ZWQvb25saW5lIGFuZCBpZGIgbXVzdCBiZSBhbHJlYWR5IGNvbm5lY3RlZCBmb3IgdGhhdCB0byBoYXBwZW5cbiAqXG4gKiBAcGFyYW0gez9udW1iZXJ9IHRpbWVvdXRNcyBbMTAwMDBdIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdFxuICogdW50aWwgdGhlIGRldmljZSB1bmRlciB0ZXN0cyBpcyBvbmxpbmUuIFRoZSBtZXRob2Qgd2lsbCByZXR1cm4gaW1tZWRpYXRlbHlcbiAqIGlmIHRoZSB0aW1lb3V0IGlzIGZhbHN5XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRldmljZSBpcyBub3QgcmVzcG9uZGluZyB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXRcbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckRldmljZSA9IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JEZXZpY2UgKHRpbWVvdXRNcyA9IDEwMDAwKSB7XG4gIGlmICghdGltZW91dE1zKSB7XG4gICAgbG9nLmRlYnVnKCdObyB0aW1lb3V0IGlzIHByb3ZpZGVkLCBzbyBub3Qgd2FpdGluZyB1bnRpbCB0aGUgZGV2aWNlIGlzIG9ubGluZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgV2FpdGluZyB1cCB0byAke3RpbWVvdXRNc31tcyBmb3IgdGhlIGRldmljZSB0byBiZSBvbmxpbmVgKTtcbiAgY29uc3QgdGltZXIgPSBuZXcgdGltaW5nLlRpbWVyKCkuc3RhcnQoKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZXhlYyhbJ3VpJywgJ2Rlc2NyaWJlLWFsbCddKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB3YWl0TXM6IHRpbWVvdXRNcyxcbiAgICAgIGludGVydmFsTXM6IDMwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRldmljZSAnJHt0aGlzLnVkaWR9JyBpcyBub3QgcmVzcG9uZGluZyB0byBpZGIgcmVxdWVzdHMgYWZ0ZXIgJHt0aW1lb3V0TXN9bXMgdGltZW91dC4gYCArXG4gICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5zdGRlcnIgfHwgZS5tZXNzYWdlfWApO1xuICB9XG4gIGxvZy5kZWJ1ZyhgVGhlIGRldmljZSAnJHt0aGlzLnVkaWR9JyBpcyBvbmxpbmUgYW5kIHJlYWR5IHRvIGFjY2VwdCBpZGIgY29tbWFuZHMgaW4gYCArXG4gICAgYCR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHMudG9GaXhlZCgzKX1zYCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGNsZWFudXAgb2Ygb2Jzb2xldGUgY29tcGFuaW9uIHByb2Nlc3Nlc1xuICogVGhlIGRhZW1vbiBwcm9jZXNzIGlzIGxlZnQgdW50b3VjaGVkLCBiZWNhdXNlIGtpbGxpbmcgaXQgbWlnaHRcbiAqIHBvdGVudGlhbGx5IGFmZmVjdCBvdGhlciBwYXJhbGxlbCBzZXNzaW9ucy4gTm90aGluZ1xuICogaXMgZG9uZSBpZiBubyBvYnNvbGV0ZSBwcm9jZXNzZXMgYXJlIGZvdW5kLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5kaXNjb25uZWN0ID0gYXN5bmMgZnVuY3Rpb24gZGlzY29ubmVjdCAoKSB7XG4gIGxvZy5kZWJ1ZyhgRGlzY29ubmVjdGluZyAke0lEQl9FWEVDVVRBQkxFfSBzZXJ2aWNlIGZyb20gJyR7dGhpcy51ZGlkfSdgKTtcblxuICB0cnkge1xuICAgIGF3YWl0IHRwRXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWydkaXNjb25uZWN0JywgdGhpcy51ZGlkXSk7XG4gIH0gY2F0Y2ggKGlnbikge31cblxuICBjb25zdCBjb21wYW5pb25QaWRzID0gYXdhaXQgZ2V0UGlkcyhDT01QQU5JT05fUEdSRVBfUEFUVEVSTih0aGlzLnVkaWQpKTtcbiAgaWYgKF8uaXNFbXB0eShjb21wYW5pb25QaWRzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgQ2xlYW5pbmcgdXAgJHtjb21wYW5pb25QaWRzLmxlbmd0aH0gb2Jzb2xldGUgJHtJREJfQ09NUEFOSU9OX0VYRUNVVEFCTEV9IGAgK1xuICAgIGBwcm9jZXNzJHtjb21wYW5pb25QaWRzLmxlbmd0aCA9PT0gMSA/ICcnIDogJ2VzJ31gKTtcbiAgYXdhaXQgdHBFeGVjKCdraWxsJywgWyctMicsIC4uLmNvbXBhbmlvblBpZHNdKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gaWRiIGNvbW1hbmQuXG4gKlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY21kIC0gVGhlIGFjdHVhbCBpZGIgY29tbWFuZCB3aXRob3V0IGFyZ3VtZW50cy9wYXJhbXMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFyZ3MgLSBPcHRpb25hbCBjb21tYW5kIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZXhlYyA9IGFzeW5jIGZ1bmN0aW9uIGV4ZWMgKGNtZCwgYXJncyA9IFtdLCBvcHRzID0ge30pIHtcbiAgaWYgKCFjbWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHBhc3MgaW4gYSBjb21tYW5kIHRvIGV4ZWMoKScpO1xuICB9XG4gIGNtZCA9IF8uaXNBcnJheShjbWQpID8gY21kIDogW2NtZF07XG5cbiAgb3B0cyA9IF8uY2xvbmVEZWVwKG9wdHMpO1xuICAvLyBzZXR0aW5nIGRlZmF1bHQgdGltZW91dCBmb3IgZWFjaCBjb21tYW5kIHRvIHByZXZlbnQgaW5maW5pdGUgd2FpdC5cbiAgb3B0cy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IHRoaXMuZXhlY1RpbWVvdXQgfHwgREVGQVVMVF9JREJfRVhFQ19USU1FT1VUO1xuICBvcHRzLnRpbWVvdXRDYXBOYW1lID0gb3B0cy50aW1lb3V0Q2FwTmFtZSB8fCAnZXhlY1RpbWVvdXQnOyAvLyBGb3IgZXJyb3IgbWVzc2FnZVxuXG4gIGNvbnN0IGZ1bGxBcmdzID0gWy4uLmNtZCwgLi4udGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLCAuLi5hcmdzXTtcbiAgbG9nLmRlYnVnKGBSdW5uaW5nICcke3RoaXMuZXhlY3V0YWJsZS5wYXRofSAke3V0aWwucXVvdGUoZnVsbEFyZ3MpfSdgKTtcbiAgdHJ5IHtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHRwRXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgZnVsbEFyZ3MsIG9wdHMpO1xuICAgIHJldHVybiBzdGRvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodXRpbC5oYXNWYWx1ZShlLmNvZGUpKSB7XG4gICAgICBlLm1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nICR7SURCX0VYRUNVVEFCTEV9LiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICBgU3Rkb3V0OiAnJHsoZS5zdGRvdXQgfHwgJycpLnRyaW0oKX0nOyBgICtcbiAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgYCArXG4gICAgICAgIGBDb2RlOiAnJHtlLmNvZGV9J2A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGUubWVzc2FnZSA9IGBFcnJvciBleGVjdXRpbmcgJHtJREJfRVhFQ1VUQUJMRX0uIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9Jy4gYCArXG4gICAgICAgIGBUcnkgdG8gaW5jcmVhc2UgdGhlICR7b3B0cy50aW1lb3V0fW1zICR7SURCX0VYRUNVVEFCTEV9IGV4ZWN1dGlvbiB0aW1lb3V0IHJlcHJlc2VudGVkIGJ5ICcke29wdHMudGltZW91dENhcE5hbWV9JyBjYXBhYmlsaXR5YDtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIFN1YlByb2Nlc3MgaW5zdGFuY2Ugb2YgaWRiIGZvciBiYWNrZ3JvdW5kXG4gKiBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBjb21tYW5kIGRlc2lyZWQgaWRiIGNvbW1hbmQgKGUuZy46IFtcImxhdW5jaFwiXSwgW1wieGN0ZXN0XCIsIFwicnVuXCIsIFwidWlcIl0pXG4gKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IGFyZ3MgYWRkaXRpb25hbCBpZGIgYXJndW1lbnRzXG4gKiBAcmV0dXJucyB7U3ViUHJvY2Vzc31cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuY3JlYXRlU3ViUHJvY2VzcyA9IGZ1bmN0aW9uIGNyZWF0ZVN1YlByb2Nlc3MgKGNvbW1hbmQgPSBbXSwgYXJncyA9IFtdLCBvcHRzID0ge30pIHtcbiAgY29uc3QgaWRiQXJncyA9IFsuLi5jb21tYW5kLCAuLi50aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MsIC4uLmFyZ3NdO1xuICBsb2cuZGVidWcoYENyZWF0aW5nICR7SURCX0VYRUNVVEFCTEV9IHN1YnByb2Nlc3Mgd2l0aCBhcmdzOiAke3V0aWwucXVvdGUoYXJncyl9YCk7XG4gIHJldHVybiBuZXcgU3ViUHJvY2Vzcyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgaWRiQXJncywgb3B0cyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzeXN0ZW1DYWxsTWV0aG9kcztcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFHQSxNQUFNQSxvQkFBb0IsR0FBRyxJQUE3Qjs7QUFDQSxNQUFNQyx1QkFBdUIsR0FBSUMsSUFBRCxJQUM3QixHQUFFQyxpQ0FBeUIsdUJBQXNCRCxJQUFLLEVBRHpEOztBQUVBLE1BQU1FLHdCQUF3QixHQUFHLG1DQUFqQztBQUNBLE1BQU1DLDhCQUE4QixHQUFHLDBCQUF2Qzs7QUFFQSxTQUFTQyxlQUFULENBQTBCQyxJQUFJLEdBQUcsRUFBakMsRUFBcUM7RUFDbkMsTUFBTTtJQUNKQyxJQURJO0lBRUpDO0VBRkksSUFHRkYsSUFISjtFQUtBLE1BQU1HLE1BQU0sR0FBRyxDQUFDLFFBQUQsQ0FBZjs7RUFDQSxJQUFJRixJQUFKLEVBQVU7SUFDUkUsTUFBTSxDQUFDQyxJQUFQLENBQVksUUFBWixFQUFzQkgsSUFBdEI7RUFDRDs7RUFDRCxJQUFJQyxRQUFKLEVBQWM7SUFDWkMsTUFBTSxDQUFDQyxJQUFQ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
