"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getLogger = getLogger;
exports.loadSecureValuesPreprocessingRules = loadSecureValuesPreprocessingRules;
exports.log = void 0;
exports.patchLogger = patchLogger;

require("source-map-support/register");

var _npmlog = _interopRequireDefault(require("npmlog"));

var _lodash = _interopRequireDefault(require("lodash"));

var _util = require("./util");

var _moment = _interopRequireDefault(require("moment"));

var _logInternal = _interopRequireDefault(require("./log-internal"));

const NPM_LEVELS = ['silly', 'verbose', 'debug', 'info', 'http', 'warn', 'error'];
const MAX_LOG_RECORDS_COUNT = 3000;
const PREFIX_TIMESTAMP_FORMAT = 'HH-mm-ss:SSS';
let mockLog = {};

for (let level of NPM_LEVELS) {
  mockLog[level] = () => {};
}

function patchLogger(logger) {
  if (!logger.debug) {
    logger.addLevel('debug', 1000, {
      fg: 'blue',
      bg: 'black'
    }, 'dbug');
  }
}

function _getLogger() {
  const testingMode = process.env._TESTING === '1';
  const forceLogMode = process.env._FORCE_LOGS === '1';
  const usingGlobalLog = !!global._global_npmlog;
  let logger;

  if (testingMode && !forceLogMode) {
    logger = mockLog;
  } else {
    logger = global._global_npmlog || _npmlog.default;
    logger.maxRecordSize = MAX_LOG_RECORDS_COUNT;
  }

  patchLogger(logger);
  return [logger, usingGlobalLog];
}

function getActualPrefix(prefix, logTimestamp = false) {
  var _ref;

  const result = (_ref = _lodash.default.isFunction(prefix) ? prefix() : prefix) !== null && _ref !== void 0 ? _ref : '';
  return logTimestamp ? `[${(0, _moment.default)().format(PREFIX_TIMESTAMP_FORMAT)}] ${result}` : result;
}

function getLogger(prefix = null) {
  let [logger, usingGlobalLog] = _getLogger();

  let wrappedLogger = {
    unwrap: () => logger,
    levels: NPM_LEVELS,
    prefix
  };
  Object.defineProperty(wrappedLogger, 'level', {
    get() {
      return logger.level;
    },

    set(newValue) {
      logger.level = newValue;
    },

    enumerable: true,
    configurable: true
  });
  const logTimestamp = process.env._LOG_TIMESTAMP === '1';

  for (const level of NPM_LEVELS) {
    wrappedLogger[level] = function (...args) {
      const actualPrefix = getActualPrefix(this.prefix, logTimestamp);

      for (const arg of args) {
        const out = _lodash.default.isError(arg) && arg.stack ? arg.stack : `${arg}`;

        for (const line of out.split('\n')) {
          const unleakedLine = (0, _util.unleakString)(line);
          logger[level](actualPrefix, _logInternal.default.preprocess(unleakedLine));
        }
      }
    };
  }

  wrappedLogger.errorAndThrow = function (err) {
    this.error(err);
    throw _lodash.default.isError(err) ? err : new Error((0, _util.unleakString)(err));
  };

  if (!usingGlobalLog) {
    wrappedLogger.level = 'verbose';
  }

  return wrappedLogger;
}

async function loadSecureValuesPreprocessingRules(rulesJsonPath) {
  const issues = await _logInternal.default.loadRules(rulesJsonPath);
  return {
    issues,
    rules: _lodash.default.cloneDeep(_logInternal.default.rules)
  };
}

const log = getLogger();
exports.log = log;
var _default = log;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJOUE1fTEVWRUxTIiwiTUFYX0xPR19SRUNPUkRTX0NPVU5UIiwiUFJFRklYX1RJTUVTVEFNUF9GT1JNQVQiLCJtb2NrTG9nIiwibGV2ZWwiLCJwYXRjaExvZ2dlciIsImxvZ2dlciIsImRlYnVnIiwiYWRkTGV2ZWwiLCJmZyIsImJnIiwiX2dldExvZ2dlciIsInRlc3RpbmdNb2RlIiwicHJvY2VzcyIsImVudiIsIl9URVNUSU5HIiwiZm9yY2VMb2dNb2RlIiwiX0ZPUkNFX0xPR1MiLCJ1c2luZ0dsb2JhbExvZyIsImdsb2JhbCIsIl9nbG9iYWxfbnBtbG9nIiwibnBtbG9nIiwibWF4UmVjb3JkU2l6ZSIsImdldEFjdHVhbFByZWZpeCIsInByZWZpeCIsImxvZ1RpbWVzdGFtcCIsInJlc3VsdCIsIl8iLCJpc0Z1bmN0aW9uIiwiZm9ybWF0IiwiZ2V0TG9nZ2VyIiwid3JhcHBlZExvZ2dlciIsInVud3JhcCIsImxldmVscyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic2V0IiwibmV3VmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiX0xPR19USU1FU1RBTVAiLCJhcmdzIiwiYWN0dWFsUHJlZml4IiwiYXJnIiwib3V0IiwiaXNFcnJvciIsInN0YWNrIiwibGluZSIsInNwbGl0IiwidW5sZWFrZWRMaW5lIiwiU0VDVVJFX1ZBTFVFU19QUkVQUk9DRVNTT1IiLCJwcmVwcm9jZXNzIiwiZXJyb3JBbmRUaHJvdyIsImVyciIsImVycm9yIiwiRXJyb3IiLCJsb2FkU2VjdXJlVmFsdWVzUHJlcHJvY2Vzc2luZ1J1bGVzIiwicnVsZXNKc29uUGF0aCIsImlzc3VlcyIsImxvYWRSdWxlcyIsInJ1bGVzIiwiY2xvbmVEZWVwIiwibG9nIl0sInNvdXJjZXMiOlsiLi4vLi4vbGliL2xvZ2dpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5wbWxvZyBmcm9tICducG1sb2cnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHVubGVha1N0cmluZyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgU0VDVVJFX1ZBTFVFU19QUkVQUk9DRVNTT1IgZnJvbSAnLi9sb2ctaW50ZXJuYWwnO1xuXG4vLyBsZXZlbHMgdGhhdCBhcmUgYXZhaWxhYmxlIGZyb20gYG5wbWxvZ2BcbmNvbnN0IE5QTV9MRVZFTFMgPSBbJ3NpbGx5JywgJ3ZlcmJvc2UnLCAnZGVidWcnLCAnaW5mbycsICdodHRwJywgJ3dhcm4nLCAnZXJyb3InXTtcbmNvbnN0IE1BWF9MT0dfUkVDT1JEU19DT1VOVCA9IDMwMDA7XG5cbmNvbnN0IFBSRUZJWF9USU1FU1RBTVBfRk9STUFUID0gJ0hILW1tLXNzOlNTUyc7XG5cbi8vIG1vY2sgbG9nIG9iamVjdCB1c2VkIGluIHRlc3RpbmcgbW9kZVxubGV0IG1vY2tMb2cgPSB7fTtcbmZvciAobGV0IGxldmVsIG9mIE5QTV9MRVZFTFMpIHtcbiAgbW9ja0xvZ1tsZXZlbF0gPSAoKSA9PiB7fTtcbn1cblxuZnVuY3Rpb24gcGF0Y2hMb2dnZXIgKGxvZ2dlcikge1xuICBpZiAoIWxvZ2dlci5kZWJ1Zykge1xuICAgIGxvZ2dlci5hZGRMZXZlbCgnZGVidWcnLCAxMDAwLCB7IGZnOiAnYmx1ZScsIGJnOiAnYmxhY2snIH0sICdkYnVnJyk7XG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHJldHVybnMge1tucG1sb2cuTG9nZ2VyLCBib29sZWFuXX1cbiAqL1xuZnVuY3Rpb24gX2dldExvZ2dlciAoKSB7XG4gIC8vIGNoZWNrIGlmIHRoZSB1c2VyIHNldCB0aGUgYF9URVNUSU5HYCBvciBgX0ZPUkNFX0xPR1NgIGZsYWdcbiAgY29uc3QgdGVzdGluZ01vZGUgPSBwcm9jZXNzLmVudi5fVEVTVElORyA9PT0gJzEnO1xuICBjb25zdCBmb3JjZUxvZ01vZGUgPSBwcm9jZXNzLmVudi5fRk9SQ0VfTE9HUyA9PT0gJzEnO1xuXG4gIC8vIGlmIGlzIHBvc3NpYmxlIHRoYXQgdGhlcmUgaXMgYSBsb2dnZXIgaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5IGFyb3VuZCxcbiAgLy8gaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHQgbyB1c2UgdGhhdFxuICBjb25zdCB1c2luZ0dsb2JhbExvZyA9ICEhZ2xvYmFsLl9nbG9iYWxfbnBtbG9nO1xuICBsZXQgbG9nZ2VyO1xuICBpZiAodGVzdGluZ01vZGUgJiYgIWZvcmNlTG9nTW9kZSkge1xuICAgIC8vIGluIHRlc3RpbmcgbW9kZSwgdXNlIGEgbW9jayBsb2dnZXIgb2JqZWN0IHRoYXQgd2UgY2FuIHF1ZXJ5XG4gICAgbG9nZ2VyID0gbW9ja0xvZztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIGVpdGhlciB1c2UgdGhlIGdsb2JhbCwgb3IgYSBuZXcgYG5wbWxvZ2Agb2JqZWN0XG4gICAgbG9nZ2VyID0gZ2xvYmFsLl9nbG9iYWxfbnBtbG9nIHx8IG5wbWxvZztcbiAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxMDAwMCwgd2hpY2ggY2F1c2VzIGV4Y2Vzc2l2ZSBtZW1vcnkgdXNhZ2VcbiAgICBsb2dnZXIubWF4UmVjb3JkU2l6ZSA9IE1BWF9MT0dfUkVDT1JEU19DT1VOVDtcbiAgfVxuICBwYXRjaExvZ2dlcihsb2dnZXIpO1xuICByZXR1cm4gW2xvZ2dlciwgdXNpbmdHbG9iYWxMb2ddO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UHJlZml4P30gcHJlZml4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvZ1RpbWVzdGFtcCB3aGV0aGVyIHRvIGluY2x1ZGUgdGltZXN0YW1wcyBpbnRvIGxvZyBwcmVmaXhlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0dWFsUHJlZml4IChwcmVmaXgsIGxvZ1RpbWVzdGFtcCA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IChfLmlzRnVuY3Rpb24ocHJlZml4KSA/IHByZWZpeCgpIDogcHJlZml4KSA/PyAnJztcbiAgcmV0dXJuIGxvZ1RpbWVzdGFtcFxuICAgID8gYFske21vbWVudCgpLmZvcm1hdChQUkVGSVhfVElNRVNUQU1QX0ZPUk1BVCl9XSAke3Jlc3VsdH1gXG4gICAgOiByZXN1bHQ7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7UHJlZml4P30gcHJlZml4XG4gKiBAcmV0dXJucyB7QXBwaXVtTG9nZ2VyfVxuICovXG5mdW5jdGlvbiBnZXRMb2dnZXIgKHByZWZpeCA9IG51bGwpIHtcbiAgbGV0IFtsb2dnZXIsIHVzaW5nR2xvYmFsTG9nXSA9IF9nZXRMb2dnZXIoKTtcblxuICAvLyB3cmFwIHRoZSBsb2dnZXIgc28gdGhhdCB3ZSBjYW4gY2F0Y2ggYW5kIG1vZGlmeSBhbnkgbG9nZ2luZ1xuICBsZXQgd3JhcHBlZExvZ2dlciA9IHtcbiAgICB1bndyYXA6ICgpID0+IGxvZ2dlcixcbiAgICBsZXZlbHM6IE5QTV9MRVZFTFMsXG4gICAgcHJlZml4LFxuICB9O1xuXG4gIC8vIGFsbG93IGFjY2VzcyB0byB0aGUgbGV2ZWwgb2YgdGhlIHVuZGVybHlpbmcgbG9nZ2VyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVkTG9nZ2VyLCAnbGV2ZWwnLCB7XG4gICAgZ2V0ICgpIHtcbiAgICAgIHJldHVybiBsb2dnZXIubGV2ZWw7XG4gICAgfSxcbiAgICBzZXQgKG5ld1ZhbHVlKSB7XG4gICAgICBsb2dnZXIubGV2ZWwgPSBuZXdWYWx1ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIGNvbnN0IGxvZ1RpbWVzdGFtcCA9IHByb2Nlc3MuZW52Ll9MT0dfVElNRVNUQU1QID09PSAnMSc7XG5cbiAgLy8gYWRkIGFsbCB0aGUgbGV2ZWxzIGZyb20gYG5wbWxvZ2AsIGFuZCBtYXAgdG8gdGhlIHVuZGVybHlpbmcgbG9nZ2VyXG4gIGZvciAoY29uc3QgbGV2ZWwgb2YgTlBNX0xFVkVMUykge1xuICAgIHdyYXBwZWRMb2dnZXJbbGV2ZWxdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGFjdHVhbFByZWZpeCA9IGdldEFjdHVhbFByZWZpeCh0aGlzLnByZWZpeCwgbG9nVGltZXN0YW1wKTtcbiAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gKF8uaXNFcnJvcihhcmcpICYmIGFyZy5zdGFjaykgPyBhcmcuc3RhY2sgOiBgJHthcmd9YDtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIG91dC5zcGxpdCgnXFxuJykpIHtcbiAgICAgICAgICAvLyBpdCBpcyBuZWNlc3NhcnkgdG8gdW5sZWFrIGVhY2ggbGluZSBiZWNhdXNlIGBzcGxpdGAgY2FsbFxuICAgICAgICAgIC8vIGNyZWF0ZXMgXCJ2aWV3c1wiIHRvIHRoZSBvcmlnaW5hbCBzdHJpbmcgYXMgd2VsbCBhcyB0aGUgYHN1YnN0cmluZ2Agb25lXG4gICAgICAgICAgY29uc3QgdW5sZWFrZWRMaW5lID0gdW5sZWFrU3RyaW5nKGxpbmUpO1xuICAgICAgICAgIGxvZ2dlcltsZXZlbF0oYWN0dWFsUHJlZml4LCBTRUNVUkVfVkFMVUVTX1BSRVBST0NFU1NPUi5wcmVwcm9jZXNzKHVubGVha2VkTGluZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvLyBhZGQgbWV0aG9kIHRvIGxvZyBhbiBlcnJvciwgYW5kIHRocm93IGl0LCBmb3IgY29udmVuaWVuY2VcbiAgd3JhcHBlZExvZ2dlci5lcnJvckFuZFRocm93ID0gZnVuY3Rpb24gKGVycikge1xuICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhbiBgRXJyb3JgIG9iamVjdC4gV3JhcCBpZiBuZWNlc3NhcnlcbiAgICB0aHJvdyAoXy5pc0Vycm9yKGVycikgPyBlcnIgOiBuZXcgRXJyb3IodW5sZWFrU3RyaW5nKGVycikpKTtcbiAgfTtcbiAgaWYgKCF1c2luZ0dsb2JhbExvZykge1xuICAgIC8vIGlmIHdlJ3JlIG5vdCB1c2luZyBhIGdsb2JhbCBsb2cgc3BlY2lmaWVkIGZyb20gc29tZSB0b3AtbGV2ZWwgcGFja2FnZSxcbiAgICAvLyBzZXQgdGhlIGxvZyBsZXZlbCB0byBhIGRlZmF1bHQgb2YgdmVyYm9zZS4gT3RoZXJ3aXNlLCBsZXQgdGhlIHRvcC1sZXZlbFxuICAgIC8vIHBhY2thZ2Ugc2V0IHRoZSBsb2cgbGV2ZWxcbiAgICB3cmFwcGVkTG9nZ2VyLmxldmVsID0gJ3ZlcmJvc2UnO1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge0FwcGl1bUxvZ2dlcn0gKi8od3JhcHBlZExvZ2dlcik7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgTG9hZFJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gaXNzdWVzIFRoZSBsaXN0IG9mIHJ1bGUgcGFyc2luZyBpc3N1ZXMgKG9uZSBpdGVtIHBlciBydWxlKS5cbiAqIFJ1bGVzIHdpdGggaXNzdWVzIGFyZSBza2lwcGVkLiBBbiBlbXB0eSBsaXN0IGlzIHJldHVybmVkIGlmIG5vIHBhcnNpbmcgaXNzdWVzIGV4aXN0LlxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4vbG9nLWludGVybmFsJykuU2VjdXJlVmFsdWVQcmVwcm9jZXNzaW5nUnVsZVtdfSBydWxlcyBUaGUgbGlzdCBvZiBzdWNjZXNzZnVsbHkgbG9hZGVkXG4gKiByZXBsYWNlbWVudCBydWxlcy4gVGhlIGxpc3QgY291bGQgYmUgZW1wdHkgaWYgbm8gcnVsZXMgd2VyZSBsb2FkZWQuXG4gKi9cblxuLyoqXG4gKiBMb2FkcyB0aGUgSlNPTiBmaWxlIGNvbnRhaW5pbmcgc2VjdXJlIHZhbHVlcyByZXBsYWNlbWVudCBydWxlcy5cbiAqIFRoaXMgbWlnaHQgYmUgbmVjZXNzYXJ5IHRvIGhpZGUgc2Vuc2l0aXZlIHZhbHVlcyB0aGF0IG1heSBwb3NzaWJseVxuICogYXBwZWFyIGluIEFwcGl1bSBsb2dzLlxuICogRWFjaCBjYWxsIHRvIHRoaXMgbWV0aG9kIHJlcGxhY2VzIHRoZSBwcmV2aW91c2x5IGxvYWRlZCBydWxlcyBpZiBhbnkgZXhpc3RlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXxpbXBvcnQoJy4vbG9nLWludGVybmFsJykuUnVsZVtdfSBydWxlc0pzb25QYXRoIFRoZSBmdWxsIHBhdGggdG8gdGhlIEpTT04gZmlsZSBjb250YWluaW5nXG4gKiB0aGUgcmVwbGFjZW1lbnQgcnVsZXMuIEVhY2ggcnVsZSBjb3VsZCBlaXRoZXIgYmUgYSBzdHJpbmcgdG8gYmUgcmVwbGFjZWRcbiAqIG9yIGFuIG9iamVjdCB3aXRoIHByZWRlZmluZWQgcHJvcGVydGllcy4gU2VlIHRoZSBgUnVsZWAgdHlwZSBkZWZpbml0aW9uIGluXG4gKiBgbG9nLWludGVybmFscy5qc2AgdG8gZ2V0IG1vcmUgZGV0YWlscyBvbiBpdHMgZm9ybWF0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBnaXZlbiBmaWxlIGNhbm5vdCBiZSBsb2FkZWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPExvYWRSZXN1bHQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkU2VjdXJlVmFsdWVzUHJlcHJvY2Vzc2luZ1J1bGVzIChydWxlc0pzb25QYXRoKSB7XG4gIGNvbnN0IGlzc3VlcyA9IGF3YWl0IFNFQ1VSRV9WQUxVRVNfUFJFUFJPQ0VTU09SLmxvYWRSdWxlcyhydWxlc0pzb25QYXRoKTtcbiAgcmV0dXJuIHtcbiAgICBpc3N1ZXMsXG4gICAgcnVsZXM6IF8uY2xvbmVEZWVwKFNFQ1VSRV9WQUxVRVNfUFJFUFJPQ0VTU09SLnJ1bGVzKSxcbiAgfTtcbn1cblxuLy8gZXhwb3J0IGEgZGVmYXVsdCBsb2dnZXIgd2l0aCBubyBwcmVmaXhcbmNvbnN0IGxvZyA9IGdldExvZ2dlcigpO1xuXG5leHBvcnQgeyBsb2csIHBhdGNoTG9nZ2VyLCBnZXRMb2dnZXIsIGxvYWRTZWN1cmVWYWx1ZXNQcmVwcm9jZXNzaW5nUnVsZXMgfTtcbmV4cG9ydCBkZWZhdWx0IGxvZztcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdAYXBwaXVtL3R5cGVzJykuUHJlZml4fSBQcmVmaXhcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ0BhcHBpdW0vdHlwZXMnKS5BcHBpdW1Mb2dnZXJ9IEFwcGl1bUxvZ2dlclxuICovXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLE1BQU1BLFVBQVUsR0FBRyxDQUFDLE9BQUQsRUFBVSxTQUFWLEVBQXFCLE9BQXJCLEVBQThCLE1BQTlCLEVBQXNDLE1BQXRDLEVBQThDLE1BQTlDLEVBQXNELE9BQXRELENBQW5CO0FBQ0EsTUFBTUMscUJBQXFCLEdBQUcsSUFBOUI7QUFFQSxNQUFNQyx1QkFBdUIsR0FBRyxjQUFoQztBQUdBLElBQUlDLE9BQU8sR0FBRyxFQUFkOztBQUNBLEtBQUssSUFBSUMsS0FBVCxJQUFrQkosVUFBbEIsRUFBOEI7RUFDNUJHLE9BQU8sQ0FBQ0MsS0FBRCxDQUFQLEdBQWlCLE1BQU0sQ0FBRSxDQUF6QjtBQUNEOztBQUVELFNBQVNDLFdBQVQsQ0FBc0JDLE1BQXRCLEVBQThCO0VBQzVCLElBQUksQ0FBQ0EsTUFBTSxDQUFDQyxLQUFaLEVBQW1CO0lBQ2pCRCxNQUFNLENBQUNFLFFBQVAsQ0FBZ0IsT0FBaEIsRUFBeUIsSUFBekIsRUFBK0I7TUFBRUMsRUFBRSxFQUFFLE1BQU47TUFBY0MsRUFBRSxFQUFFO0lBQWxCLENBQS9CLEVBQTRELE1BQTVEO0VBQ0Q7QUFDRjs7QUFNRCxTQUFTQyxVQUFULEdBQXVCO0VBRXJCLE1BQU1DLFdBQVcsR0FBR0MsT0FBTyxDQUFDQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsR0FBN0M7RUFDQSxNQUFNQyxZQUFZLEdBQUdILE9BQU8sQ0FBQ0MsR0FBUixDQUFZRyxXQUFaLEtBQTRCLEdBQWpEO0VBSUEsTUFBTUMsY0FBYyxHQUFHLENBQUMsQ0FBQ0MsTUFBTSxDQUFDQyxjQUFoQztFQUNBLElBQUlkLE1BQUo7O0VBQ0EsSUFBSU0sV0FBVyxJQUFJLENBQUNJLFlBQXBCLEVBQWtDO0lBRWhDVixNQUFNLEdBQUdILE9BQVQ7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