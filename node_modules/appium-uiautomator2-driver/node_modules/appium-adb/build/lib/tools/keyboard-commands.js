"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _logger = _interopRequireDefault(require("../logger.js"));

var _asyncbox = require("asyncbox");

const KEYCODE_ESC = 111;
const KEYCODE_BACK = 4;
const keyboardCommands = {};

keyboardCommands.hideKeyboard = async function hideKeyboard(timeoutMs = 1000) {
  let {
    isKeyboardShown,
    canCloseKeyboard
  } = await this.isSoftKeyboardPresent();

  if (!isKeyboardShown) {
    _logger.default.info('Keyboard has no UI; no closing necessary');

    return false;
  }

  for (const keyCode of [KEYCODE_ESC, KEYCODE_BACK]) {
    if (canCloseKeyboard) {
      await this.keyevent(keyCode);
    }

    try {
      return await (0, _asyncbox.waitForCondition)(async () => {
        ({
          isKeyboardShown
        } = await this.isSoftKeyboardPresent());
        return !isKeyboardShown;
      }, {
        waitMs: timeoutMs,
        intervalMs: 500
      });
    } catch (ign) {}
  }

  throw new Error(`The software keyboard cannot be hidden`);
};

keyboardCommands.isSoftKeyboardPresent = async function isSoftKeyboardPresent() {
  try {
    const stdout = await this.shell(['dumpsys', 'input_method']);
    const inputShownMatch = /mInputShown=(\w+)/.exec(stdout);
    const inputViewShownMatch = /mIsInputViewShown=(\w+)/.exec(stdout);
    return {
      isKeyboardShown: !!(inputShownMatch && inputShownMatch[1] === 'true'),
      canCloseKeyboard: !!(inputViewShownMatch && inputViewShownMatch[1] === 'true')
    };
  } catch (e) {
    throw new Error(`Error finding softkeyboard. Original error: ${e.message}`);
  }
};

var _default = keyboardCommands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL3Rvb2xzL2tleWJvYXJkLWNvbW1hbmRzLmpzIiwibmFtZXMiOlsiS0VZQ09ERV9FU0MiLCJLRVlDT0RFX0JBQ0siLCJrZXlib2FyZENvbW1hbmRzIiwiaGlkZUtleWJvYXJkIiwidGltZW91dE1zIiwiaXNLZXlib2FyZFNob3duIiwiY2FuQ2xvc2VLZXlib2FyZCIsImlzU29mdEtleWJvYXJkUHJlc2VudCIsImxvZyIsImluZm8iLCJrZXlDb2RlIiwia2V5ZXZlbnQiLCJ3YWl0Rm9yQ29uZGl0aW9uIiwid2FpdE1zIiwiaW50ZXJ2YWxNcyIsImlnbiIsIkVycm9yIiwic3Rkb3V0Iiwic2hlbGwiLCJpbnB1dFNob3duTWF0Y2giLCJleGVjIiwiaW5wdXRWaWV3U2hvd25NYXRjaCIsImUiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLiIsInNvdXJjZXMiOlsibGliL3Rvb2xzL2tleWJvYXJkLWNvbW1hbmRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyLmpzJztcbmltcG9ydCB7IHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5cbmNvbnN0IEtFWUNPREVfRVNDID0gMTExO1xuY29uc3QgS0VZQ09ERV9CQUNLID0gNDtcblxuY29uc3Qga2V5Ym9hcmRDb21tYW5kcyA9IHt9O1xuXG4vKipcbiAqIEhpZGVzIHNvZnR3YXJlIGtleWJvYXJkIGlmIGl0IGlzIHZpc2libGUuXG4gKiBOb29wIGlmIHRoZSBrZXlib2FyZCBpcyBhbHJlYWR5IGhpZGRlbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIFsxMDAwXSBGb3IgaG93IGxvbmcgdG8gd2FpdCAoaW4gbWlsbGlzZWNvbmRzKVxuICogdW50aWwgdGhlIGtleWJvYXJkIGlzIGFjdHVhbGx5IGhpZGRlbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgZmFsc2VgIGlmIHRoZSBrZXlib2FyZCB3YXMgYWxyZWFkeSBoaWRkZW5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUga2V5Ym9hcmQgY2Fubm90IGJlIGhpZGRlbi5cbiAqL1xua2V5Ym9hcmRDb21tYW5kcy5oaWRlS2V5Ym9hcmQgPSBhc3luYyBmdW5jdGlvbiBoaWRlS2V5Ym9hcmQgKHRpbWVvdXRNcyA9IDEwMDApIHtcbiAgbGV0IHtpc0tleWJvYXJkU2hvd24sIGNhbkNsb3NlS2V5Ym9hcmR9ID0gYXdhaXQgdGhpcy5pc1NvZnRLZXlib2FyZFByZXNlbnQoKTtcbiAgaWYgKCFpc0tleWJvYXJkU2hvd24pIHtcbiAgICBsb2cuaW5mbygnS2V5Ym9hcmQgaGFzIG5vIFVJOyBubyBjbG9zaW5nIG5lY2Vzc2FyeScpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUcnkgRVNDIHRoZW4gQkFDSyBpZiB0aGUgZmlyc3Qgb25lIGZhaWxzXG4gIGZvciAoY29uc3Qga2V5Q29kZSBvZiBbS0VZQ09ERV9FU0MsIEtFWUNPREVfQkFDS10pIHtcbiAgICBpZiAoY2FuQ2xvc2VLZXlib2FyZCkge1xuICAgICAgYXdhaXQgdGhpcy5rZXlldmVudChrZXlDb2RlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgKHtpc0tleWJvYXJkU2hvd259ID0gYXdhaXQgdGhpcy5pc1NvZnRLZXlib2FyZFByZXNlbnQoKSk7XG4gICAgICAgIHJldHVybiAhaXNLZXlib2FyZFNob3duO1xuICAgICAgfSwge3dhaXRNczogdGltZW91dE1zLCBpbnRlcnZhbE1zOiA1MDB9KTtcbiAgICB9IGNhdGNoIChpZ24pIHt9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc29mdHdhcmUga2V5Ym9hcmQgY2Fubm90IGJlIGhpZGRlbmApO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBLZXlib2FyZFN0YXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzS2V5Ym9hcmRTaG93biAtIFdoZXRoZXIgc29mdCBrZXlib2FyZCBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FuQ2xvc2VLZXlib2FyZCAtIFdoZXRoZXIgdGhlIGtleWJvYXJkIGNhbiBiZSBjbG9zZWQuXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgc3RhdGUgb2YgdGhlIHNvZnR3YXJlIGtleWJvYXJkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtLZXlib2FyZFN0YXRlfSBUaGUga2V5Ym9hcmQgc3RhdGUuXG4gKi9cbmtleWJvYXJkQ29tbWFuZHMuaXNTb2Z0S2V5Ym9hcmRQcmVzZW50ID0gYXN5bmMgZnVuY3Rpb24gaXNTb2Z0S2V5Ym9hcmRQcmVzZW50ICgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnZHVtcHN5cycsICdpbnB1dF9tZXRob2QnXSk7XG4gICAgY29uc3QgaW5wdXRTaG93bk1hdGNoID0gL21JbnB1dFNob3duPShcXHcrKS8uZXhlYyhzdGRvdXQpO1xuICAgIGNvbnN0IGlucHV0Vmlld1Nob3duTWF0Y2ggPSAvbUlzSW5wdXRWaWV3U2hvd249KFxcdyspLy5leGVjKHN0ZG91dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzS2V5Ym9hcmRTaG93bjogISEoaW5wdXRTaG93bk1hdGNoICYmIGlucHV0U2hvd25NYXRjaFsxXSA9PT0gJ3RydWUnKSxcbiAgICAgIGNhbkNsb3NlS2V5Ym9hcmQ6ICEhKGlucHV0Vmlld1Nob3duTWF0Y2ggJiYgaW5wdXRWaWV3U2hvd25NYXRjaFsxXSA9PT0gJ3RydWUnKSxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmaW5kaW5nIHNvZnRrZXlib2FyZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBrZXlib2FyZENvbW1hbmRzO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUVBLE1BQU1BLFdBQVcsR0FBRyxHQUFwQjtBQUNBLE1BQU1DLFlBQVksR0FBRyxDQUFyQjtBQUVBLE1BQU1DLGdCQUFnQixHQUFHLEVBQXpCOztBQVdBQSxnQkFBZ0IsQ0FBQ0MsWUFBakIsR0FBZ0MsZUFBZUEsWUFBZixDQUE2QkMsU0FBUyxHQUFHLElBQXpDLEVBQStDO0VBQzdFLElBQUk7SUFBQ0MsZUFBRDtJQUFrQkM7RUFBbEIsSUFBc0MsTUFBTSxLQUFLQyxxQkFBTCxFQUFoRDs7RUFDQSxJQUFJLENBQUNGLGVBQUwsRUFBc0I7SUFDcEJHLGVBQUEsQ0FBSUMsSUFBSixDQUFTLDBDQUFUOztJQUNBLE9BQU8sS0FBUDtFQUNEOztFQUVELEtBQUssTUFBTUMsT0FBWCxJQUFzQixDQUFDVixXQUFELEVBQWNDLFlBQWQsQ0FBdEIsRUFBbUQ7SUFDakQsSUFBSUssZ0JBQUosRUFBc0I7TUFDcEIsTUFBTSxLQUFLSyxRQUFMLENBQWNELE9BQWQsQ0FBTjtJQUNEOztJQUNELElBQUk7TUFDRixPQUFPLE1BQU0sSUFBQUUsMEJBQUEsRUFBaUIsWUFBWTtRQUN4QyxDQUFDO1VBQUNQO1FBQUQsSUFBb0IsTUFBTSxLQUFLRSxxQkFBTCxFQUEzQjtRQUNBLE9BQU8sQ0FBQ0YsZUFBUjtNQUNELENBSFksRUFHVjtRQUFDUSxNQUFNLEVBQUVULFNBQVQ7UUFBb0JVLFVBQVUsRUFBRTtNQUFoQyxDQUhVLENBQWI7SUFJRCxDQUxELENBS0UsT0FBT0MsR0FBUCxFQUFZLENBQUU7RUFDakI7O0VBQ0QsTUFBTSxJQUFJQyxLQUFKLENBQVcsd0NBQVgsQ0FBTjtBQUNELENBbkJEOztBQWdDQWQsZ0JBQWdCLENBQUNLLHFCQUFqQixHQUF5QyxlQUFlQSxxQkFBZixHQUF3QztFQUMvRSxJQUFJO0lBQ0YsTUFBTVUsTUFBTSxHQUFHLE1BQU0sS0FBS0MsS0FBTCxDQUFXLENBQUMsU0FBRCxFQUFZLGNBQVosQ0FBWCxDQUFyQjtJQUNBLE1BQU1DLGVBQWUsR0FBRyxvQkFBb0JDLElBQXBCLENBQXlCSCxNQUF6QixDQUF4QjtJQUNBLE1BQU1JLG1CQUFtQixHQUFHLDBCQUEwQkQsSUFBMUIsQ0FBK0JILE1BQS9CLENBQTVCO0lBQ0EsT0FBTztNQUNMWixlQUFlLEVBQUUsQ0FBQyxFQUFFYyxlQUFlLElBQUlBLGVBQWUsQ0FBQyxDQUFELENBQWYsS0FBdUIsTUFBNUMsQ0FEYjtNQUVMYixnQkFBZ0IsRUFBRSxDQUFDLEVBQUVlLG1CQUFtQixJQUFJQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CLEtBQTJCLE1BQXBEO0lBRmQsQ0FBUDtFQUlELENBUkQsQ0FRRSxPQUFPQyxDQUFQLEVBQVU7SUFDVixNQUFNLElBQUlOLEtBQUosQ0FBVywrQ0FBOENNLENBQUMsQ0FBQ0MsT0FBUSxFQUFuRSxDQUFOO0VBQ0Q7QUFDRixDQVpEOztlQWNlckIsZ0IifQ==
