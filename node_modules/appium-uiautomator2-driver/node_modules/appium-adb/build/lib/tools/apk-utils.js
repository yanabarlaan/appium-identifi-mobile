"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.REMOTE_CACHE_ROOT = void 0;

require("source-map-support/register");

var _helpers = require("../helpers.js");

var _teen_process = require("teen_process");

var _logger = _interopRequireDefault(require("../logger.js"));

var _path = _interopRequireDefault(require("path"));

var _lodash = _interopRequireDefault(require("lodash"));

var _asyncbox = require("asyncbox");

var _support = require("@appium/support");

var _semver = _interopRequireDefault(require("semver"));

var _os = _interopRequireDefault(require("os"));

var _lruCache = _interopRequireDefault(require("lru-cache"));

var _adbkitApkreader = _interopRequireDefault(require("adbkit-apkreader"));

const apkUtilsMethods = {};
const ACTIVITIES_TROUBLESHOOTING_LINK = 'https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/android/activity-startup.md';
apkUtilsMethods.APP_INSTALL_STATE = {
  UNKNOWN: 'unknown',
  NOT_INSTALLED: 'notInstalled',
  NEWER_VERSION_INSTALLED: 'newerVersionInstalled',
  SAME_VERSION_INSTALLED: 'sameVersionInstalled',
  OLDER_VERSION_INSTALLED: 'olderVersionInstalled'
};
const REMOTE_CACHE_ROOT = '/data/local/tmp/appium_cache';
exports.REMOTE_CACHE_ROOT = REMOTE_CACHE_ROOT;

apkUtilsMethods.isAppInstalled = async function isAppInstalled(pkg) {
  _logger.default.debug(`Getting install status for ${pkg}`);

  const installedPattern = new RegExp(`^\\s*Package\\s+\\[${_lodash.default.escapeRegExp(pkg)}\\][^:]+:$`, 'm');

  try {
    const stdout = await this.shell(['dumpsys', 'package', pkg]);
    const isInstalled = installedPattern.test(stdout);

    _logger.default.debug(`'${pkg}' is${!isInstalled ? ' not' : ''} installed`);

    return isInstalled;
  } catch (e) {
    throw new Error(`Error finding if '${pkg}' is installed. Original error: ${e.message}`);
  }
};

apkUtilsMethods.startUri = async function startUri(uri, pkg, opts = {}) {
  const {
    waitForLaunch = true
  } = opts;

  if (!uri || !pkg) {
    throw new Error('URI and package arguments are required');
  }

  const args = ['am', 'start'];

  if (waitForLaunch) {
    args.push('-W');
  }

  args.push('-a', 'android.intent.action.VIEW', '-d', (0, _helpers.escapeShellArg)(uri), pkg);

  try {
    const res = await this.shell(args);

    if (res.toLowerCase().includes('unable to resolve intent')) {
      throw new Error(res);
    }
  } catch (e) {
    throw new Error(`Error attempting to start URI. Original error: ${e}`);
  }
};

apkUtilsMethods.startApp = async function startApp(startAppOptions = {}) {
  if (!startAppOptions.pkg || !(startAppOptions.activity || startAppOptions.action)) {
    throw new Error('pkg, and activity or intent action, are required to start an application');
  }

  startAppOptions = _lodash.default.clone(startAppOptions);

  if (startAppOptions.activity) {
    startAppOptions.activity = startAppOptions.activity.replace('$', '\\$');
  }

  _lodash.default.defaults(startAppOptions, {
    waitPkg: startAppOptions.pkg,
    waitForLaunch: true,
    waitActivity: false,
    retry: true,
    stopApp: true
  });

  startAppOptions.waitPkg = startAppOptions.waitPkg || startAppOptions.pkg;
  const apiLevel = await this.getApiLevel();
  const cmd = (0, _helpers.buildStartCmd)(startAppOptions, apiLevel);
  const intentName = `${startAppOptions.action}${startAppOptions.optionalIntentArguments ? ' ' + startAppOptions.optionalIntentArguments : ''}`;

  try {
    const shellOpts = {};

    if (_lodash.default.isInteger(startAppOptions.waitDuration) && startAppOptions.waitDuration >= 0) {
      shellOpts.timeout = startAppOptions.waitDuration;
    }

    const stdout = await this.shell(cmd, shellOpts);

    if (stdout.includes('Error: Activity class') && stdout.includes('does not exist')) {
      if (startAppOptions.retry && !startAppOptions.activity.startsWith('.')) {
        _logger.default.debug(`We tried to start an activity that doesn't exist, ` + `retrying with '.${startAppOptions.activity}' activity name`);

        startAppOptions.activity = `.${startAppOptions.activity}`;
        startAppOptions.retry = false;
        return await this.startApp(startAppOptions);
      }

      throw new Error(`Activity name '${startAppOptions.activity}' used to start the app doesn't ` + `exist or cannot be launched! Make sure it exists and is a launchable activity`);
    } else if (stdout.includes('Error: Intent does not match any activities') || stdout.includes('Error: Activity not started, unable to resolve Intent')) {
      throw new Error(`Activity for intent '${intentName}' used to start the app doesn't ` + `exist or cannot be launched! Make sure it exists and is a launchable activity`);
    } else if (stdout.includes('java.lang.SecurityException')) {
      throw new Error(`The permission to start '${startAppOptions.activity}' activity has been denied.` + `Make sure the activity/package names are correct.`);
    }

    if (startAppOptions.waitActivity) {
      await this.waitForActivity(startAppOptions.waitPkg, startAppOptions.waitActivity, startAppOptions.waitDuration);
    }

    return stdout;
  } catch (e) {
    const appDescriptor = startAppOptions.pkg || intentName;
    throw new Error(`Cannot start the '${appDescriptor}' application. ` + `Visit ${ACTIVITIES_TROUBLESHOOTING_LINK} for troubleshooting. ` + `Original error: ${e.message}`);
  }
};

apkUtilsMethods.dumpWindows = async function dumpWindows() {
  const apiLevel = await this.getApiLevel();
  const dumpsysArg = apiLevel >= 29 ? 'displays' : 'windows';
  const cmd = ['dumpsys', 'window', dumpsysArg];
  return await this.shell(cmd);
};

apkUtilsMethods.getFocusedPackageAndActivity = async function getFocusedPackageAndActivity() {
  _logger.default.debug('Getting focused package and activity');

  const nullFocusedAppRe = new RegExp(/^\s*mFocusedApp=null/, 'm');
  const focusedAppRe = new RegExp('^\\s*mFocusedApp.+Record\\{.*\\s([^\\s\\/\\}]+)' + '\\/([^\\s\\/\\}\\,]+)\\,?(\\s[^\\s\\/\\}]+)*\\}', 'm');
  const nullCurrentFocusRe = new RegExp(/^\s*mCurrentFocus=null/, 'm');
  const currentFocusAppRe = new RegExp('^\\s*mCurrentFocus.+\\{.+\\s([^\\s\\/]+)\\/([^\\s]+)\\b', 'm');

  try {
    const stdout = await this.dumpWindows();

    for (const pattern of [focusedAppRe, currentFocusAppRe]) {
      const match = pattern.exec(stdout);

      if (match) {
        return {
          appPackage: match[1].trim(),
          appActivity: match[2].trim()
        };
      }
    }

    for (const pattern of [nullFocusedAppRe, nullCurrentFocusRe]) {
      if (pattern.exec(stdout)) {
        return {
          appPackage: null,
          appActivity: null
        };
      }
    }

    throw new Error('Could not parse activity from dumpsys');
  } catch (e) {
    throw new Error(`Could not get focusPackageAndActivity. Original error: ${e.message}`);
  }
};

apkUtilsMethods.waitForActivityOrNot = async function waitForActivityOrNot(pkg, activity, waitForStop, waitMs = 20000) {
  if (!pkg || !activity) {
    throw new Error('Package and activity required.');
  }

  _logger.default.debug(`Waiting up to ${waitMs}ms for activity matching pkg: '${pkg}' and ` + `activity: '${activity}' to${waitForStop ? ' not' : ''} be focused`);

  const splitNames = names => names.split(',').map(name => name.trim());

  const allPackages = splitNames(pkg);
  const allActivities = splitNames(activity);
  const possibleActivityNames = [];

  for (const oneActivity of allActivities) {
    if (oneActivity.startsWith('.')) {
      for (const currentPkg of allPackages) {
        possibleActivityNames.push(`${currentPkg}${oneActivity}`.replace(/\.+/g, '.'));
      }
    } else {
      possibleActivityNames.push(oneActivity);
      possibleActivityNames.push(`${pkg}.${oneActivity}`);
    }
  }

  _logger.default.debug(`Possible activities, to be checked: ${possibleActivityNames.map(name => `'${name}'`).join(', ')}`);

  const possibleActivityPatterns = possibleActivityNames.map(actName => new RegExp(`^${actName.replace(/\./g, '\\.').replace(/\*/g, '.*?').replace(/\$/g, '\\$')}$`));

  const conditionFunc = async () => {
    let appPackage;
    let appActivity;

    try {
      ({
        appPackage,
        appActivity
      } = await this.getFocusedPackageAndActivity());
    } catch (e) {
      _logger.default.debug(e.message);

      return false;
    }

    if (appActivity && appPackage) {
      const fullyQualifiedActivity = appActivity.startsWith('.') ? `${appPackage}${appActivity}` : appActivity;

      _logger.default.debug(`Found package: '${appPackage}' and fully qualified activity name : '${fullyQualifiedActivity}'`);

      const isActivityFound = _lodash.default.includes(allPackages, appPackage) && possibleActivityPatterns.some(p => p.test(fullyQualifiedActivity));

      if (!waitForStop && isActivityFound || waitForStop && !isActivityFound) {
        return true;
      }
    }

    _logger.default.debug('Incorrect package and activity. Retrying.');

    return false;
  };

  try {
    await (0, _asyncbox.waitForCondition)(conditionFunc, {
      waitMs: parseInt(waitMs, 10),
      intervalMs: 500
    });
  } catch (e) {
    throw new Error(`${possibleActivityNames.map(name => `'${name}'`).join(' or ')} never ${waitForStop ? 'stopped' : 'started'}. ` + `Visit ${ACTIVITIES_TROUBLESHOOTING_LINK} for troubleshooting`);
  }
};

apkUtilsMethods.waitForActivity = async function waitForActivity(pkg, act, waitMs = 20000) {
  await this.waitForActivityOrNot(pkg, act, false, waitMs);
};

apkUtilsMethods.waitForNotActivity = async function waitForNotActivity(pkg, act, waitMs = 20000) {
  await this.waitForActivityOrNot(pkg, act, true, waitMs);
};

apkUtilsMethods.uninstallApk = async function uninstallApk(pkg, options = {}) {
  _logger.default.debug(`Uninstalling ${pkg}`);

  if (!(await this.isAppInstalled(pkg))) {
    _logger.default.info(`${pkg} was not uninstalled, because it was not present on the device`);

    return false;
  }

  const cmd = ['uninstall'];

  if (options.keepData) {
    cmd.push('-k');
  }

  cmd.push(pkg);
  let stdout;

  try {
    await this.forceStop(pkg);
    stdout = (await this.adbExec(cmd, {
      timeout: options.timeout
    })).trim();
  } catch (e) {
    throw new Error(`Unable to uninstall APK. Original error: ${e.message}`);
  }

  _logger.default.debug(`'adb ${cmd.join(' ')}' command output: ${stdout}`);

  if (stdout.includes('Success')) {
    _logger.default.info(`${pkg} was successfully uninstalled`);

    return true;
  }

  _logger.default.info(`${pkg} was not uninstalled`);

  return false;
};

apkUtilsMethods.installFromDevicePath = async function installFromDevicePath(apkPathOnDevice, opts = {}) {
  let stdout = await this.shell(['pm', 'install', '-r', apkPathOnDevice], opts);

  if (stdout.indexOf('Failure') !== -1) {
    throw new Error(`Remote install failed: ${stdout}`);
  }
};

apkUtilsMethods.cacheApk = async function cacheApk(apkPath, options = {}) {
  const appHash = await _support.fs.hash(apkPath);

  const remotePath = _path.default.posix.join(REMOTE_CACHE_ROOT, `${appHash}.apk`);

  const remoteCachedFiles = [];

  try {
    const errorMarker = '_ERROR_';
    let lsOutput = null;

    if (this._areExtendedLsOptionsSupported === true || !_lodash.default.isBoolean(this._areExtendedLsOptionsSupported)) {
      lsOutput = await this.shell([`ls -t -1 ${REMOTE_CACHE_ROOT} 2>&1 || echo ${errorMarker}`]);
    }

    if (!_lodash.default.isString(lsOutput) || lsOutput.includes(errorMarker) && !lsOutput.includes(REMOTE_CACHE_ROOT)) {
      if (!_lodash.default.isBoolean(this._areExtendedLsOptionsSupported)) {
        _logger.default.debug('The current Android API does not support extended ls options. ' + 'Defaulting to no-options call');
      }

      lsOutput = await this.shell([`ls ${REMOTE_CACHE_ROOT} 2>&1 || echo ${errorMarker}`]);
      this._areExtendedLsOptionsSupported = false;
    } else {
      this._areExtendedLsOptionsSupported = true;
    }

    if (lsOutput.includes(errorMarker)) {
      throw new Error(lsOutput.substring(0, lsOutput.indexOf(errorMarker)));
    }

    remoteCachedFiles.push(...lsOutput.split('\n').map(x => x.trim()).filter(Boolean));
  } catch (e) {
    _logger.default.debug(`Got an error '${e.message.trim()}' while getting the list of files in the cache. ` + `Assuming the cache does not exist yet`);

    await this.shell(['mkdir', '-p', REMOTE_CACHE_ROOT]);
  }

  _logger.default.debug(`The count of applications in the cache: ${remoteCachedFiles.length}`);

  const toHash = remotePath => _path.default.posix.parse(remotePath).name;

  if (remoteCachedFiles.some(x => toHash(x) === appHash)) {
    _logger.default.info(`The application at '${apkPath}' is already cached to '${remotePath}'`);

    this.shell(['touch', '-am', remotePath]).catch(() => {});
  } else {
    _logger.default.info(`Caching the application at '${apkPath}' to '${remotePath}'`);

    const timer = new _support.timing.Timer().start();
    await this.push(apkPath, remotePath, {
      timeout: options.timeout
    });
    const {
      size
    } = await _support.fs.stat(apkPath);

    _logger.default.info(`The upload of '${_path.default.basename(apkPath)}' (${_support.util.toReadableSizeString(size)}) ` + `took ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);
  }

  if (!this.remoteAppsCache) {
    this.remoteAppsCache = new _lruCache.default({
      max: this.remoteAppsCacheLimit
    });
  }

  _lodash.default.difference([...this.remoteAppsCache.keys()], remoteCachedFiles.map(toHash)).forEach(hash => this.remoteAppsCache.del(hash));

  this.remoteAppsCache.set(appHash, remotePath);
  const entriesToCleanup = remoteCachedFiles.map(x => _path.default.posix.join(REMOTE_CACHE_ROOT, x)).filter(x => !this.remoteAppsCache.has(toHash(x))).slice(this.remoteAppsCacheLimit - [...this.remoteAppsCache.keys()].length);

  if (!_lodash.default.isEmpty(entriesToCleanup)) {
    try {
      await this.shell(['rm', '-f', ...entriesToCleanup]);

      _logger.default.debug(`Deleted ${entriesToCleanup.length} expired application cache entries`);
    } catch (e) {
      _logger.default.warn(`Cannot delete ${entriesToCleanup.length} expired application cache entries. ` + `Original error: ${e.message}`);
    }
  }

  return remotePath;
};

apkUtilsMethods.install = async function install(appPath, options = {}) {
  if (appPath.endsWith(_helpers.APKS_EXTENSION)) {
    return await this.installApks(appPath, options);
  }

  options = _lodash.default.cloneDeep(options);

  _lodash.default.defaults(options, {
    replace: true,
    timeout: this.adbExecTimeout === _helpers.DEFAULT_ADB_EXEC_TIMEOUT ? _helpers.APK_INSTALL_TIMEOUT : this.adbExecTimeout,
    timeoutCapName: 'androidInstallTimeout'
  });

  const installArgs = (0, _helpers.buildInstallArgs)(await this.getApiLevel(), options);

  if (options.noIncremental && (await this.isIncrementalInstallSupported())) {
    installArgs.push('--no-incremental');
  }

  const installOpts = {
    timeout: options.timeout,
    timeoutCapName: options.timeoutCapName
  };
  const installCmd = ['install', ...installArgs, appPath];

  let performAppInstall = async () => await this.adbExec(installCmd, installOpts);

  let shouldCacheApp = this.remoteAppsCacheLimit > 0;

  if (shouldCacheApp) {
    shouldCacheApp = !(await this.isStreamedInstallSupported());

    if (!shouldCacheApp) {
      _logger.default.info(`The application at '${appPath}' will not be cached, because the device under test has ` + `confirmed the support of streamed installs`);
    }
  }

  if (shouldCacheApp) {
    const clearCache = async () => {
      _logger.default.info(`Clearing the cache at '${REMOTE_CACHE_ROOT}'`);

      await this.shell(['rm', '-rf', `${REMOTE_CACHE_ROOT}/*`]);
    };

    const cacheApp = async () => await this.cacheApk(appPath, {
      timeout: options.timeout
    });

    try {
      const cachedAppPath = await cacheApp();

      performAppInstall = async () => {
        const pmInstallCmdByRemotePath = remotePath => ['pm', 'install', ...installArgs, remotePath];

        const output = await this.shell(pmInstallCmdByRemotePath(cachedAppPath), installOpts);

        if (/\bINSTALL_FAILED_INSUFFICIENT_STORAGE\b/.test(output)) {
          _logger.default.warn(`There was a failure while installing '${appPath}' ` + `because of the insufficient device storage space`);

          await clearCache();

          _logger.default.info(`Consider decreasing the maximum amount of cached apps ` + `(currently ${this.remoteAppsCacheLimit}) to avoid such issues in the future`);

          const newCachedAppPath = await cacheApp();
          return await this.shell(pmInstallCmdByRemotePath(newCachedAppPath), installOpts);
        }

        return output;
      };
    } catch (e) {
      _logger.default.debug(e);

      _logger.default.warn(`There was a failure while caching '${appPath}': ${e.message}`);

      _logger.default.warn('Falling back to the default installation procedure');

      await clearCache();
    }
  }

  try {
    const timer = new _support.timing.Timer().start();
    const output = await performAppInstall();

    _logger.default.info(`The installation of '${_path.default.basename(appPath)}' took ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);

    const truncatedOutput = !_lodash.default.isString(output) || output.length <= 300 ? output : `${output.substr(0, 150)}...${output.substr(output.length - 150)}`;

    _logger.default.debug(`Install command stdout: ${truncatedOutput}`);

    if (/\[INSTALL[A-Z_]+FAILED[A-Z_]+\]/.test(output)) {
      if (this.isTestPackageOnlyError(output)) {
        const msg = `Set 'allowTestPackages' capability to true in order to allow test packages installation.`;

        _logger.default.warn(msg);

        throw new Error(`${output}\n${msg}`);
      }

      throw new Error(output);
    }
  } catch (err) {
    if (!err.message.includes('INSTALL_FAILED_ALREADY_EXISTS')) {
      throw err;
    }

    _logger.default.debug(`Application '${appPath}' already installed. Continuing.`);
  }
};

apkUtilsMethods.getApplicationInstallState = async function getApplicationInstallState(appPath, pkg = null) {
  let apkInfo = null;

  if (!pkg) {
    apkInfo = await this.getApkInfo(appPath);
    pkg = apkInfo.name;
  }

  if (!pkg) {
    _logger.default.warn(`Cannot read the package name of '${appPath}'`);

    return this.APP_INSTALL_STATE.UNKNOWN;
  }

  if (!(await this.isAppInstalled(pkg))) {
    _logger.default.debug(`App '${appPath}' is not installed`);

    return this.APP_INSTALL_STATE.NOT_INSTALLED;
  }

  const {
    versionCode: pkgVersionCode,
    versionName: pkgVersionNameStr
  } = await this.getPackageInfo(pkg);

  const pkgVersionName = _semver.default.valid(_semver.default.coerce(pkgVersionNameStr));

  if (!apkInfo) {
    apkInfo = await this.getApkInfo(appPath);
  }

  const {
    versionCode: apkVersionCode,
    versionName: apkVersionNameStr
  } = apkInfo;

  const apkVersionName = _semver.default.valid(_semver.default.coerce(apkVersionNameStr));

  if (!_lodash.default.isInteger(apkVersionCode) || !_lodash.default.isInteger(pkgVersionCode)) {
    _logger.default.warn(`Cannot read version codes of '${appPath}' and/or '${pkg}'`);

    if (!_lodash.default.isString(apkVersionName) || !_lodash.default.isString(pkgVersionName)) {
      _logger.default.warn(`Cannot read version names of '${appPath}' and/or '${pkg}'`);

      return this.APP_INSTALL_STATE.UNKNOWN;
    }
  }

  if (_lodash.default.isInteger(apkVersionCode) && _lodash.default.isInteger(pkgVersionCode)) {
    if (pkgVersionCode > apkVersionCode) {
      _logger.default.debug(`The version code of the installed '${pkg}' is greater than the application version code (${pkgVersionCode} > ${apkVersionCode})`);

      return this.APP_INSTALL_STATE.NEWER_VERSION_INSTALLED;
    }

    if (pkgVersionCode === apkVersionCode) {
      if (_lodash.default.isString(apkVersionName) && _lodash.default.isString(pkgVersionName) && _semver.default.satisfies(pkgVersionName, `>=${apkVersionName}`)) {
        _logger.default.debug(`The version name of the installed '${pkg}' is greater or equal to the application version name ('${pkgVersionName}' >= '${apkVersionName}')`);

        return _semver.default.satisfies(pkgVersionName, `>${apkVersionName}`) ? this.APP_INSTALL_STATE.NEWER_VERSION_INSTALLED : this.APP_INSTALL_STATE.SAME_VERSION_INSTALLED;
      }

      if (!_lodash.default.isString(apkVersionName) || !_lodash.default.isString(pkgVersionName)) {
        _logger.default.debug(`The version name of the installed '${pkg}' is equal to application version name (${pkgVersionCode} === ${apkVersionCode})`);

        return this.APP_INSTALL_STATE.SAME_VERSION_INSTALLED;
      }
    }
  } else if (_lodash.default.isString(apkVersionName) && _lodash.default.isString(pkgVersionName) && _semver.default.satisfies(pkgVersionName, `>=${apkVersionName}`)) {
    _logger.default.debug(`The version name of the installed '${pkg}' is greater or equal to the application version name ('${pkgVersionName}' >= '${apkVersionName}')`);

    return _semver.default.satisfies(pkgVersionName, `>${apkVersionName}`) ? this.APP_INSTALL_STATE.NEWER_VERSION_INSTALLED : this.APP_INSTALL_STATE.SAME_VERSION_INSTALLED;
  }

  _logger.default.debug(`The installed '${pkg}' package is older than '${appPath}' (${pkgVersionCode} < ${apkVersionCode} or '${pkgVersionName}' < '${apkVersionName}')'`);

  return this.APP_INSTALL_STATE.OLDER_VERSION_INSTALLED;
};

apkUtilsMethods.installOrUpgrade = async function installOrUpgrade(appPath, pkg = null, options = {}) {
  if (!pkg) {
    const apkInfo = await this.getApkInfo(appPath);
    pkg = apkInfo.name;
  }

  const {
    enforceCurrentBuild
  } = options;
  const appState = await this.getApplicationInstallState(appPath, pkg);
  let wasUninstalled = false;

  const uninstallPackage = async () => {
    if (!(await this.uninstallApk(pkg))) {
      throw new Error(`'${pkg}' package cannot be uninstalled`);
    }

    wasUninstalled = true;
  };

  switch (appState) {
    case this.APP_INSTALL_STATE.NOT_INSTALLED:
      _logger.default.debug(`Installing '${appPath}'`);

      await this.install(appPath, Object.assign({}, options, {
        replace: false
      }));
      return {
        appState,
        wasUninstalled
      };

    case this.APP_INSTALL_STATE.NEWER_VERSION_INSTALLED:
      if (enforceCurrentBuild) {
        _logger.default.info(`Downgrading '${pkg}' as requested`);

        await uninstallPackage();
        break;
      }

      _logger.default.debug(`There is no need to downgrade '${pkg}'`);

      return {
        appState,
        wasUninstalled
      };

    case this.APP_INSTALL_STATE.SAME_VERSION_INSTALLED:
      if (enforceCurrentBuild) {
        break;
      }

      _logger.default.debug(`There is no need to install/upgrade '${appPath}'`);

      return {
        appState,
        wasUninstalled
      };

    case this.APP_INSTALL_STATE.OLDER_VERSION_INSTALLED:
      _logger.default.debug(`Executing upgrade of '${appPath}'`);

      break;

    default:
      _logger.default.debug(`The current install state of '${appPath}' is unknown. Installing anyway`);

      break;
  }

  try {
    await this.install(appPath, Object.assign({}, options, {
      replace: true
    }));
  } catch (err) {
    _logger.default.warn(`Cannot install/upgrade '${pkg}' because of '${err.message}'. Trying full reinstall`);

    await uninstallPackage();
    await this.install(appPath, Object.assign({}, options, {
      replace: false
    }));
  }

  return {
    appState,
    wasUninstalled
  };
};

apkUtilsMethods.extractStringsFromApk = async function extractStringsFromApk(appPath, language, out) {
  _logger.default.debug(`Extracting strings from for language: ${language || 'default'}`);

  const originalAppPath = appPath;

  if (appPath.endsWith(_helpers.APKS_EXTENSION)) {
    appPath = await this.extractLanguageApk(appPath, language);
  }

  let apkStrings = {};
  let configMarker;

  try {
    await this.initAapt();
    configMarker = await (0, _helpers.formatConfigMarker)(async () => {
      const {
        stdout
      } = await (0, _teen_process.exec)(this.binaries.aapt, ['d', 'configurations', appPath]);
      return _lodash.default.uniq(stdout.split(_os.default.EOL));
    }, language, '(default)');
    const {
      stdout
    } = await (0, _teen_process.exec)(this.binaries.aapt, ['d', '--values', 'resources', appPath]);
    apkStrings = (0, _helpers.parseAaptStrings)(stdout, configMarker);
  } catch (e) {
    _logger.default.debug('Cannot extract resources using aapt. Trying aapt2. ' + `Original error: ${e.stderr || e.message}`);

    await this.initAapt2();
    configMarker = await (0, _helpers.formatConfigMarker)(async () => {
      const {
        stdout
      } = await (0, _teen_process.exec)(this.binaries.aapt2, ['d', 'configurations', appPath]);
      return _lodash.default.uniq(stdout.split(_os.default.EOL));
    }, language, '');

    try {
      const {
        stdout
      } = await (0, _teen_process.exec)(this.binaries.aapt2, ['d', 'resources', appPath]);
      apkStrings = (0, _helpers.parseAapt2Strings)(stdout, configMarker);
    } catch (e) {
      throw new Error(`Cannot extract resources from '${originalAppPath}'. ` + `Original error: ${e.message}`);
    }
  }

  if (_lodash.default.isEmpty(apkStrings)) {
    _logger.default.warn(`No strings have been found in '${originalAppPath}' resources ` + `for '${configMarker || 'default'}' configuration`);
  } else {
    _logger.default.info(`Successfully extracted ${_lodash.default.keys(apkStrings).length} strings from ` + `'${originalAppPath}' resources for '${configMarker || 'default'}' configuration`);
  }

  const localPath = _path.default.resolve(out, 'strings.json');

  await (0, _support.mkdirp)(out);
  await _support.fs.writeFile(localPath, JSON.stringify(apkStrings, null, 2), 'utf-8');
  return {
    apkStrings,
    localPath
  };
};

apkUtilsMethods.getDeviceLanguage = async function getDeviceLanguage() {
  let language;

  if ((await this.getApiLevel()) < 23) {
    language = await this.getDeviceSysLanguage();

    if (!language) {
      language = await this.getDeviceProductLanguage();
    }
  } else {
    language = (await this.getDeviceLocale()).split('-')[0];
  }

  return language;
};

apkUtilsMethods.getDeviceCountry = async function getDeviceCountry() {
  let country = await this.getDeviceSysCountry();

  if (!country) {
    country = await this.getDeviceProductCountry();
  }

  return country;
};

apkUtilsMethods.getDeviceLocale = async function getDeviceLocale() {
  let locale = await this.getDeviceSysLocale();

  if (!locale) {
    locale = await this.getDeviceProductLocale();
  }

  return locale;
};

apkUtilsMethods.setDeviceLocale = async function setDeviceLocale(locale) {
  const validateLocale = new RegExp(/[a-zA-Z]+-[a-zA-Z0-9]+/);

  if (!validateLocale.test(locale)) {
    _logger.default.warn(`setDeviceLocale requires the following format: en-US or ja-JP`);

    return;
  }

  let split_locale = locale.split('-');
  await this.setDeviceLanguageCountry(split_locale[0], split_locale[1]);
};

apkUtilsMethods.ensureCurrentLocale = async function ensureCurrentLocale(language, country, script = null) {
  const hasLanguage = _lodash.default.isString(language);

  const hasCountry = _lodash.default.isString(country);

  if (!hasLanguage && !hasCountry) {
    _logger.default.warn('ensureCurrentLocale requires language or country');

    return false;
  }

  language = (language || '').toLowerCase();
  country = (country || '').toLowerCase();
  const apiLevel = await this.getApiLevel();
  return await (0, _asyncbox.retryInterval)(5, 1000, async () => {
    try {
      if (apiLevel < 23) {
        let curLanguage, curCountry;

        if (hasLanguage) {
          curLanguage = (await this.getDeviceLanguage()).toLowerCase();

          if (!hasCountry && language === curLanguage) {
            return true;
          }
        }

        if (hasCountry) {
          curCountry = (await this.getDeviceCountry()).toLowerCase();

          if (!hasLanguage && country === curCountry) {
            return true;
          }
        }

        if (language === curLanguage && country === curCountry) {
          return true;
        }
      } else {
        const curLocale = (await this.getDeviceLocale()).toLowerCase();
        const localeCode = script ? `${language}-${script.toLowerCase()}-${country}` : `${language}-${country}`;

        if (localeCode === curLocale) {
          _logger.default.debug(`Requested locale is equal to current locale: '${curLocale}'`);

          return true;
        }
      }

      return false;
    } catch (err) {
      _logger.default.error(`Unable to check device localization: ${err.message}`);

      try {
        await this.reconnect();
      } catch (ign) {
        await this.restartAdb();
      }

      throw err;
    }
  });
};

apkUtilsMethods.setDeviceLanguageCountry = async function setDeviceLanguageCountry(language, country, script = null) {
  let hasLanguage = language && _lodash.default.isString(language);

  let hasCountry = country && _lodash.default.isString(country);

  if (!hasLanguage || !hasCountry) {
    _logger.default.warn(`setDeviceLanguageCountry requires language and country at least`);

    _logger.default.warn(`Got language: '${language}' and country: '${country}'`);

    return;
  }

  let apiLevel = await this.getApiLevel();
  language = (language || '').toLowerCase();
  country = (country || '').toUpperCase();

  if (apiLevel < 23) {
    let curLanguage = (await this.getDeviceLanguage()).toLowerCase();
    let curCountry = (await this.getDeviceCountry()).toUpperCase();

    if (language !== curLanguage || country !== curCountry) {
      await this.setDeviceSysLocaleViaSettingApp(language, country);
    }
  } else {
    let curLocale = await this.getDeviceLocale();
    const localeCode = script ? `${language}-${script}-${country}` : `${language}-${country}`;

    _logger.default.debug(`Current locale: '${curLocale}'; requested locale: '${localeCode}'`);

    if (localeCode.toLowerCase() !== curLocale.toLowerCase()) {
      await this.setDeviceSysLocaleViaSettingApp(language, country, script);
    }
  }
};

apkUtilsMethods.getApkInfo = async function getApkInfo(appPath) {
  if (!(await _support.fs.exists(appPath))) {
    throw new Error(`The file at path ${appPath} does not exist or is not accessible`);
  }

  if (appPath.endsWith(_helpers.APKS_EXTENSION)) {
    appPath = await this.extractBaseApk(appPath);
  }

  try {
    const apkReader = await _adbkitApkreader.default.open(appPath);
    const manifest = await apkReader.readManifest();
    const {
      pkg,
      versionName,
      versionCode
    } = (0, _helpers.parseManifest)(manifest);
    return {
      name: pkg,
      versionCode,
      versionName
    };
  } catch (e) {
    _logger.default.warn(`Error '${e.message}' while getting badging info`);
  }

  return {};
};

apkUtilsMethods.getPackageInfo = async function getPackageInfo(pkg) {
  _logger.default.debug(`Getting package info for '${pkg}'`);

  let result = {
    name: pkg
  };

  try {
    const stdout = await this.shell(['dumpsys', 'package', pkg]);
    const versionNameMatch = new RegExp(/versionName=([\d+.]+)/).exec(stdout);

    if (versionNameMatch) {
      result.versionName = versionNameMatch[1];
    }

    const versionCodeMatch = new RegExp(/versionCode=(\d+)/).exec(stdout);

    if (versionCodeMatch) {
      result.versionCode = parseInt(versionCodeMatch[1], 10);
    }

    return result;
  } catch (err) {
    _logger.default.warn(`Error '${err.message}' while dumping package info`);
  }

  return result;
};

apkUtilsMethods.pullApk = async function pullApk(pkg, tmpDir) {
  const pkgPath = (await this.adbExec(['shell', 'pm', 'path', pkg])).replace('package:', '');

  const tmpApp = _path.default.resolve(tmpDir, `${pkg}.apk`);

  await this.pull(pkgPath, tmpApp);

  _logger.default.debug(`Pulled app for package '${pkg}' to '${tmpApp}'`);

  return tmpApp;
};

var _default = apkUtilsMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL3Rvb2xzL2Fway11dGlscy5qcyIsIm5hbWVzIjpbImFwa1V0aWxzTWV0aG9kcyIsIkFDVElWSVRJRVNfVFJPVUJMRVNIT09USU5HX0xJTksiLCJBUFBfSU5TVEFMTF9TVEFURSIsIlVOS05PV04iLCJOT1RfSU5TVEFMTEVEIiwiTkVXRVJfVkVSU0lPTl9JTlNUQUxMRUQiLCJTQU1FX1ZFUlNJT05fSU5TVEFMTEVEIiwiT0xERVJfVkVSU0lPTl9JTlNUQUxMRUQiLCJSRU1PVEVfQ0FDSEVfUk9PVCIsImlzQXBwSW5zdGFsbGVkIiwicGtnIiwibG9nIiwiZGVidWciLCJpbnN0YWxsZWRQYXR0ZXJuIiwiUmVnRXhwIiwiXyIsImVzY2FwZVJlZ0V4cCIsInN0ZG91dCIsInNoZWxsIiwiaXNJbnN0YWxsZWQiLCJ0ZXN0IiwiZSIsIkVycm9yIiwibWVzc2FnZSIsInN0YXJ0VXJpIiwidXJpIiwib3B0cyIsIndhaXRGb3JMYXVuY2giLCJhcmdzIiwicHVzaCIsImVzY2FwZVNoZWxsQXJnIiwicmVzIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInN0YXJ0QXBwIiwic3RhcnRBcHBPcHRpb25zIiwiYWN0aXZpdHkiLCJhY3Rpb24iLCJjbG9uZSIsInJlcGxhY2UiLCJkZWZhdWx0cyIsIndhaXRQa2ciLCJ3YWl0QWN0aXZpdHkiLCJyZXRyeSIsInN0b3BBcHAiLCJhcGlMZXZlbCIsImdldEFwaUxldmVsIiwiY21kIiwiYnVpbGRTdGFydENtZCIsImludGVudE5hbWUiLCJvcHRpb25hbEludGVudEFyZ3VtZW50cyIsInNoZWxsT3B0cyIsImlzSW50ZWdlciIsIndhaXREdXJhdGlvbiIsInRpbWVvdXQiLCJzdGFydHNXaXRoIiwid2FpdEZvckFjdGl2aXR5IiwiYXBwRGVzY3JpcHRvciIsImR1bXBXaW5kb3dzIiwiZHVtcHN5c0FyZyIsImdldEZvY3VzZWRQYWNrYWdlQW5kQWN0aXZpdHkiLCJudWxsRm9jdXNlZEFwcFJlIiwiZm9jdXNlZEFwcFJlIiwibnVsbEN1cnJlbnRGb2N1c1JlIiwiY3VycmVudEZvY3VzQXBwUmUiLCJwYXR0ZXJuIiwibWF0Y2giLCJleGVjIiwiYXBwUGFja2FnZSIsInRyaW0iLCJhcHBBY3Rpdml0eSIsIndhaXRGb3JBY3Rpdml0eU9yTm90Iiwid2FpdEZvclN0b3AiLCJ3YWl0TXMiLCJzcGxpdE5hbWVzIiwibmFtZXMiLCJzcGxpdCIsIm1hcCIsIm5hbWUiLCJhbGxQYWNrYWdlcyIsImFsbEFjdGl2aXRpZXMiLCJwb3NzaWJsZUFjdGl2aXR5TmFtZXMiLCJvbmVBY3Rpdml0eSIsImN1cnJlbnRQa2ciLCJqb2luIiwicG9zc2libGVBY3Rpdml0eVBhdHRlcm5zIiwiYWN0TmFtZSIsImNvbmRpdGlvbkZ1bmMiLCJmdWxseVF1YWxpZmllZEFjdGl2aXR5IiwiaXNBY3Rpdml0eUZvdW5kIiwic29tZSIsInAiLCJ3YWl0Rm9yQ29uZGl0aW9uIiwicGFyc2VJbnQiLCJpbnRlcnZhbE1zIiwiYWN0Iiwid2FpdEZvck5vdEFjdGl2aXR5IiwidW5pbnN0YWxsQXBrIiwib3B0aW9ucyIsImluZm8iLCJrZWVwRGF0YSIsImZvcmNlU3RvcCIsImFkYkV4ZWMiLCJpbnN0YWxsRnJvbURldmljZVBhdGgiLCJhcGtQYXRoT25EZXZpY2UiLCJpbmRleE9mIiwiY2FjaGVBcGsiLCJhcGtQYXRoIiwiYXBwSGFzaCIsImZzIiwiaGFzaCIsInJlbW90ZVBhdGgiLCJwYXRoIiwicG9zaXgiLCJyZW1vdGVDYWNoZWRGaWxlcyIsImVycm9yTWFya2VyIiwibHNPdXRwdXQiLCJfYXJlRXh0ZW5kZWRMc09wdGlvbnNTdXBwb3J0ZWQiLCJpc0Jvb2xlYW4iLCJpc1N0cmluZyIsInN1YnN0cmluZyIsIngiLCJmaWx0ZXIiLCJCb29sZWFuIiwibGVuZ3RoIiwidG9IYXNoIiwicGFyc2UiLCJjYXRjaCIsInRpbWVyIiwidGltaW5nIiwiVGltZXIiLCJzdGFydCIsInNpemUiLCJzdGF0IiwiYmFzZW5hbWUiLCJ1dGlsIiwidG9SZWFkYWJsZVNpemVTdHJpbmciLCJnZXREdXJhdGlvbiIsImFzTWlsbGlTZWNvbmRzIiwidG9GaXhlZCIsInJlbW90ZUFwcHNDYWNoZSIsIkxSVSIsIm1heCIsInJlbW90ZUFwcHNDYWNoZUxpbWl0IiwiZGlmZmVyZW5jZSIsImtleXMiLCJmb3JFYWNoIiwiZGVsIiwic2V0IiwiZW50cmllc1RvQ2xlYW51cCIsImhhcyIsInNsaWNlIiwiaXNFbXB0eSIsIndhcm4iLCJpbnN0YWxsIiwiYXBwUGF0aCIsImVuZHNXaXRoIiwiQVBLU19FWFRFTlNJT04iLCJpbnN0YWxsQXBrcyIsImNsb25lRGVlcCIsImFkYkV4ZWNUaW1lb3V0IiwiREVGQVVMVF9BREJfRVhFQ19USU1FT1VUIiwiQVBLX0lOU1RBTExfVElNRU9VVCIsInRpbWVvdXRDYXBOYW1lIiwiaW5zdGFsbEFyZ3MiLCJidWlsZEluc3RhbGxBcmdzIiwibm9JbmNyZW1lbnRhbCIsImlzSW5jcmVtZW50YWxJbnN0YWxsU3VwcG9ydGVkIiwiaW5zdGFsbE9wdHMiLCJpbnN0YWxsQ21kIiwicGVyZm9ybUFwcEluc3RhbGwiLCJzaG91bGRDYWNoZUFwcCIsImlzU3RyZWFtZWRJbnN0YWxsU3VwcG9ydGVkIiwiY2xlYXJDYWNoZSIsImNhY2hlQXBwIiwiY2FjaGVkQXBwUGF0aCIsInBtSW5zdGFsbENtZEJ5UmVtb3RlUGF0aCIsIm91dHB1dCIsIm5ld0NhY2hlZEFwcFBhdGgiLCJ0cnVuY2F0ZWRPdXRwdXQiLCJzdWJzdHIiLCJpc1Rlc3RQYWNrYWdlT25seUVycm9yIiwibXNnIiwiZXJyIiwiZ2V0QXBwbGljYXRpb25JbnN0YWxsU3RhdGUiLCJhcGtJbmZvIiwiZ2V0QXBrSW5mbyIsInZlcnNpb25Db2RlIiwicGtnVmVyc2lvbkNvZGUiLCJ2ZXJzaW9uTmFtZSIsInBrZ1ZlcnNpb25OYW1lU3RyIiwiZ2V0UGFja2FnZUluZm8iLCJwa2dWZXJzaW9uTmFtZSIsInNlbXZlciIsInZhbGlkIiwiY29lcmNlIiwiYXBrVmVyc2lvbkNvZGUiLCJhcGtWZXJzaW9uTmFtZVN0ciIsImFwa1ZlcnNpb25OYW1lIiwic2F0aXNmaWVzIiwiaW5zdGFsbE9yVXBncmFkZSIsImVuZm9yY2VDdXJyZW50QnVpbGQiLCJhcHBTdGF0ZSIsIndhc1VuaW5zdGFsbGVkIiwidW5pbnN0YWxsUGFja2FnZSIsIk9iamVjdCIsImFzc2lnbiIsImV4dHJhY3RTdHJpbmdzRnJvbUFwayIsImxhbmd1YWdlIiwib3V0Iiwib3JpZ2luYWxBcHBQYXRoIiwiZXh0cmFjdExhbmd1YWdlQXBrIiwiYXBrU3RyaW5ncyIsImNvbmZpZ01hcmtlciIsImluaXRBYXB0IiwiZm9ybWF0Q29uZmlnTWFya2VyIiwiYmluYXJpZXMiLCJhYXB0IiwidW5pcSIsIm9zIiwiRU9MIiwicGFyc2VBYXB0U3RyaW5ncyIsInN0ZGVyciIsImluaXRBYXB0MiIsImFhcHQyIiwicGFyc2VBYXB0MlN0cmluZ3MiLCJsb2NhbFBhdGgiLCJyZXNvbHZlIiwibWtkaXJwIiwid3JpdGVGaWxlIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldERldmljZUxhbmd1YWdlIiwiZ2V0RGV2aWNlU3lzTGFuZ3VhZ2UiLCJnZXREZXZpY2VQcm9kdWN0TGFuZ3VhZ2UiLCJnZXREZXZpY2VMb2NhbGUiLCJnZXREZXZpY2VDb3VudHJ5IiwiY291bnRyeSIsImdldERldmljZVN5c0NvdW50cnkiLCJnZXREZXZpY2VQcm9kdWN0Q291bnRyeSIsImxvY2FsZSIsImdldERldmljZVN5c0xvY2FsZSIsImdldERldmljZVByb2R1Y3RMb2NhbGUiLCJzZXREZXZpY2VMb2NhbGUiLCJ2YWxpZGF0ZUxvY2FsZSIsInNwbGl0X2xvY2FsZSIsInNldERldmljZUxhbmd1YWdlQ291bnRyeSIsImVuc3VyZUN1cnJlbnRMb2NhbGUiLCJzY3JpcHQiLCJoYXNMYW5ndWFnZSIsImhhc0NvdW50cnkiLCJyZXRyeUludGVydmFsIiwiY3VyTGFuZ3VhZ2UiLCJjdXJDb3VudHJ5IiwiY3VyTG9jYWxlIiwibG9jYWxlQ29kZSIsImVycm9yIiwicmVjb25uZWN0IiwiaWduIiwicmVzdGFydEFkYiIsInRvVXBwZXJDYXNlIiwic2V0RGV2aWNlU3lzTG9jYWxlVmlhU2V0dGluZ0FwcCIsImV4aXN0cyIsImV4dHJhY3RCYXNlQXBrIiwiYXBrUmVhZGVyIiwiQXBrUmVhZGVyIiwib3BlbiIsIm1hbmlmZXN0IiwicmVhZE1hbmlmZXN0IiwicGFyc2VNYW5pZmVzdCIsInJlc3VsdCIsInZlcnNpb25OYW1lTWF0Y2giLCJ2ZXJzaW9uQ29kZU1hdGNoIiwicHVsbEFwayIsInRtcERpciIsInBrZ1BhdGgiLCJ0bXBBcHAiLCJwdWxsIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLiIsInNvdXJjZXMiOlsibGliL3Rvb2xzL2Fway11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBidWlsZFN0YXJ0Q21kLCBBUEtTX0VYVEVOU0lPTiwgYnVpbGRJbnN0YWxsQXJncyxcbiAgQVBLX0lOU1RBTExfVElNRU9VVCwgREVGQVVMVF9BREJfRVhFQ19USU1FT1VULFxuICBwYXJzZU1hbmlmZXN0LCBwYXJzZUFhcHRTdHJpbmdzLCBwYXJzZUFhcHQyU3RyaW5ncywgZm9ybWF0Q29uZmlnTWFya2VyLFxuICBlc2NhcGVTaGVsbEFyZyxcbn0gZnJvbSAnLi4vaGVscGVycy5qcyc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyLmpzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwsIHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBmcywgdXRpbCwgbWtkaXJwLCB0aW1pbmcgfSBmcm9tICdAYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IG9zIGZyb20gJ29zJztcbmltcG9ydCBMUlUgZnJvbSAnbHJ1LWNhY2hlJztcbmltcG9ydCBBcGtSZWFkZXIgZnJvbSAnYWRia2l0LWFwa3JlYWRlcic7XG5cbmNvbnN0IGFwa1V0aWxzTWV0aG9kcyA9IHt9O1xuXG5jb25zdCBBQ1RJVklUSUVTX1RST1VCTEVTSE9PVElOR19MSU5LID1cbiAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vYXBwaXVtL2Jsb2IvbWFzdGVyL2RvY3MvZW4vd3JpdGluZy1ydW5uaW5nLWFwcGl1bS9hbmRyb2lkL2FjdGl2aXR5LXN0YXJ0dXAubWQnO1xuYXBrVXRpbHNNZXRob2RzLkFQUF9JTlNUQUxMX1NUQVRFID0ge1xuICBVTktOT1dOOiAndW5rbm93bicsXG4gIE5PVF9JTlNUQUxMRUQ6ICdub3RJbnN0YWxsZWQnLFxuICBORVdFUl9WRVJTSU9OX0lOU1RBTExFRDogJ25ld2VyVmVyc2lvbkluc3RhbGxlZCcsXG4gIFNBTUVfVkVSU0lPTl9JTlNUQUxMRUQ6ICdzYW1lVmVyc2lvbkluc3RhbGxlZCcsXG4gIE9MREVSX1ZFUlNJT05fSU5TVEFMTEVEOiAnb2xkZXJWZXJzaW9uSW5zdGFsbGVkJyxcbn07XG5jb25zdCBSRU1PVEVfQ0FDSEVfUk9PVCA9ICcvZGF0YS9sb2NhbC90bXAvYXBwaXVtX2NhY2hlJztcblxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHBhcnRpY3VsYXIgcGFja2FnZSBpcyBwcmVzZW50IG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYWNrYWdlIGlzIGluc3RhbGxlZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZGV0ZWN0aW5nIGFwcGxpY2F0aW9uIHN0YXRlXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5pc0FwcEluc3RhbGxlZCA9IGFzeW5jIGZ1bmN0aW9uIGlzQXBwSW5zdGFsbGVkIChwa2cpIHtcbiAgbG9nLmRlYnVnKGBHZXR0aW5nIGluc3RhbGwgc3RhdHVzIGZvciAke3BrZ31gKTtcbiAgY29uc3QgaW5zdGFsbGVkUGF0dGVybiA9IG5ldyBSZWdFeHAoYF5cXFxccypQYWNrYWdlXFxcXHMrXFxcXFske18uZXNjYXBlUmVnRXhwKHBrZyl9XFxcXF1bXjpdKzokYCwgJ20nKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnZHVtcHN5cycsICdwYWNrYWdlJywgcGtnXSk7XG4gICAgY29uc3QgaXNJbnN0YWxsZWQgPSBpbnN0YWxsZWRQYXR0ZXJuLnRlc3Qoc3Rkb3V0KTtcbiAgICBsb2cuZGVidWcoYCcke3BrZ30nIGlzJHshaXNJbnN0YWxsZWQgPyAnIG5vdCcgOiAnJ30gaW5zdGFsbGVkYCk7XG4gICAgcmV0dXJuIGlzSW5zdGFsbGVkO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmaW5kaW5nIGlmICcke3BrZ30nIGlzIGluc3RhbGxlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXJ0VXJpT3B0aW9uc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gd2FpdEZvckxhdW5jaCBbdHJ1ZV0gLSBpZiBgZmFsc2VgIHRoZW4gYWRiIHdvbid0IHdhaXRcbiAqIGZvciB0aGUgc3RhcnRlZCBhY3Rpdml0eSB0byByZXR1cm4gdGhlIGNvbnRyb2xcbiAqL1xuXG4vKipcbiAqIFN0YXJ0IHRoZSBwYXJ0aWN1bGFyIFVSSSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVyaSAtIFRoZSBuYW1lIG9mIFVSSSB0byBzdGFydC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBzdGFydCB0aGUgVVJJIHdpdGguXG4gKiBAcGFyYW0ge1N0YXJ0VXJpT3B0aW9uc30gb3B0c1xuICovXG5hcGtVdGlsc01ldGhvZHMuc3RhcnRVcmkgPSBhc3luYyBmdW5jdGlvbiBzdGFydFVyaSAodXJpLCBwa2csIG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgd2FpdEZvckxhdW5jaCA9IHRydWUsXG4gIH0gPSBvcHRzO1xuXG4gIGlmICghdXJpIHx8ICFwa2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSSSBhbmQgcGFja2FnZSBhcmd1bWVudHMgYXJlIHJlcXVpcmVkJyk7XG4gIH1cblxuICBjb25zdCBhcmdzID0gWydhbScsICdzdGFydCddO1xuICBpZiAod2FpdEZvckxhdW5jaCkge1xuICAgIGFyZ3MucHVzaCgnLVcnKTtcbiAgfVxuICBhcmdzLnB1c2goJy1hJywgJ2FuZHJvaWQuaW50ZW50LmFjdGlvbi5WSUVXJyxcbiAgICAnLWQnLCBlc2NhcGVTaGVsbEFyZyh1cmkpLFxuICAgIHBrZyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xuICAgIGlmIChyZXMudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndW5hYmxlIHRvIHJlc29sdmUgaW50ZW50JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgYXR0ZW1wdGluZyB0byBzdGFydCBVUkkuIE9yaWdpbmFsIGVycm9yOiAke2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RhcnRBcHBPcHRpb25zXG4gKiBAcHJvcGVydHkgeyFzdHJpbmd9IHBrZyAtIFRoZSBuYW1lIG9mIHRoZSBhcHBsaWNhdGlvbiBwYWNrYWdlXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGFjdGl2aXR5IC0gVGhlIG5hbWUgb2YgdGhlIG1haW4gYXBwbGljYXRpb24gYWN0aXZpdHkuXG4gKiBUaGlzIG9yIGFjdGlvbiBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIGxhdW5jaCBhbiBhcHAuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGFjdGlvbiAtIFRoZSBuYW1lIG9mIHRoZSBpbnRlbnQgYWN0aW9uIHRoYXQgd2lsbCBsYXVuY2ggdGhlIHJlcXVpcmVkIGFwcC5cbiAqIFRoaXMgb3IgYWN0aXZpdHkgaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBsYXVuY2ggYW4gYXBwLlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gcmV0cnkgW3RydWVdIC0gSWYgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gYHRydWVgXG4gKiBhbmQgdGhlIGFjdGl2aXR5IG5hbWUgZG9lcyBub3Qgc3RhcnQgd2l0aCAnLicgdGhlbiB0aGUgbWV0aG9kXG4gKiB3aWxsIHRyeSB0byBhZGQgdGhlIG1pc3NpbmcgZG90IGFuZCBzdGFydCB0aGUgYWN0aXZpdHkgb25jZSBtb3JlXG4gKiBpZiB0aGUgZmlyc3Qgc3RhcnR1cCB0cnkgZmFpbHMuXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBzdG9wQXBwIFt0cnVlXSAtIFNldCBpdCB0byBgdHJ1ZWAgaW4gb3JkZXIgdG8gZm9yY2VmdWxseVxuICogc3RvcCB0aGUgYWN0aXZpdHkgaWYgaXQgaXMgYWxyZWFkeSBydW5uaW5nLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSB3YWl0UGtnIC0gVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gd2FpdCB0byBvblxuICogc3RhcnR1cCAodGhpcyBvbmx5IG1ha2VzIHNlbnNlIGlmIHRoaXMgbmFtZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgb25lLCB3aGljaCBpcyBzZXQgYXMgYHBrZ2ApXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHdhaXRBY3Rpdml0eSAtIFRoZSBuYW1lIG9mIHRoZSBhY3Rpdml0eSB0byB3YWl0IHRvIG9uXG4gKiBzdGFydHVwICh0aGlzIG9ubHkgbWFrZXMgc2Vuc2UgaWYgdGhpcyBuYW1lIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBvbmUsIHdoaWNoIGlzIHNldCBhcyBgYWN0aXZpdHlgKVxuICogQHByb3BlcnR5IHs/bnVtYmVyfSB3YWl0RHVyYXRpb24gLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IHVudGlsIHRoZVxuICogYHdhaXRBY3Rpdml0eWAgaXMgZm9jdXNlZFxuICogQHByb3BlcnR5IHs/c3RyaW5nfG51bWJlcn0gdXNlciAtIFRoZSBudW1iZXIgb2YgdGhlIHVzZXIgcHJvZmlsZSB0byBzdGFydFxuICogdGhlIGdpdmVuIGFjdGl2aXR5IHdpdGguIFRoZSBkZWZhdWx0IE9TIHVzZXIgcHJvZmlsZSAodXN1YWxseSB6ZXJvKSBpcyB1c2VkXG4gKiB3aGVuIHRoaXMgcHJvcGVydHkgaXMgdW5zZXRcbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHdhaXRGb3JMYXVuY2ggW3RydWVdIC0gaWYgYGZhbHNlYCB0aGVuIGFkYiB3b24ndCB3YWl0XG4gKiBmb3IgdGhlIHN0YXJ0ZWQgYWN0aXZpdHkgdG8gcmV0dXJuIHRoZSBjb250cm9sXG4gKi9cblxuLyoqXG4gKiBTdGFydCB0aGUgcGFydGljdWxhciBwYWNrYWdlL2FjdGl2aXR5IG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0YXJ0QXBwT3B0aW9uc30gc3RhcnRBcHBPcHRpb25zIFt7fV0gLSBTdGFydHVwIG9wdGlvbnMgbWFwcGluZy5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG91dHB1dCBvZiB0aGUgY29ycmVzcG9uZGluZyBhZGIgY29tbWFuZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbiBlcnJvciB3aGlsZSBleGVjdXRpbmcgdGhlIGFjdGl2aXR5XG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5zdGFydEFwcCA9IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0QXBwIChzdGFydEFwcE9wdGlvbnMgPSB7fSkge1xuICBpZiAoIXN0YXJ0QXBwT3B0aW9ucy5wa2cgfHwgIShzdGFydEFwcE9wdGlvbnMuYWN0aXZpdHkgfHwgc3RhcnRBcHBPcHRpb25zLmFjdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BrZywgYW5kIGFjdGl2aXR5IG9yIGludGVudCBhY3Rpb24sIGFyZSByZXF1aXJlZCB0byBzdGFydCBhbiBhcHBsaWNhdGlvbicpO1xuICB9XG5cbiAgc3RhcnRBcHBPcHRpb25zID0gXy5jbG9uZShzdGFydEFwcE9wdGlvbnMpO1xuICBpZiAoc3RhcnRBcHBPcHRpb25zLmFjdGl2aXR5KSB7XG4gICAgc3RhcnRBcHBPcHRpb25zLmFjdGl2aXR5ID0gc3RhcnRBcHBPcHRpb25zLmFjdGl2aXR5LnJlcGxhY2UoJyQnLCAnXFxcXCQnKTtcbiAgfVxuICAvLyBpbml0aWFsaXppbmcgZGVmYXVsdHNcbiAgXy5kZWZhdWx0cyhzdGFydEFwcE9wdGlvbnMsIHtcbiAgICB3YWl0UGtnOiBzdGFydEFwcE9wdGlvbnMucGtnLFxuICAgIHdhaXRGb3JMYXVuY2g6IHRydWUsXG4gICAgd2FpdEFjdGl2aXR5OiBmYWxzZSxcbiAgICByZXRyeTogdHJ1ZSxcbiAgICBzdG9wQXBwOiB0cnVlXG4gIH0pO1xuICAvLyBwcmV2ZW50aW5nIG51bGwgd2FpdHBrZ1xuICBzdGFydEFwcE9wdGlvbnMud2FpdFBrZyA9IHN0YXJ0QXBwT3B0aW9ucy53YWl0UGtnIHx8IHN0YXJ0QXBwT3B0aW9ucy5wa2c7XG5cbiAgY29uc3QgYXBpTGV2ZWwgPSBhd2FpdCB0aGlzLmdldEFwaUxldmVsKCk7XG4gIGNvbnN0IGNtZCA9IGJ1aWxkU3RhcnRDbWQoc3RhcnRBcHBPcHRpb25zLCBhcGlMZXZlbCk7XG4gIGNvbnN0IGludGVudE5hbWUgPSBgJHtzdGFydEFwcE9wdGlvbnMuYWN0aW9ufSR7c3RhcnRBcHBPcHRpb25zLm9wdGlvbmFsSW50ZW50QXJndW1lbnRzID8gJyAnICsgc3RhcnRBcHBPcHRpb25zLm9wdGlvbmFsSW50ZW50QXJndW1lbnRzIDogJyd9YDtcbiAgdHJ5IHtcbiAgICBjb25zdCBzaGVsbE9wdHMgPSB7fTtcbiAgICBpZiAoXy5pc0ludGVnZXIoc3RhcnRBcHBPcHRpb25zLndhaXREdXJhdGlvbikgJiYgc3RhcnRBcHBPcHRpb25zLndhaXREdXJhdGlvbiA+PSAwKSB7XG4gICAgICBzaGVsbE9wdHMudGltZW91dCA9IHN0YXJ0QXBwT3B0aW9ucy53YWl0RHVyYXRpb247XG4gICAgfVxuICAgIGNvbnN0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoY21kLCBzaGVsbE9wdHMpO1xuICAgIGlmIChzdGRvdXQuaW5jbHVkZXMoJ0Vycm9yOiBBY3Rpdml0eSBjbGFzcycpICYmIHN0ZG91dC5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSkge1xuICAgICAgaWYgKHN0YXJ0QXBwT3B0aW9ucy5yZXRyeSAmJiAhc3RhcnRBcHBPcHRpb25zLmFjdGl2aXR5LnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICBsb2cuZGVidWcoYFdlIHRyaWVkIHRvIHN0YXJ0IGFuIGFjdGl2aXR5IHRoYXQgZG9lc24ndCBleGlzdCwgYCArXG4gICAgICAgICAgICAgICAgICBgcmV0cnlpbmcgd2l0aCAnLiR7c3RhcnRBcHBPcHRpb25zLmFjdGl2aXR5fScgYWN0aXZpdHkgbmFtZWApO1xuICAgICAgICBzdGFydEFwcE9wdGlvbnMuYWN0aXZpdHkgPSBgLiR7c3RhcnRBcHBPcHRpb25zLmFjdGl2aXR5fWA7XG4gICAgICAgIHN0YXJ0QXBwT3B0aW9ucy5yZXRyeSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zdGFydEFwcChzdGFydEFwcE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3Rpdml0eSBuYW1lICcke3N0YXJ0QXBwT3B0aW9ucy5hY3Rpdml0eX0nIHVzZWQgdG8gc3RhcnQgdGhlIGFwcCBkb2Vzbid0IGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBleGlzdCBvciBjYW5ub3QgYmUgbGF1bmNoZWQhIE1ha2Ugc3VyZSBpdCBleGlzdHMgYW5kIGlzIGEgbGF1bmNoYWJsZSBhY3Rpdml0eWApO1xuICAgIH0gZWxzZSBpZiAoc3Rkb3V0LmluY2x1ZGVzKCdFcnJvcjogSW50ZW50IGRvZXMgbm90IG1hdGNoIGFueSBhY3Rpdml0aWVzJykgfHwgc3Rkb3V0LmluY2x1ZGVzKCdFcnJvcjogQWN0aXZpdHkgbm90IHN0YXJ0ZWQsIHVuYWJsZSB0byByZXNvbHZlIEludGVudCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdGl2aXR5IGZvciBpbnRlbnQgJyR7aW50ZW50TmFtZX0nIHVzZWQgdG8gc3RhcnQgdGhlIGFwcCBkb2Vzbid0IGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBleGlzdCBvciBjYW5ub3QgYmUgbGF1bmNoZWQhIE1ha2Ugc3VyZSBpdCBleGlzdHMgYW5kIGlzIGEgbGF1bmNoYWJsZSBhY3Rpdml0eWApO1xuICAgIH0gZWxzZSBpZiAoc3Rkb3V0LmluY2x1ZGVzKCdqYXZhLmxhbmcuU2VjdXJpdHlFeGNlcHRpb24nKSkge1xuICAgICAgLy8gaWYgdGhlIGFwcCBpcyBkaXNhYmxlZCBvbiBhIHJlYWwgZGV2aWNlIGl0IHdpbGwgdGhyb3cgYSBzZWN1cml0eSBleGNlcHRpb25cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHBlcm1pc3Npb24gdG8gc3RhcnQgJyR7c3RhcnRBcHBPcHRpb25zLmFjdGl2aXR5fScgYWN0aXZpdHkgaGFzIGJlZW4gZGVuaWVkLmAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBNYWtlIHN1cmUgdGhlIGFjdGl2aXR5L3BhY2thZ2UgbmFtZXMgYXJlIGNvcnJlY3QuYCk7XG4gICAgfVxuICAgIGlmIChzdGFydEFwcE9wdGlvbnMud2FpdEFjdGl2aXR5KSB7XG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JBY3Rpdml0eShzdGFydEFwcE9wdGlvbnMud2FpdFBrZywgc3RhcnRBcHBPcHRpb25zLndhaXRBY3Rpdml0eSwgc3RhcnRBcHBPcHRpb25zLndhaXREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBzdGRvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zdCBhcHBEZXNjcmlwdG9yID0gc3RhcnRBcHBPcHRpb25zLnBrZyB8fCBpbnRlbnROYW1lO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN0YXJ0IHRoZSAnJHthcHBEZXNjcmlwdG9yfScgYXBwbGljYXRpb24uIGAgK1xuICAgICAgYFZpc2l0ICR7QUNUSVZJVElFU19UUk9VQkxFU0hPT1RJTkdfTElOS30gZm9yIHRyb3VibGVzaG9vdGluZy4gYCArXG4gICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gY2FsbCBgYWRiIGR1bXBzeXMgd2luZG93IHdpbmRvd3MvZGlzcGxheXNgXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5kdW1wV2luZG93cyA9IGFzeW5jIGZ1bmN0aW9uIGR1bXBXaW5kb3dzICgpIHtcbiAgY29uc3QgYXBpTGV2ZWwgPSBhd2FpdCB0aGlzLmdldEFwaUxldmVsKCk7XG5cbiAgLy8gV2l0aCB2ZXJzaW9uIDI5LCBBbmRyb2lkIGNoYW5nZWQgdGhlIGR1bXBzeXMgc3ludGF4XG4gIGNvbnN0IGR1bXBzeXNBcmcgPSBhcGlMZXZlbCA+PSAyOSA/ICdkaXNwbGF5cycgOiAnd2luZG93cyc7XG4gIGNvbnN0IGNtZCA9IFsnZHVtcHN5cycsICd3aW5kb3cnLCBkdW1wc3lzQXJnXTtcblxuICByZXR1cm4gYXdhaXQgdGhpcy5zaGVsbChjbWQpO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYWNrYWdlQWN0aXZpdHlJbmZvXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGFwcFBhY2thZ2UgLSBUaGUgbmFtZSBvZiBhcHBsaWNhdGlvbiBwYWNrYWdlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUgJ2NvbS5hY21lLmFwcCcuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGFwcEFjdGl2aXR5IC0gVGhlIG5hbWUgb2YgbWFpbiBhcHBsaWNhdGlvbiBhY3Rpdml0eS5cbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiBjdXJyZW50bHkgZm9jdXNlZCBwYWNrYWdlIGFuZCBhY3Rpdml0eS5cbiAqXG4gKiBAcmV0dXJuIHtQYWNrYWdlQWN0aXZpdHlJbmZvfSBUaGUgbWFwcGluZywgd2hlcmUgcHJvcGVydHkgbmFtZXMgYXJlICdhcHBQYWNrYWdlJyBhbmQgJ2FwcEFjdGl2aXR5Jy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbiBlcnJvciB3aGlsZSBwYXJzaW5nIHRoZSBkYXRhLlxuICovXG5hcGtVdGlsc01ldGhvZHMuZ2V0Rm9jdXNlZFBhY2thZ2VBbmRBY3Rpdml0eSA9IGFzeW5jIGZ1bmN0aW9uIGdldEZvY3VzZWRQYWNrYWdlQW5kQWN0aXZpdHkgKCkge1xuICBsb2cuZGVidWcoJ0dldHRpbmcgZm9jdXNlZCBwYWNrYWdlIGFuZCBhY3Rpdml0eScpO1xuICBjb25zdCBudWxsRm9jdXNlZEFwcFJlID0gbmV3IFJlZ0V4cCgvXlxccyptRm9jdXNlZEFwcD1udWxsLywgJ20nKTtcbiAgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20vci94Wjh2RjcvMVxuICBjb25zdCBmb2N1c2VkQXBwUmUgPSBuZXcgUmVnRXhwKCdeXFxcXHMqbUZvY3VzZWRBcHAuK1JlY29yZFxcXFx7LipcXFxccyhbXlxcXFxzXFxcXC9cXFxcfV0rKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcLyhbXlxcXFxzXFxcXC9cXFxcfVxcXFwsXSspXFxcXCw/KFxcXFxzW15cXFxcc1xcXFwvXFxcXH1dKykqXFxcXH0nLCAnbScpO1xuICBjb25zdCBudWxsQ3VycmVudEZvY3VzUmUgPSBuZXcgUmVnRXhwKC9eXFxzKm1DdXJyZW50Rm9jdXM9bnVsbC8sICdtJyk7XG4gIGNvbnN0IGN1cnJlbnRGb2N1c0FwcFJlID0gbmV3IFJlZ0V4cCgnXlxcXFxzKm1DdXJyZW50Rm9jdXMuK1xcXFx7LitcXFxccyhbXlxcXFxzXFxcXC9dKylcXFxcLyhbXlxcXFxzXSspXFxcXGInLCAnbScpO1xuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3Rkb3V0ID0gYXdhaXQgdGhpcy5kdW1wV2luZG93cygpO1xuICAgIC8vIFRoZSBvcmRlciBtYXR0ZXJzIGhlcmVcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgW2ZvY3VzZWRBcHBSZSwgY3VycmVudEZvY3VzQXBwUmVdKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdGRvdXQpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXBwUGFja2FnZTogbWF0Y2hbMV0udHJpbSgpLFxuICAgICAgICAgIGFwcEFjdGl2aXR5OiBtYXRjaFsyXS50cmltKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgW251bGxGb2N1c2VkQXBwUmUsIG51bGxDdXJyZW50Rm9jdXNSZV0pIHtcbiAgICAgIGlmIChwYXR0ZXJuLmV4ZWMoc3Rkb3V0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFwcFBhY2thZ2U6IG51bGwsXG4gICAgICAgICAgYXBwQWN0aXZpdHk6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBhY3Rpdml0eSBmcm9tIGR1bXBzeXMnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCBmb2N1c1BhY2thZ2VBbmRBY3Rpdml0eS4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFdhaXQgZm9yIHRoZSBnaXZlbiBhY3Rpdml0eSB0byBiZSBmb2N1c2VkL25vbi1mb2N1c2VkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byB3YWl0IGZvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpdml0eSAtIFRoZSBuYW1lIG9mIHRoZSBhY3Rpdml0eSwgYmVsb25naW5nIHRvIHRoYXQgcGFja2FnZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHdhaXQgZm9yLlxuICogQHBhcmFtIHtib29sZWFufSB3YWl0Rm9yU3RvcCAtIFdoZXRoZXIgdG8gd2FpdCB1bnRpbCB0aGUgYWN0aXZpdHkgaXMgZm9jdXNlZCAodHJ1ZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBpcyBub3QgZm9jdXNlZCAoZmFsc2UpLlxuICogQHBhcmFtIHtudW1iZXJ9IHdhaXRNcyBbMjAwMDBdIC0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSB0aW1lb3V0IG9jY3Vycy5cbiAqIEB0aHJvd3Mge2Vycm9yfSBJZiB0aW1lb3V0IGhhcHBlbnMuXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy53YWl0Rm9yQWN0aXZpdHlPck5vdCA9IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JBY3Rpdml0eU9yTm90IChwa2csIGFjdGl2aXR5LCB3YWl0Rm9yU3RvcCwgd2FpdE1zID0gMjAwMDApIHtcbiAgaWYgKCFwa2cgfHwgIWFjdGl2aXR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrYWdlIGFuZCBhY3Rpdml0eSByZXF1aXJlZC4nKTtcbiAgfVxuICBsb2cuZGVidWcoYFdhaXRpbmcgdXAgdG8gJHt3YWl0TXN9bXMgZm9yIGFjdGl2aXR5IG1hdGNoaW5nIHBrZzogJyR7cGtnfScgYW5kIGAgK1xuICAgICAgICAgICAgYGFjdGl2aXR5OiAnJHthY3Rpdml0eX0nIHRvJHt3YWl0Rm9yU3RvcCA/ICcgbm90JyA6ICcnfSBiZSBmb2N1c2VkYCk7XG5cbiAgY29uc3Qgc3BsaXROYW1lcyA9IChuYW1lcykgPT4gbmFtZXMuc3BsaXQoJywnKS5tYXAoKG5hbWUpID0+IG5hbWUudHJpbSgpKTtcbiAgY29uc3QgYWxsUGFja2FnZXMgPSBzcGxpdE5hbWVzKHBrZyk7XG4gIGNvbnN0IGFsbEFjdGl2aXRpZXMgPSBzcGxpdE5hbWVzKGFjdGl2aXR5KTtcblxuICBjb25zdCBwb3NzaWJsZUFjdGl2aXR5TmFtZXMgPSBbXTtcbiAgZm9yIChjb25zdCBvbmVBY3Rpdml0eSBvZiBhbGxBY3Rpdml0aWVzKSB7XG4gICAgaWYgKG9uZUFjdGl2aXR5LnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgLy8gYWRkIHRoZSBwYWNrYWdlIG5hbWUgaWYgYWN0aXZpdHkgaXMgbm90IGZ1bGwgcXVhbGlmaWVkXG4gICAgICBmb3IgKGNvbnN0IGN1cnJlbnRQa2cgb2YgYWxsUGFja2FnZXMpIHtcbiAgICAgICAgcG9zc2libGVBY3Rpdml0eU5hbWVzLnB1c2goYCR7Y3VycmVudFBrZ30ke29uZUFjdGl2aXR5fWAucmVwbGFjZSgvXFwuKy9nLCAnLicpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWNjZXB0IGZ1bGx5IHF1YWxpZmllZCBhY3Rpdml0eSBuYW1lLlxuICAgICAgcG9zc2libGVBY3Rpdml0eU5hbWVzLnB1c2gob25lQWN0aXZpdHkpO1xuICAgICAgcG9zc2libGVBY3Rpdml0eU5hbWVzLnB1c2goYCR7cGtnfS4ke29uZUFjdGl2aXR5fWApO1xuICAgIH1cbiAgfVxuICBsb2cuZGVidWcoYFBvc3NpYmxlIGFjdGl2aXRpZXMsIHRvIGJlIGNoZWNrZWQ6ICR7cG9zc2libGVBY3Rpdml0eU5hbWVzLm1hcCgobmFtZSkgPT4gYCcke25hbWV9J2ApLmpvaW4oJywgJyl9YCk7XG5cbiAgY29uc3QgcG9zc2libGVBY3Rpdml0eVBhdHRlcm5zID0gcG9zc2libGVBY3Rpdml0eU5hbWVzLm1hcChcbiAgICAoYWN0TmFtZSkgPT4gbmV3IFJlZ0V4cChgXiR7YWN0TmFtZS5yZXBsYWNlKC9cXC4vZywgJ1xcXFwuJykucmVwbGFjZSgvXFwqL2csICcuKj8nKS5yZXBsYWNlKC9cXCQvZywgJ1xcXFwkJyl9JGApXG4gICk7XG5cbiAgY29uc3QgY29uZGl0aW9uRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICBsZXQgYXBwUGFja2FnZTtcbiAgICBsZXQgYXBwQWN0aXZpdHk7XG4gICAgdHJ5IHtcbiAgICAgICh7YXBwUGFja2FnZSwgYXBwQWN0aXZpdHl9ID0gYXdhaXQgdGhpcy5nZXRGb2N1c2VkUGFja2FnZUFuZEFjdGl2aXR5KCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy5kZWJ1ZyhlLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYXBwQWN0aXZpdHkgJiYgYXBwUGFja2FnZSkge1xuICAgICAgY29uc3QgZnVsbHlRdWFsaWZpZWRBY3Rpdml0eSA9IGFwcEFjdGl2aXR5LnN0YXJ0c1dpdGgoJy4nKSA/IGAke2FwcFBhY2thZ2V9JHthcHBBY3Rpdml0eX1gIDogYXBwQWN0aXZpdHk7XG4gICAgICBsb2cuZGVidWcoYEZvdW5kIHBhY2thZ2U6ICcke2FwcFBhY2thZ2V9JyBhbmQgZnVsbHkgcXVhbGlmaWVkIGFjdGl2aXR5IG5hbWUgOiAnJHtmdWxseVF1YWxpZmllZEFjdGl2aXR5fSdgKTtcbiAgICAgIGNvbnN0IGlzQWN0aXZpdHlGb3VuZCA9IF8uaW5jbHVkZXMoYWxsUGFja2FnZXMsIGFwcFBhY2thZ2UpXG4gICAgICAgICYmIHBvc3NpYmxlQWN0aXZpdHlQYXR0ZXJucy5zb21lKChwKSA9PiBwLnRlc3QoZnVsbHlRdWFsaWZpZWRBY3Rpdml0eSkpO1xuICAgICAgaWYgKCghd2FpdEZvclN0b3AgJiYgaXNBY3Rpdml0eUZvdW5kKSB8fCAod2FpdEZvclN0b3AgJiYgIWlzQWN0aXZpdHlGb3VuZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZygnSW5jb3JyZWN0IHBhY2thZ2UgYW5kIGFjdGl2aXR5LiBSZXRyeWluZy4nKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGNvbmRpdGlvbkZ1bmMsIHtcbiAgICAgIHdhaXRNczogcGFyc2VJbnQod2FpdE1zLCAxMCksXG4gICAgICBpbnRlcnZhbE1zOiA1MDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cG9zc2libGVBY3Rpdml0eU5hbWVzLm1hcCgobmFtZSkgPT4gYCcke25hbWV9J2ApLmpvaW4oJyBvciAnKX0gbmV2ZXIgJHt3YWl0Rm9yU3RvcCA/ICdzdG9wcGVkJyA6ICdzdGFydGVkJ30uIGAgK1xuICAgICAgYFZpc2l0ICR7QUNUSVZJVElFU19UUk9VQkxFU0hPT1RJTkdfTElOS30gZm9yIHRyb3VibGVzaG9vdGluZ2ApO1xuICB9XG59O1xuXG4vKipcbiAqIFdhaXQgZm9yIHRoZSBnaXZlbiBhY3Rpdml0eSB0byBiZSBmb2N1c2VkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIHdhaXQgZm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGl2aXR5IC0gVGhlIG5hbWUgb2YgdGhlIGFjdGl2aXR5LCBiZWxvbmdpbmcgdG8gdGhhdCBwYWNrYWdlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gd2FpdCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gd2FpdE1zIFsyMDAwMF0gLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHRpbWVvdXQgb2NjdXJzLlxuICogQHRocm93cyB7ZXJyb3J9IElmIHRpbWVvdXQgaGFwcGVucy5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLndhaXRGb3JBY3Rpdml0eSA9IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JBY3Rpdml0eSAocGtnLCBhY3QsIHdhaXRNcyA9IDIwMDAwKSB7XG4gIGF3YWl0IHRoaXMud2FpdEZvckFjdGl2aXR5T3JOb3QocGtnLCBhY3QsIGZhbHNlLCB3YWl0TXMpO1xufTtcblxuLyoqXG4gKiBXYWl0IGZvciB0aGUgZ2l2ZW4gYWN0aXZpdHkgdG8gYmUgbm9uLWZvY3VzZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIHdhaXQgZm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGl2aXR5IC0gVGhlIG5hbWUgb2YgdGhlIGFjdGl2aXR5LCBiZWxvbmdpbmcgdG8gdGhhdCBwYWNrYWdlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gd2FpdCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gd2FpdE1zIFsyMDAwMF0gLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHRpbWVvdXQgb2NjdXJzLlxuICogQHRocm93cyB7ZXJyb3J9IElmIHRpbWVvdXQgaGFwcGVucy5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLndhaXRGb3JOb3RBY3Rpdml0eSA9IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JOb3RBY3Rpdml0eSAocGtnLCBhY3QsIHdhaXRNcyA9IDIwMDAwKSB7XG4gIGF3YWl0IHRoaXMud2FpdEZvckFjdGl2aXR5T3JOb3QocGtnLCBhY3QsIHRydWUsIHdhaXRNcyk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVuaW5zdGFsbE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lb3V0IFthZGJFeGVjVGltZW91dF0gLSBUaGUgY291bnQgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgdW50aWwgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwIGlzIHVuaW5zdGFsbGVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBrZWVwRGF0YSBbZmFsc2VdIC0gU2V0IHRvIHRydWUgaW4gb3JkZXIgdG8ga2VlcCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIGRhdGEgYW5kIGNhY2hlIGZvbGRlcnMgYWZ0ZXIgdW5pbnN0YWxsLlxuICovXG5cbi8qKlxuICogVW5pbnN0YWxsIHRoZSBnaXZlbiBwYWNrYWdlIGZyb20gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBiZSB1bmluc3RhbGxlZC5cbiAqIEBwYXJhbSB7P1VuaW5zdGFsbE9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgc2V0IG9mIHVuaW5zdGFsbCBvcHRpb25zLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFja2FnZSB3YXMgZm91bmQgb24gdGhlIGRldmljZSBhbmRcbiAqICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NmdWxseSB1bmluc3RhbGxlZC5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLnVuaW5zdGFsbEFwayA9IGFzeW5jIGZ1bmN0aW9uIHVuaW5zdGFsbEFwayAocGtnLCBvcHRpb25zID0ge30pIHtcbiAgbG9nLmRlYnVnKGBVbmluc3RhbGxpbmcgJHtwa2d9YCk7XG4gIGlmICghYXdhaXQgdGhpcy5pc0FwcEluc3RhbGxlZChwa2cpKSB7XG4gICAgbG9nLmluZm8oYCR7cGtnfSB3YXMgbm90IHVuaW5zdGFsbGVkLCBiZWNhdXNlIGl0IHdhcyBub3QgcHJlc2VudCBvbiB0aGUgZGV2aWNlYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgY21kID0gWyd1bmluc3RhbGwnXTtcbiAgaWYgKG9wdGlvbnMua2VlcERhdGEpIHtcbiAgICBjbWQucHVzaCgnLWsnKTtcbiAgfVxuICBjbWQucHVzaChwa2cpO1xuXG4gIGxldCBzdGRvdXQ7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5mb3JjZVN0b3AocGtnKTtcbiAgICBzdGRvdXQgPSAoYXdhaXQgdGhpcy5hZGJFeGVjKGNtZCwge3RpbWVvdXQ6IG9wdGlvbnMudGltZW91dH0pKS50cmltKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byB1bmluc3RhbGwgQVBLLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbiAgbG9nLmRlYnVnKGAnYWRiICR7Y21kLmpvaW4oJyAnKX0nIGNvbW1hbmQgb3V0cHV0OiAke3N0ZG91dH1gKTtcbiAgaWYgKHN0ZG91dC5pbmNsdWRlcygnU3VjY2VzcycpKSB7XG4gICAgbG9nLmluZm8oYCR7cGtnfSB3YXMgc3VjY2Vzc2Z1bGx5IHVuaW5zdGFsbGVkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbG9nLmluZm8oYCR7cGtnfSB3YXMgbm90IHVuaW5zdGFsbGVkYCk7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSW5zdGFsbCB0aGUgcGFja2FnZSBhZnRlciBpdCB3YXMgcHVzaGVkIHRvIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrUGF0aE9uRGV2aWNlIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgcGFja2FnZSBvbiB0aGUgZGV2aWNlIGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdHMgW3t9XSAtIEFkZGl0aW9uYWwgZXhlYyBvcHRpb25zLiBTZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS10ZWVuX3Byb2Nlc3N9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIHBhcmFtZXRlci5cbiAqIEB0aHJvd3Mge2Vycm9yfSBJZiB0aGVyZSB3YXMgYSBmYWlsdXJlIGR1cmluZyBhcHBsaWNhdGlvbiBpbnN0YWxsLlxuICovXG5hcGtVdGlsc01ldGhvZHMuaW5zdGFsbEZyb21EZXZpY2VQYXRoID0gYXN5bmMgZnVuY3Rpb24gaW5zdGFsbEZyb21EZXZpY2VQYXRoIChhcGtQYXRoT25EZXZpY2UsIG9wdHMgPSB7fSkge1xuICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbJ3BtJywgJ2luc3RhbGwnLCAnLXInLCBhcGtQYXRoT25EZXZpY2VdLCBvcHRzKTtcbiAgaWYgKHN0ZG91dC5pbmRleE9mKCdGYWlsdXJlJykgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSZW1vdGUgaW5zdGFsbCBmYWlsZWQ6ICR7c3Rkb3V0fWApO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhY2hpbmdPcHRpb25zXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IHRpbWVvdXQgW2FkYkV4ZWNUaW1lb3V0XSAtIFRoZSBjb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB1bnRpbCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwIGlzIHVwbG9hZGVkIHRvIHRoZSByZW1vdGUgbG9jYXRpb24uXG4gKi9cblxuLyoqXG4gKiBDYWNoZXMgdGhlIGdpdmVuIEFQSyBhdCBhIHJlbW90ZSBsb2NhdGlvbiB0byBzcGVlZCB1cCBmdXJ0aGVyIEFQSyBkZXBsb3ltZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrUGF0aCAtIEZ1bGwgcGF0aCB0byB0aGUgYXBrIG9uIHRoZSBsb2NhbCBGU1xuICogQHBhcmFtIHs/Q2FjaGluZ09wdGlvbnN9IG9wdGlvbnMgLSBDYWNoaW5nIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRnVsbCBwYXRoIHRvIHRoZSBjYWNoZWQgYXBrIG9uIHRoZSByZW1vdGUgZmlsZSBzeXN0ZW1cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSB3YXMgYSBmYWlsdXJlIHdoaWxlIGNhY2hpbmcgdGhlIGFwcFxuICovXG5hcGtVdGlsc01ldGhvZHMuY2FjaGVBcGsgPSBhc3luYyBmdW5jdGlvbiBjYWNoZUFwayAoYXBrUGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGFwcEhhc2ggPSBhd2FpdCBmcy5oYXNoKGFwa1BhdGgpO1xuICBjb25zdCByZW1vdGVQYXRoID0gcGF0aC5wb3NpeC5qb2luKFJFTU9URV9DQUNIRV9ST09ULCBgJHthcHBIYXNofS5hcGtgKTtcbiAgY29uc3QgcmVtb3RlQ2FjaGVkRmlsZXMgPSBbXTtcbiAgLy8gR2V0IGN1cnJlbnQgY29udGVudHMgb2YgdGhlIHJlbW90ZSBjYWNoZSBvciBjcmVhdGUgaXQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gIHRyeSB7XG4gICAgY29uc3QgZXJyb3JNYXJrZXIgPSAnX0VSUk9SXyc7XG4gICAgbGV0IGxzT3V0cHV0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fYXJlRXh0ZW5kZWRMc09wdGlvbnNTdXBwb3J0ZWQgPT09IHRydWUgfHwgIV8uaXNCb29sZWFuKHRoaXMuX2FyZUV4dGVuZGVkTHNPcHRpb25zU3VwcG9ydGVkKSkge1xuICAgICAgbHNPdXRwdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFtgbHMgLXQgLTEgJHtSRU1PVEVfQ0FDSEVfUk9PVH0gMj4mMSB8fCBlY2hvICR7ZXJyb3JNYXJrZXJ9YF0pO1xuICAgIH1cbiAgICBpZiAoIV8uaXNTdHJpbmcobHNPdXRwdXQpIHx8IChsc091dHB1dC5pbmNsdWRlcyhlcnJvck1hcmtlcikgJiYgIWxzT3V0cHV0LmluY2x1ZGVzKFJFTU9URV9DQUNIRV9ST09UKSkpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4odGhpcy5fYXJlRXh0ZW5kZWRMc09wdGlvbnNTdXBwb3J0ZWQpKSB7XG4gICAgICAgIGxvZy5kZWJ1ZygnVGhlIGN1cnJlbnQgQW5kcm9pZCBBUEkgZG9lcyBub3Qgc3VwcG9ydCBleHRlbmRlZCBscyBvcHRpb25zLiAnICtcbiAgICAgICAgICAnRGVmYXVsdGluZyB0byBuby1vcHRpb25zIGNhbGwnKTtcbiAgICAgIH1cbiAgICAgIGxzT3V0cHV0ID0gYXdhaXQgdGhpcy5zaGVsbChbYGxzICR7UkVNT1RFX0NBQ0hFX1JPT1R9IDI+JjEgfHwgZWNobyAke2Vycm9yTWFya2VyfWBdKTtcbiAgICAgIHRoaXMuX2FyZUV4dGVuZGVkTHNPcHRpb25zU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FyZUV4dGVuZGVkTHNPcHRpb25zU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxzT3V0cHV0LmluY2x1ZGVzKGVycm9yTWFya2VyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGxzT3V0cHV0LnN1YnN0cmluZygwLCBsc091dHB1dC5pbmRleE9mKGVycm9yTWFya2VyKSkpO1xuICAgIH1cbiAgICByZW1vdGVDYWNoZWRGaWxlcy5wdXNoKC4uLihcbiAgICAgIGxzT3V0cHV0LnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKCh4KSA9PiB4LnRyaW0oKSlcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGBHb3QgYW4gZXJyb3IgJyR7ZS5tZXNzYWdlLnRyaW0oKX0nIHdoaWxlIGdldHRpbmcgdGhlIGxpc3Qgb2YgZmlsZXMgaW4gdGhlIGNhY2hlLiBgICtcbiAgICAgIGBBc3N1bWluZyB0aGUgY2FjaGUgZG9lcyBub3QgZXhpc3QgeWV0YCk7XG4gICAgYXdhaXQgdGhpcy5zaGVsbChbJ21rZGlyJywgJy1wJywgUkVNT1RFX0NBQ0hFX1JPT1RdKTtcbiAgfVxuICBsb2cuZGVidWcoYFRoZSBjb3VudCBvZiBhcHBsaWNhdGlvbnMgaW4gdGhlIGNhY2hlOiAke3JlbW90ZUNhY2hlZEZpbGVzLmxlbmd0aH1gKTtcbiAgY29uc3QgdG9IYXNoID0gKHJlbW90ZVBhdGgpID0+IHBhdGgucG9zaXgucGFyc2UocmVtb3RlUGF0aCkubmFtZTtcbiAgLy8gUHVzaCB0aGUgYXBrIHRvIHRoZSByZW1vdGUgY2FjaGUgaWYgbmVlZGVkXG4gIGlmIChyZW1vdGVDYWNoZWRGaWxlcy5zb21lKCh4KSA9PiB0b0hhc2goeCkgPT09IGFwcEhhc2gpKSB7XG4gICAgbG9nLmluZm8oYFRoZSBhcHBsaWNhdGlvbiBhdCAnJHthcGtQYXRofScgaXMgYWxyZWFkeSBjYWNoZWQgdG8gJyR7cmVtb3RlUGF0aH0nYCk7XG4gICAgLy8gVXBkYXRlIHRoZSBhcHBsaWNhdGlvbiB0aW1lc3RhbXAgYXN5bmNocm9ub3VzbHkgaW4gb3JkZXIgdG8gYnVtcCBpdHMgcG9zaXRpb25cbiAgICAvLyBpbiB0aGUgc29ydGVkIGxzIG91dHB1dFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG4gICAgdGhpcy5zaGVsbChbJ3RvdWNoJywgJy1hbScsIHJlbW90ZVBhdGhdKS5jYXRjaCgoKSA9PiB7fSk7XG4gIH0gZWxzZSB7XG4gICAgbG9nLmluZm8oYENhY2hpbmcgdGhlIGFwcGxpY2F0aW9uIGF0ICcke2Fwa1BhdGh9JyB0byAnJHtyZW1vdGVQYXRofSdgKTtcbiAgICBjb25zdCB0aW1lciA9IG5ldyB0aW1pbmcuVGltZXIoKS5zdGFydCgpO1xuICAgIGF3YWl0IHRoaXMucHVzaChhcGtQYXRoLCByZW1vdGVQYXRoLCB7dGltZW91dDogb3B0aW9ucy50aW1lb3V0fSk7XG4gICAgY29uc3Qge3NpemV9ID0gYXdhaXQgZnMuc3RhdChhcGtQYXRoKTtcbiAgICBsb2cuaW5mbyhgVGhlIHVwbG9hZCBvZiAnJHtwYXRoLmJhc2VuYW1lKGFwa1BhdGgpfScgKCR7dXRpbC50b1JlYWRhYmxlU2l6ZVN0cmluZyhzaXplKX0pIGAgK1xuICAgICAgYHRvb2sgJHt0aW1lci5nZXREdXJhdGlvbigpLmFzTWlsbGlTZWNvbmRzLnRvRml4ZWQoMCl9bXNgKTtcbiAgfVxuICBpZiAoIXRoaXMucmVtb3RlQXBwc0NhY2hlKSB7XG4gICAgdGhpcy5yZW1vdGVBcHBzQ2FjaGUgPSBuZXcgTFJVKHtcbiAgICAgIG1heDogdGhpcy5yZW1vdGVBcHBzQ2FjaGVMaW1pdCxcbiAgICB9KTtcbiAgfVxuICAvLyBDbGVhbnVwIHRoZSBpbnZhbGlkIGVudHJpZXMgZnJvbSB0aGUgY2FjaGVcbiAgXy5kaWZmZXJlbmNlKFsuLi50aGlzLnJlbW90ZUFwcHNDYWNoZS5rZXlzKCldLCByZW1vdGVDYWNoZWRGaWxlcy5tYXAodG9IYXNoKSlcbiAgICAuZm9yRWFjaCgoaGFzaCkgPT4gdGhpcy5yZW1vdGVBcHBzQ2FjaGUuZGVsKGhhc2gpKTtcbiAgLy8gQnVtcCB0aGUgY2FjaGUgcmVjb3JkIGZvciB0aGUgcmVjZW50bHkgY2FjaGVkIGl0ZW1cbiAgdGhpcy5yZW1vdGVBcHBzQ2FjaGUuc2V0KGFwcEhhc2gsIHJlbW90ZVBhdGgpO1xuICAvLyBJZiB0aGUgcmVtb3RlIGNhY2hlIGV4Y2VlZHMgdGhpcy5yZW1vdGVBcHBzQ2FjaGVMaW1pdCwgcmVtb3ZlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGVudHJpZXNcbiAgY29uc3QgZW50cmllc1RvQ2xlYW51cCA9IHJlbW90ZUNhY2hlZEZpbGVzXG4gICAgLm1hcCgoeCkgPT4gcGF0aC5wb3NpeC5qb2luKFJFTU9URV9DQUNIRV9ST09ULCB4KSlcbiAgICAuZmlsdGVyKCh4KSA9PiAhdGhpcy5yZW1vdGVBcHBzQ2FjaGUuaGFzKHRvSGFzaCh4KSkpXG4gICAgLnNsaWNlKHRoaXMucmVtb3RlQXBwc0NhY2hlTGltaXQgLSBbLi4udGhpcy5yZW1vdGVBcHBzQ2FjaGUua2V5cygpXS5sZW5ndGgpO1xuICBpZiAoIV8uaXNFbXB0eShlbnRyaWVzVG9DbGVhbnVwKSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnNoZWxsKFsncm0nLCAnLWYnLCAuLi5lbnRyaWVzVG9DbGVhbnVwXSk7XG4gICAgICBsb2cuZGVidWcoYERlbGV0ZWQgJHtlbnRyaWVzVG9DbGVhbnVwLmxlbmd0aH0gZXhwaXJlZCBhcHBsaWNhdGlvbiBjYWNoZSBlbnRyaWVzYCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLndhcm4oYENhbm5vdCBkZWxldGUgJHtlbnRyaWVzVG9DbGVhbnVwLmxlbmd0aH0gZXhwaXJlZCBhcHBsaWNhdGlvbiBjYWNoZSBlbnRyaWVzLiBgICtcbiAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbW90ZVBhdGg7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEluc3RhbGxPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZW91dCBbNjAwMDBdIC0gVGhlIGNvdW50IG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IHVudGlsIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcCBpcyBpbnN0YWxsZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGltZW91dENhcE5hbWUgW2FuZHJvaWRJbnN0YWxsVGltZW91dF0gLSBUaGUgdGltZW91dCBvcHRpb24gbmFtZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcnMgY2FuIGluY3JlYXNlIHRoZSB0aW1lb3V0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBhbGxvd1Rlc3RQYWNrYWdlcyBbZmFsc2VdIC0gU2V0IHRvIHRydWUgaW4gb3JkZXIgdG8gYWxsb3cgdGVzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZXMgaW5zdGFsbGF0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSB1c2VTZGNhcmQgW2ZhbHNlXSAtIFNldCB0byB0cnVlIHRvIGluc3RhbGwgdGhlIGFwcCBvbiBzZGNhcmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0ZWFkIG9mIHRoZSBkZXZpY2UgbWVtb3J5LlxuICogQHByb3BlcnR5IHtib29sZWFufSBncmFudFBlcm1pc3Npb25zIFtmYWxzZV0gLSBTZXQgdG8gdHJ1ZSBpbiBvcmRlciB0byBncmFudCBhbGwgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zIHJlcXVlc3RlZCBpbiB0aGUgYXBwbGljYXRpb24ncyBtYW5pZmVzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGFmdGVyIHRoZSBpbnN0YWxsYXRpb24gaXMgY29tcGxldGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVyIEFuZHJvaWQgNisuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlcGxhY2UgW3RydWVdIC0gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGFwcGxpY2F0aW9uIHRvIGJlIHVwZ3JhZGVkL3JlaW5zdGFsbGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgaXQgaXMgYWxyZWFkeSBwcmVzZW50IG9uIHRoZSBkZXZpY2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG5vSW5jcmVtZW50YWwgW2ZhbHNlXSAtIEZvcmNlZnVsbHkgZGlzYWJsZXMgaW5jcmVtZW50YWwgaW5zdGFsbHMgaWYgc2V0IHRvIGB0cnVlYC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZCBodHRwczovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9wcmV2aWV3L2ZlYXR1cmVzI2luY3JlbWVudGFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cblxuLyoqXG4gKiBJbnN0YWxsIHRoZSBwYWNrYWdlIGZyb20gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBQYXRoIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgbG9jYWwgcGFja2FnZS5cbiAqIEBwYXJhbSB7P0luc3RhbGxPcHRpb25zfSBvcHRpb25zIC0gVGhlIHNldCBvZiBpbnN0YWxsYXRpb24gb3B0aW9ucy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbiB1bmV4cGVjdGVkIGVycm9yIGhhcHBlbnMgZHVyaW5nIGluc3RhbGwuXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5pbnN0YWxsID0gYXN5bmMgZnVuY3Rpb24gaW5zdGFsbCAoYXBwUGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmIChhcHBQYXRoLmVuZHNXaXRoKEFQS1NfRVhURU5TSU9OKSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmluc3RhbGxBcGtzKGFwcFBhdGgsIG9wdGlvbnMpO1xuICB9XG5cbiAgb3B0aW9ucyA9IF8uY2xvbmVEZWVwKG9wdGlvbnMpO1xuICBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRpbWVvdXQ6IHRoaXMuYWRiRXhlY1RpbWVvdXQgPT09IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVCA/IEFQS19JTlNUQUxMX1RJTUVPVVQgOiB0aGlzLmFkYkV4ZWNUaW1lb3V0LFxuICAgIHRpbWVvdXRDYXBOYW1lOiAnYW5kcm9pZEluc3RhbGxUaW1lb3V0JyxcbiAgfSk7XG5cbiAgY29uc3QgaW5zdGFsbEFyZ3MgPSBidWlsZEluc3RhbGxBcmdzKGF3YWl0IHRoaXMuZ2V0QXBpTGV2ZWwoKSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLm5vSW5jcmVtZW50YWwgJiYgYXdhaXQgdGhpcy5pc0luY3JlbWVudGFsSW5zdGFsbFN1cHBvcnRlZCgpKSB7XG4gICAgLy8gQWRiIHRocm93cyBhbiBlcnJvciBpZiBpdCBkb2VzIG5vdCBrbm93IGFib3V0IGFuIGFyZyxcbiAgICAvLyB3aGljaCBpcyB0aGUgY2FzZSBoZXJlIGZvciBvbGRlciBhZGIgdmVyc2lvbnMuXG4gICAgaW5zdGFsbEFyZ3MucHVzaCgnLS1uby1pbmNyZW1lbnRhbCcpO1xuICB9XG4gIGNvbnN0IGluc3RhbGxPcHRzID0ge1xuICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCxcbiAgICB0aW1lb3V0Q2FwTmFtZTogb3B0aW9ucy50aW1lb3V0Q2FwTmFtZSxcbiAgfTtcbiAgY29uc3QgaW5zdGFsbENtZCA9IFtcbiAgICAnaW5zdGFsbCcsXG4gICAgLi4uaW5zdGFsbEFyZ3MsXG4gICAgYXBwUGF0aCxcbiAgXTtcbiAgbGV0IHBlcmZvcm1BcHBJbnN0YWxsID0gYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5hZGJFeGVjKGluc3RhbGxDbWQsIGluc3RhbGxPcHRzKTtcbiAgLy8gdGhpcy5yZW1vdGVBcHBzQ2FjaGVMaW1pdCA8PSAwIG1lYW5zIG5vIGNhY2hpbmcgc2hvdWxkIGJlIGFwcGxpZWRcbiAgbGV0IHNob3VsZENhY2hlQXBwID0gdGhpcy5yZW1vdGVBcHBzQ2FjaGVMaW1pdCA+IDA7XG4gIGlmIChzaG91bGRDYWNoZUFwcCkge1xuICAgIHNob3VsZENhY2hlQXBwID0gIShhd2FpdCB0aGlzLmlzU3RyZWFtZWRJbnN0YWxsU3VwcG9ydGVkKCkpO1xuICAgIGlmICghc2hvdWxkQ2FjaGVBcHApIHtcbiAgICAgIGxvZy5pbmZvKGBUaGUgYXBwbGljYXRpb24gYXQgJyR7YXBwUGF0aH0nIHdpbGwgbm90IGJlIGNhY2hlZCwgYmVjYXVzZSB0aGUgZGV2aWNlIHVuZGVyIHRlc3QgaGFzIGAgK1xuICAgICAgICBgY29uZmlybWVkIHRoZSBzdXBwb3J0IG9mIHN0cmVhbWVkIGluc3RhbGxzYCk7XG4gICAgfVxuICB9XG4gIGlmIChzaG91bGRDYWNoZUFwcCkge1xuICAgIGNvbnN0IGNsZWFyQ2FjaGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICBsb2cuaW5mbyhgQ2xlYXJpbmcgdGhlIGNhY2hlIGF0ICcke1JFTU9URV9DQUNIRV9ST09UfSdgKTtcbiAgICAgIGF3YWl0IHRoaXMuc2hlbGwoWydybScsICctcmYnLCBgJHtSRU1PVEVfQ0FDSEVfUk9PVH0vKmBdKTtcbiAgICB9O1xuICAgIGNvbnN0IGNhY2hlQXBwID0gYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5jYWNoZUFwayhhcHBQYXRoLCB7XG4gICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhY2hlZEFwcFBhdGggPSBhd2FpdCBjYWNoZUFwcCgpO1xuICAgICAgcGVyZm9ybUFwcEluc3RhbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBtSW5zdGFsbENtZEJ5UmVtb3RlUGF0aCA9IChyZW1vdGVQYXRoKSA9PiBbXG4gICAgICAgICAgJ3BtJywgJ2luc3RhbGwnLFxuICAgICAgICAgIC4uLmluc3RhbGxBcmdzLFxuICAgICAgICAgIHJlbW90ZVBhdGgsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuc2hlbGwocG1JbnN0YWxsQ21kQnlSZW1vdGVQYXRoKGNhY2hlZEFwcFBhdGgpLCBpbnN0YWxsT3B0cyk7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vYXBwaXVtL2lzc3Vlcy8xMzk3MFxuICAgICAgICBpZiAoL1xcYklOU1RBTExfRkFJTEVEX0lOU1VGRklDSUVOVF9TVE9SQUdFXFxiLy50ZXN0KG91dHB1dCkpIHtcbiAgICAgICAgICBsb2cud2FybihgVGhlcmUgd2FzIGEgZmFpbHVyZSB3aGlsZSBpbnN0YWxsaW5nICcke2FwcFBhdGh9JyBgICtcbiAgICAgICAgICAgIGBiZWNhdXNlIG9mIHRoZSBpbnN1ZmZpY2llbnQgZGV2aWNlIHN0b3JhZ2Ugc3BhY2VgKTtcbiAgICAgICAgICBhd2FpdCBjbGVhckNhY2hlKCk7XG4gICAgICAgICAgbG9nLmluZm8oYENvbnNpZGVyIGRlY3JlYXNpbmcgdGhlIG1heGltdW0gYW1vdW50IG9mIGNhY2hlZCBhcHBzIGAgK1xuICAgICAgICAgICAgYChjdXJyZW50bHkgJHt0aGlzLnJlbW90ZUFwcHNDYWNoZUxpbWl0fSkgdG8gYXZvaWQgc3VjaCBpc3N1ZXMgaW4gdGhlIGZ1dHVyZWApO1xuICAgICAgICAgIGNvbnN0IG5ld0NhY2hlZEFwcFBhdGggPSBhd2FpdCBjYWNoZUFwcCgpO1xuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNoZWxsKHBtSW5zdGFsbENtZEJ5UmVtb3RlUGF0aChuZXdDYWNoZWRBcHBQYXRoKSwgaW5zdGFsbE9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy5kZWJ1ZyhlKTtcbiAgICAgIGxvZy53YXJuKGBUaGVyZSB3YXMgYSBmYWlsdXJlIHdoaWxlIGNhY2hpbmcgJyR7YXBwUGF0aH0nOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIGxvZy53YXJuKCdGYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgaW5zdGFsbGF0aW9uIHByb2NlZHVyZScpO1xuICAgICAgYXdhaXQgY2xlYXJDYWNoZSgpO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHRpbWVyID0gbmV3IHRpbWluZy5UaW1lcigpLnN0YXJ0KCk7XG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcGVyZm9ybUFwcEluc3RhbGwoKTtcbiAgICBsb2cuaW5mbyhgVGhlIGluc3RhbGxhdGlvbiBvZiAnJHtwYXRoLmJhc2VuYW1lKGFwcFBhdGgpfScgdG9vayAke3RpbWVyLmdldER1cmF0aW9uKCkuYXNNaWxsaVNlY29uZHMudG9GaXhlZCgwKX1tc2ApO1xuICAgIGNvbnN0IHRydW5jYXRlZE91dHB1dCA9ICghXy5pc1N0cmluZyhvdXRwdXQpIHx8IG91dHB1dC5sZW5ndGggPD0gMzAwKSA/XG4gICAgICBvdXRwdXQgOiBgJHtvdXRwdXQuc3Vic3RyKDAsIDE1MCl9Li4uJHtvdXRwdXQuc3Vic3RyKG91dHB1dC5sZW5ndGggLSAxNTApfWA7XG4gICAgbG9nLmRlYnVnKGBJbnN0YWxsIGNvbW1hbmQgc3Rkb3V0OiAke3RydW5jYXRlZE91dHB1dH1gKTtcbiAgICBpZiAoL1xcW0lOU1RBTExbQS1aX10rRkFJTEVEW0EtWl9dK1xcXS8udGVzdChvdXRwdXQpKSB7XG4gICAgICBpZiAodGhpcy5pc1Rlc3RQYWNrYWdlT25seUVycm9yKG91dHB1dCkpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFNldCAnYWxsb3dUZXN0UGFja2FnZXMnIGNhcGFiaWxpdHkgdG8gdHJ1ZSBpbiBvcmRlciB0byBhbGxvdyB0ZXN0IHBhY2thZ2VzIGluc3RhbGxhdGlvbi5gO1xuICAgICAgICBsb2cud2Fybihtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3V0cHV0fVxcbiR7bXNnfWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKG91dHB1dCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBvbiBzb21lIHN5c3RlbXMgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhcHAgYWxyZWFkeVxuICAgIC8vIGV4aXN0c1xuICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0lOU1RBTExfRkFJTEVEX0FMUkVBRFlfRVhJU1RTJykpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgbG9nLmRlYnVnKGBBcHBsaWNhdGlvbiAnJHthcHBQYXRofScgYWxyZWFkeSBpbnN0YWxsZWQuIENvbnRpbnVpbmcuYCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjdXJyZW50IGluc3RhbGxhdGlvbiBzdGF0ZSBvZiB0aGUgcGFydGljdWxhciBhcHBsaWNhdGlvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBQYXRoIC0gRnVsbCBwYXRoIHRvIHRoZSBhcHBsaWNhdGlvblxuICogQHBhcmFtIHs/c3RyaW5nfSBwa2cgLSBQYWNrYWdlIGlkZW50aWZpZXIuIElmIG9taXR0ZWQgdGhlbiB0aGUgc2NyaXB0IHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHRvIGV4dHJhY3QgaXQgb24gaXRzIG93blxuICogQHJldHVybnMge3N0cmluZ31dT25lIG9mIGBBUFBfSU5TVEFMTF9TVEFURWAgY29uc3RhbnRzXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5nZXRBcHBsaWNhdGlvbkluc3RhbGxTdGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIGdldEFwcGxpY2F0aW9uSW5zdGFsbFN0YXRlIChhcHBQYXRoLCBwa2cgPSBudWxsKSB7XG4gIGxldCBhcGtJbmZvID0gbnVsbDtcbiAgaWYgKCFwa2cpIHtcbiAgICBhcGtJbmZvID0gYXdhaXQgdGhpcy5nZXRBcGtJbmZvKGFwcFBhdGgpO1xuICAgIHBrZyA9IGFwa0luZm8ubmFtZTtcbiAgfVxuICBpZiAoIXBrZykge1xuICAgIGxvZy53YXJuKGBDYW5ub3QgcmVhZCB0aGUgcGFja2FnZSBuYW1lIG9mICcke2FwcFBhdGh9J2ApO1xuICAgIHJldHVybiB0aGlzLkFQUF9JTlNUQUxMX1NUQVRFLlVOS05PV047XG4gIH1cblxuICBpZiAoIWF3YWl0IHRoaXMuaXNBcHBJbnN0YWxsZWQocGtnKSkge1xuICAgIGxvZy5kZWJ1ZyhgQXBwICcke2FwcFBhdGh9JyBpcyBub3QgaW5zdGFsbGVkYCk7XG4gICAgcmV0dXJuIHRoaXMuQVBQX0lOU1RBTExfU1RBVEUuTk9UX0lOU1RBTExFRDtcbiAgfVxuXG4gIGNvbnN0IHt2ZXJzaW9uQ29kZTogcGtnVmVyc2lvbkNvZGUsIHZlcnNpb25OYW1lOiBwa2dWZXJzaW9uTmFtZVN0cn0gPSBhd2FpdCB0aGlzLmdldFBhY2thZ2VJbmZvKHBrZyk7XG4gIGNvbnN0IHBrZ1ZlcnNpb25OYW1lID0gc2VtdmVyLnZhbGlkKHNlbXZlci5jb2VyY2UocGtnVmVyc2lvbk5hbWVTdHIpKTtcbiAgaWYgKCFhcGtJbmZvKSB7XG4gICAgYXBrSW5mbyA9IGF3YWl0IHRoaXMuZ2V0QXBrSW5mbyhhcHBQYXRoKTtcbiAgfVxuICBjb25zdCB7dmVyc2lvbkNvZGU6IGFwa1ZlcnNpb25Db2RlLCB2ZXJzaW9uTmFtZTogYXBrVmVyc2lvbk5hbWVTdHJ9ID0gYXBrSW5mbztcbiAgY29uc3QgYXBrVmVyc2lvbk5hbWUgPSBzZW12ZXIudmFsaWQoc2VtdmVyLmNvZXJjZShhcGtWZXJzaW9uTmFtZVN0cikpO1xuXG4gIGlmICghXy5pc0ludGVnZXIoYXBrVmVyc2lvbkNvZGUpIHx8ICFfLmlzSW50ZWdlcihwa2dWZXJzaW9uQ29kZSkpIHtcbiAgICBsb2cud2FybihgQ2Fubm90IHJlYWQgdmVyc2lvbiBjb2RlcyBvZiAnJHthcHBQYXRofScgYW5kL29yICcke3BrZ30nYCk7XG4gICAgaWYgKCFfLmlzU3RyaW5nKGFwa1ZlcnNpb25OYW1lKSB8fCAhXy5pc1N0cmluZyhwa2dWZXJzaW9uTmFtZSkpIHtcbiAgICAgIGxvZy53YXJuKGBDYW5ub3QgcmVhZCB2ZXJzaW9uIG5hbWVzIG9mICcke2FwcFBhdGh9JyBhbmQvb3IgJyR7cGtnfSdgKTtcbiAgICAgIHJldHVybiB0aGlzLkFQUF9JTlNUQUxMX1NUQVRFLlVOS05PV047XG4gICAgfVxuICB9XG4gIGlmIChfLmlzSW50ZWdlcihhcGtWZXJzaW9uQ29kZSkgJiYgXy5pc0ludGVnZXIocGtnVmVyc2lvbkNvZGUpKSB7XG4gICAgaWYgKHBrZ1ZlcnNpb25Db2RlID4gYXBrVmVyc2lvbkNvZGUpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgVGhlIHZlcnNpb24gY29kZSBvZiB0aGUgaW5zdGFsbGVkICcke3BrZ30nIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYXBwbGljYXRpb24gdmVyc2lvbiBjb2RlICgke3BrZ1ZlcnNpb25Db2RlfSA+ICR7YXBrVmVyc2lvbkNvZGV9KWApO1xuICAgICAgcmV0dXJuIHRoaXMuQVBQX0lOU1RBTExfU1RBVEUuTkVXRVJfVkVSU0lPTl9JTlNUQUxMRUQ7XG4gICAgfVxuICAgIC8vIFZlcnNpb24gY29kZXMgbWlnaHQgbm90IGJlIG1haW50YWluZWQuIENoZWNrIHZlcnNpb24gbmFtZXMuXG4gICAgaWYgKHBrZ1ZlcnNpb25Db2RlID09PSBhcGtWZXJzaW9uQ29kZSkge1xuICAgICAgaWYgKF8uaXNTdHJpbmcoYXBrVmVyc2lvbk5hbWUpICYmIF8uaXNTdHJpbmcocGtnVmVyc2lvbk5hbWUpICYmIHNlbXZlci5zYXRpc2ZpZXMocGtnVmVyc2lvbk5hbWUsIGA+PSR7YXBrVmVyc2lvbk5hbWV9YCkpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBUaGUgdmVyc2lvbiBuYW1lIG9mIHRoZSBpbnN0YWxsZWQgJyR7cGtnfScgaXMgZ3JlYXRlciBvciBlcXVhbCB0byB0aGUgYXBwbGljYXRpb24gdmVyc2lvbiBuYW1lICgnJHtwa2dWZXJzaW9uTmFtZX0nID49ICcke2Fwa1ZlcnNpb25OYW1lfScpYCk7XG4gICAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKHBrZ1ZlcnNpb25OYW1lLCBgPiR7YXBrVmVyc2lvbk5hbWV9YClcbiAgICAgICAgICA/IHRoaXMuQVBQX0lOU1RBTExfU1RBVEUuTkVXRVJfVkVSU0lPTl9JTlNUQUxMRURcbiAgICAgICAgICA6IHRoaXMuQVBQX0lOU1RBTExfU1RBVEUuU0FNRV9WRVJTSU9OX0lOU1RBTExFRDtcbiAgICAgIH1cbiAgICAgIGlmICghXy5pc1N0cmluZyhhcGtWZXJzaW9uTmFtZSkgfHwgIV8uaXNTdHJpbmcocGtnVmVyc2lvbk5hbWUpKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgVGhlIHZlcnNpb24gbmFtZSBvZiB0aGUgaW5zdGFsbGVkICcke3BrZ30nIGlzIGVxdWFsIHRvIGFwcGxpY2F0aW9uIHZlcnNpb24gbmFtZSAoJHtwa2dWZXJzaW9uQ29kZX0gPT09ICR7YXBrVmVyc2lvbkNvZGV9KWApO1xuICAgICAgICByZXR1cm4gdGhpcy5BUFBfSU5TVEFMTF9TVEFURS5TQU1FX1ZFUlNJT05fSU5TVEFMTEVEO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGFwa1ZlcnNpb25OYW1lKSAmJiBfLmlzU3RyaW5nKHBrZ1ZlcnNpb25OYW1lKSAmJiBzZW12ZXIuc2F0aXNmaWVzKHBrZ1ZlcnNpb25OYW1lLCBgPj0ke2Fwa1ZlcnNpb25OYW1lfWApKSB7XG4gICAgbG9nLmRlYnVnKGBUaGUgdmVyc2lvbiBuYW1lIG9mIHRoZSBpbnN0YWxsZWQgJyR7cGtnfScgaXMgZ3JlYXRlciBvciBlcXVhbCB0byB0aGUgYXBwbGljYXRpb24gdmVyc2lvbiBuYW1lICgnJHtwa2dWZXJzaW9uTmFtZX0nID49ICcke2Fwa1ZlcnNpb25OYW1lfScpYCk7XG4gICAgcmV0dXJuIHNlbXZlci5zYXRpc2ZpZXMocGtnVmVyc2lvbk5hbWUsIGA+JHthcGtWZXJzaW9uTmFtZX1gKVxuICAgICAgPyB0aGlzLkFQUF9JTlNUQUxMX1NUQVRFLk5FV0VSX1ZFUlNJT05fSU5TVEFMTEVEXG4gICAgICA6IHRoaXMuQVBQX0lOU1RBTExfU1RBVEUuU0FNRV9WRVJTSU9OX0lOU1RBTExFRDtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgVGhlIGluc3RhbGxlZCAnJHtwa2d9JyBwYWNrYWdlIGlzIG9sZGVyIHRoYW4gJyR7YXBwUGF0aH0nICgke3BrZ1ZlcnNpb25Db2RlfSA8ICR7YXBrVmVyc2lvbkNvZGV9IG9yICcke3BrZ1ZlcnNpb25OYW1lfScgPCAnJHthcGtWZXJzaW9uTmFtZX0nKSdgKTtcbiAgcmV0dXJuIHRoaXMuQVBQX0lOU1RBTExfU1RBVEUuT0xERVJfVkVSU0lPTl9JTlNUQUxMRUQ7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEluc3RhbGxPclVwZ3JhZGVPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZW91dCBbNjAwMDBdIC0gVGhlIGNvdW50IG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IHVudGlsIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcCBpcyBpbnN0YWxsZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFsbG93VGVzdFBhY2thZ2VzIFtmYWxzZV0gLSBTZXQgdG8gdHJ1ZSBpbiBvcmRlciB0byBhbGxvdyB0ZXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrYWdlcyBpbnN0YWxsYXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVzZVNkY2FyZCBbZmFsc2VdIC0gU2V0IHRvIHRydWUgdG8gaW5zdGFsbCB0aGUgYXBwIG9uIFNEQ2FyZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RlYWQgb2YgdGhlIGRldmljZSBtZW1vcnkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGdyYW50UGVybWlzc2lvbnMgW2ZhbHNlXSAtIFNldCB0byB0cnVlIGluIG9yZGVyIHRvIGdyYW50IGFsbCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbnMgcmVxdWVzdGVkIGluIHRoZSBhcHBsaWNhdGlvbidzIG1hbmlmZXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgdGhlIGluc3RhbGxhdGlvbiBpcyBjb21wbGV0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXIgQW5kcm9pZCA2Ky5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5mb3JjZUN1cnJlbnRCdWlsZCBbZmFsc2VdIC0gU2V0IHRvIGB0cnVlYCBpbiBvcmRlciB0byBhbHdheXMgcHJlZmVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjdXJyZW50IGJ1aWxkIG92ZXIgYW55IGluc3RhbGxlZCBwYWNrYWdlcyBoYXZpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHNhbWUgaWRlbnRpZmllclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSW5zdGFsbE9yVXBncmFkZVJlc3VsdFxuICogQHByb3BlcnR5IHtib29sZWFufSB3YXNVbmluc3RhbGxlZCAtIEVxdWFscyB0byBgdHJ1ZWAgaWYgdGhlIHRhcmdldCBhcHAgaGFzIGJlZW4gdW5pbnN0YWxsZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmUgYmVpbmcgaW5zdGFsbGVkXG4gKiBAcHJvcGVydHkge0FQUF9JTlNUQUxMX1NUQVRFfSBhcHBTdGF0ZSAtIE9uZSBvZiBgYWRiLkFQUF9JTlNUQUxMX1NUQVRFYCBzdGF0ZXMsIHdoaWNoIHJlZmxlY3RzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzdGF0ZSBvZiB0aGUgYXBwbGljYXRpb24gYmVmb3JlIGJlaW5nIGluc3RhbGxlZC5cbiAqL1xuXG4vKipcbiAqIEluc3RhbGwgdGhlIHBhY2thZ2UgZnJvbSB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0gb3IgdXBncmFkZSBpdCBpZiBhbiBvbGRlclxuICogdmVyc2lvbiBvZiB0aGUgc2FtZSBwYWNrYWdlIGlzIGFscmVhZHkgaW5zdGFsbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBQYXRoIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgbG9jYWwgcGFja2FnZS5cbiAqIEBwYXJhbSB7P3N0cmluZ30gcGtnIC0gVGhlIG5hbWUgb2YgdGhlIGluc3RhbGxlZCBwYWNrYWdlLiBUaGUgbWV0aG9kIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybSBmYXN0ZXIgaWYgaXQgaXMgc2V0LlxuICogQHBhcmFtIHs/SW5zdGFsbE9yVXBncmFkZU9wdGlvbnN9IG9wdGlvbnMgLSBTZXQgb2YgaW5zdGFsbCBvcHRpb25zLlxuICogQHRocm93cyB7RXJyb3J9IElmIGFuIHVuZXhwZWN0ZWQgZXJyb3IgaGFwcGVucyBkdXJpbmcgaW5zdGFsbC5cbiAqIEByZXR1cm5zIHtJbnN0YWxsT3JVcGdyYWRlUmVzdWx0fVxuICovXG5hcGtVdGlsc01ldGhvZHMuaW5zdGFsbE9yVXBncmFkZSA9IGFzeW5jIGZ1bmN0aW9uIGluc3RhbGxPclVwZ3JhZGUgKGFwcFBhdGgsIHBrZyA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIXBrZykge1xuICAgIGNvbnN0IGFwa0luZm8gPSBhd2FpdCB0aGlzLmdldEFwa0luZm8oYXBwUGF0aCk7XG4gICAgcGtnID0gYXBrSW5mby5uYW1lO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGVuZm9yY2VDdXJyZW50QnVpbGQsXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBhcHBTdGF0ZSA9IGF3YWl0IHRoaXMuZ2V0QXBwbGljYXRpb25JbnN0YWxsU3RhdGUoYXBwUGF0aCwgcGtnKTtcbiAgbGV0IHdhc1VuaW5zdGFsbGVkID0gZmFsc2U7XG4gIGNvbnN0IHVuaW5zdGFsbFBhY2thZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFhd2FpdCB0aGlzLnVuaW5zdGFsbEFwayhwa2cpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke3BrZ30nIHBhY2thZ2UgY2Fubm90IGJlIHVuaW5zdGFsbGVkYCk7XG4gICAgfVxuICAgIHdhc1VuaW5zdGFsbGVkID0gdHJ1ZTtcbiAgfTtcbiAgc3dpdGNoIChhcHBTdGF0ZSkge1xuICAgIGNhc2UgdGhpcy5BUFBfSU5TVEFMTF9TVEFURS5OT1RfSU5TVEFMTEVEOlxuICAgICAgbG9nLmRlYnVnKGBJbnN0YWxsaW5nICcke2FwcFBhdGh9J2ApO1xuICAgICAgYXdhaXQgdGhpcy5pbnN0YWxsKGFwcFBhdGgsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtyZXBsYWNlOiBmYWxzZX0pKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwcFN0YXRlLFxuICAgICAgICB3YXNVbmluc3RhbGxlZCxcbiAgICAgIH07XG4gICAgY2FzZSB0aGlzLkFQUF9JTlNUQUxMX1NUQVRFLk5FV0VSX1ZFUlNJT05fSU5TVEFMTEVEOlxuICAgICAgaWYgKGVuZm9yY2VDdXJyZW50QnVpbGQpIHtcbiAgICAgICAgbG9nLmluZm8oYERvd25ncmFkaW5nICcke3BrZ30nIGFzIHJlcXVlc3RlZGApO1xuICAgICAgICBhd2FpdCB1bmluc3RhbGxQYWNrYWdlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbG9nLmRlYnVnKGBUaGVyZSBpcyBubyBuZWVkIHRvIGRvd25ncmFkZSAnJHtwa2d9J2ApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXBwU3RhdGUsXG4gICAgICAgIHdhc1VuaW5zdGFsbGVkLFxuICAgICAgfTtcbiAgICBjYXNlIHRoaXMuQVBQX0lOU1RBTExfU1RBVEUuU0FNRV9WRVJTSU9OX0lOU1RBTExFRDpcbiAgICAgIGlmIChlbmZvcmNlQ3VycmVudEJ1aWxkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbG9nLmRlYnVnKGBUaGVyZSBpcyBubyBuZWVkIHRvIGluc3RhbGwvdXBncmFkZSAnJHthcHBQYXRofSdgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwcFN0YXRlLFxuICAgICAgICB3YXNVbmluc3RhbGxlZCxcbiAgICAgIH07XG4gICAgY2FzZSB0aGlzLkFQUF9JTlNUQUxMX1NUQVRFLk9MREVSX1ZFUlNJT05fSU5TVEFMTEVEOlxuICAgICAgbG9nLmRlYnVnKGBFeGVjdXRpbmcgdXBncmFkZSBvZiAnJHthcHBQYXRofSdgKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsb2cuZGVidWcoYFRoZSBjdXJyZW50IGluc3RhbGwgc3RhdGUgb2YgJyR7YXBwUGF0aH0nIGlzIHVua25vd24uIEluc3RhbGxpbmcgYW55d2F5YCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5pbnN0YWxsKGFwcFBhdGgsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtyZXBsYWNlOiB0cnVlfSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgQ2Fubm90IGluc3RhbGwvdXBncmFkZSAnJHtwa2d9JyBiZWNhdXNlIG9mICcke2Vyci5tZXNzYWdlfScuIFRyeWluZyBmdWxsIHJlaW5zdGFsbGApO1xuICAgIGF3YWl0IHVuaW5zdGFsbFBhY2thZ2UoKTtcbiAgICBhd2FpdCB0aGlzLmluc3RhbGwoYXBwUGF0aCwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge3JlcGxhY2U6IGZhbHNlfSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYXBwU3RhdGUsXG4gICAgd2FzVW5pbnN0YWxsZWQsXG4gIH07XG59O1xuXG4vKipcbiAqIEV4dHJhY3Qgc3RyaW5nIHJlc291cmNlcyBmcm9tIHRoZSBnaXZlbiBwYWNrYWdlIG9uIGxvY2FsIGZpbGUgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBQYXRoIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgLmFwayhzKSBwYWNrYWdlLlxuICogQHBhcmFtIHs/c3RyaW5nfSBsYW5ndWFnZSAtIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0byBleHRyYWN0IHRoZSByZXNvdXJjZXMgZm9yLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IGxhbmd1YWdlIGlzIHVzZWQgaWYgdGhpcyBlcXVhbHMgdG8gYG51bGxgL2B1bmRlZmluZWRgXG4gKiBAcGFyYW0ge3N0cmluZ30gb3V0IC0gVGhlIG5hbWUgb2YgdGhlIGRlc3RpbmF0aW9uIGZvbGRlciBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0gdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICBzdG9yZSB0aGUgZXh0cmFjdGVkIGZpbGUgdG8uXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbWFwcGluZyBvYmplY3QsIHdoZXJlIHByb3BlcnRpZXMgYXJlOiAnYXBrU3RyaW5ncycsIGNvbnRhaW5pbmdcbiAqICAgICAgICAgICAgICAgICAgcGFyc2VkIHJlc291cmNlIGZpbGUgcmVwcmVzZW50ZWQgYXMgSlNPTiBvYmplY3QsIGFuZCAnbG9jYWxQYXRoJyxcbiAqICAgICAgICAgICAgICAgICAgY29udGFpbmluZyB0aGUgcGF0aCB0byB0aGUgZXh0cmFjdGVkIGZpbGUgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5hcGtVdGlsc01ldGhvZHMuZXh0cmFjdFN0cmluZ3NGcm9tQXBrID0gYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFN0cmluZ3NGcm9tQXBrIChhcHBQYXRoLCBsYW5ndWFnZSwgb3V0KSB7XG4gIGxvZy5kZWJ1ZyhgRXh0cmFjdGluZyBzdHJpbmdzIGZyb20gZm9yIGxhbmd1YWdlOiAke2xhbmd1YWdlIHx8ICdkZWZhdWx0J31gKTtcbiAgY29uc3Qgb3JpZ2luYWxBcHBQYXRoID0gYXBwUGF0aDtcbiAgaWYgKGFwcFBhdGguZW5kc1dpdGgoQVBLU19FWFRFTlNJT04pKSB7XG4gICAgYXBwUGF0aCA9IGF3YWl0IHRoaXMuZXh0cmFjdExhbmd1YWdlQXBrKGFwcFBhdGgsIGxhbmd1YWdlKTtcbiAgfVxuXG4gIGxldCBhcGtTdHJpbmdzID0ge307XG4gIGxldCBjb25maWdNYXJrZXI7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5pbml0QWFwdCgpO1xuXG4gICAgY29uZmlnTWFya2VyID0gYXdhaXQgZm9ybWF0Q29uZmlnTWFya2VyKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmJpbmFyaWVzLmFhcHQsIFtcbiAgICAgICAgJ2QnLCAnY29uZmlndXJhdGlvbnMnLCBhcHBQYXRoLFxuICAgICAgXSk7XG4gICAgICByZXR1cm4gXy51bmlxKHN0ZG91dC5zcGxpdChvcy5FT0wpKTtcbiAgICB9LCBsYW5ndWFnZSwgJyhkZWZhdWx0KScpO1xuXG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuYmluYXJpZXMuYWFwdCwgW1xuICAgICAgJ2QnLCAnLS12YWx1ZXMnLCAncmVzb3VyY2VzJywgYXBwUGF0aCxcbiAgICBdKTtcbiAgICBhcGtTdHJpbmdzID0gcGFyc2VBYXB0U3RyaW5ncyhzdGRvdXQsIGNvbmZpZ01hcmtlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZGVidWcoJ0Nhbm5vdCBleHRyYWN0IHJlc291cmNlcyB1c2luZyBhYXB0LiBUcnlpbmcgYWFwdDIuICcgK1xuICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2Uuc3RkZXJyIHx8IGUubWVzc2FnZX1gKTtcblxuICAgIGF3YWl0IHRoaXMuaW5pdEFhcHQyKCk7XG5cbiAgICBjb25maWdNYXJrZXIgPSBhd2FpdCBmb3JtYXRDb25maWdNYXJrZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuYmluYXJpZXMuYWFwdDIsIFtcbiAgICAgICAgJ2QnLCAnY29uZmlndXJhdGlvbnMnLCBhcHBQYXRoLFxuICAgICAgXSk7XG4gICAgICByZXR1cm4gXy51bmlxKHN0ZG91dC5zcGxpdChvcy5FT0wpKTtcbiAgICB9LCBsYW5ndWFnZSwgJycpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmJpbmFyaWVzLmFhcHQyLCBbXG4gICAgICAgICdkJywgJ3Jlc291cmNlcycsIGFwcFBhdGgsXG4gICAgICBdKTtcbiAgICAgIGFwa1N0cmluZ3MgPSBwYXJzZUFhcHQyU3RyaW5ncyhzdGRvdXQsIGNvbmZpZ01hcmtlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZXh0cmFjdCByZXNvdXJjZXMgZnJvbSAnJHtvcmlnaW5hbEFwcFBhdGh9Jy4gYCArXG4gICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKF8uaXNFbXB0eShhcGtTdHJpbmdzKSkge1xuICAgIGxvZy53YXJuKGBObyBzdHJpbmdzIGhhdmUgYmVlbiBmb3VuZCBpbiAnJHtvcmlnaW5hbEFwcFBhdGh9JyByZXNvdXJjZXMgYCArXG4gICAgICBgZm9yICcke2NvbmZpZ01hcmtlciB8fCAnZGVmYXVsdCd9JyBjb25maWd1cmF0aW9uYCk7XG4gIH0gZWxzZSB7XG4gICAgbG9nLmluZm8oYFN1Y2Nlc3NmdWxseSBleHRyYWN0ZWQgJHtfLmtleXMoYXBrU3RyaW5ncykubGVuZ3RofSBzdHJpbmdzIGZyb20gYCArXG4gICAgICBgJyR7b3JpZ2luYWxBcHBQYXRofScgcmVzb3VyY2VzIGZvciAnJHtjb25maWdNYXJrZXIgfHwgJ2RlZmF1bHQnfScgY29uZmlndXJhdGlvbmApO1xuICB9XG5cbiAgY29uc3QgbG9jYWxQYXRoID0gcGF0aC5yZXNvbHZlKG91dCwgJ3N0cmluZ3MuanNvbicpO1xuICBhd2FpdCBta2RpcnAob3V0KTtcbiAgYXdhaXQgZnMud3JpdGVGaWxlKGxvY2FsUGF0aCwgSlNPTi5zdHJpbmdpZnkoYXBrU3RyaW5ncywgbnVsbCwgMiksICd1dGYtOCcpO1xuICByZXR1cm4ge2Fwa1N0cmluZ3MsIGxvY2FsUGF0aH07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGFuZ3VhZ2UgbmFtZSBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvZiBkZXZpY2UgbGFuZ3VhZ2UuXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5nZXREZXZpY2VMYW5ndWFnZSA9IGFzeW5jIGZ1bmN0aW9uIGdldERldmljZUxhbmd1YWdlICgpIHtcbiAgbGV0IGxhbmd1YWdlO1xuICBpZiAoYXdhaXQgdGhpcy5nZXRBcGlMZXZlbCgpIDwgMjMpIHtcbiAgICBsYW5ndWFnZSA9IGF3YWl0IHRoaXMuZ2V0RGV2aWNlU3lzTGFuZ3VhZ2UoKTtcbiAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICBsYW5ndWFnZSA9IGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvZHVjdExhbmd1YWdlKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxhbmd1YWdlID0gKGF3YWl0IHRoaXMuZ2V0RGV2aWNlTG9jYWxlKCkpLnNwbGl0KCctJylbMF07XG4gIH1cbiAgcmV0dXJuIGxhbmd1YWdlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvdW50cnkgbmFtZSBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvZiBkZXZpY2UgY291bnRyeS5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLmdldERldmljZUNvdW50cnkgPSBhc3luYyBmdW5jdGlvbiBnZXREZXZpY2VDb3VudHJ5ICgpIHtcbiAgLy8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGluIEFQSSA8IDIzXG4gIGxldCBjb3VudHJ5ID0gYXdhaXQgdGhpcy5nZXREZXZpY2VTeXNDb3VudHJ5KCk7XG4gIGlmICghY291bnRyeSkge1xuICAgIGNvdW50cnkgPSBhd2FpdCB0aGlzLmdldERldmljZVByb2R1Y3RDb3VudHJ5KCk7XG4gIH1cbiAgcmV0dXJuIGNvdW50cnk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbG9jYWxlIG5hbWUgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb2YgZGV2aWNlIGxvY2FsZS5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLmdldERldmljZUxvY2FsZSA9IGFzeW5jIGZ1bmN0aW9uIGdldERldmljZUxvY2FsZSAoKSB7XG4gIC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBpbiBBUEkgPj0gMjNcbiAgbGV0IGxvY2FsZSA9IGF3YWl0IHRoaXMuZ2V0RGV2aWNlU3lzTG9jYWxlKCk7XG4gIGlmICghbG9jYWxlKSB7XG4gICAgbG9jYWxlID0gYXdhaXQgdGhpcy5nZXREZXZpY2VQcm9kdWN0TG9jYWxlKCk7XG4gIH1cbiAgcmV0dXJuIGxvY2FsZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBsb2NhbGUgbmFtZSBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QgYW5kIHRoZSBmb3JtYXQgb2YgdGhlIGxvY2FsZSBpcyBlbi1VUywgZm9yIGV4YW1wbGUuXG4gKiBUaGlzIG1ldGhvZCBjYWxsIHNldERldmljZUxhbmd1YWdlQ291bnRyeSwgc28sIHBsZWFzZSB1c2Ugc2V0RGV2aWNlTGFuZ3VhZ2VDb3VudHJ5IGFzIHBvc3NpYmxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGUgLSBOYW1lcyBvZiB0aGUgZGV2aWNlIGxhbmd1YWdlIGFuZCB0aGUgY291bnRyeSBjb25uZWN0ZWQgd2l0aCBgLWAuIGUuZy4gZW4tVVMuXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5zZXREZXZpY2VMb2NhbGUgPSBhc3luYyBmdW5jdGlvbiBzZXREZXZpY2VMb2NhbGUgKGxvY2FsZSkge1xuICBjb25zdCB2YWxpZGF0ZUxvY2FsZSA9IG5ldyBSZWdFeHAoL1thLXpBLVpdKy1bYS16QS1aMC05XSsvKTtcbiAgaWYgKCF2YWxpZGF0ZUxvY2FsZS50ZXN0KGxvY2FsZSkpIHtcbiAgICBsb2cud2Fybihgc2V0RGV2aWNlTG9jYWxlIHJlcXVpcmVzIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBlbi1VUyBvciBqYS1KUGApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBzcGxpdF9sb2NhbGUgPSBsb2NhbGUuc3BsaXQoJy0nKTtcbiAgYXdhaXQgdGhpcy5zZXREZXZpY2VMYW5ndWFnZUNvdW50cnkoc3BsaXRfbG9jYWxlWzBdLCBzcGxpdF9sb2NhbGVbMV0pO1xufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgY3VycmVudCBkZXZpY2UgbG9jYWxlIGlzIGV4cGVjdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgLSBMYW5ndWFnZS4gVGhlIGxhbmd1YWdlIGZpZWxkIGlzIGNhc2UgaW5zZW5zaXRpdmUsIGJ1dCBMb2NhbGUgYWx3YXlzIGNhbm9uaWNhbGl6ZXMgdG8gbG93ZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb3VudHJ5IC0gQ291bnRyeS4gVGhlIGxhbmd1YWdlIGZpZWxkIGlzIGNhc2UgaW5zZW5zaXRpdmUsIGJ1dCBMb2NhbGUgYWx3YXlzIGNhbm9uaWNhbGl6ZXMgdG8gbG93ZXIgY2FzZS5cbiAqIEBwYXJhbSB7P3N0cmluZ30gc2NyaXB0IC0gU2NyaXB0LiBUaGUgc2NyaXB0IGZpZWxkIGlzIGNhc2UgaW5zZW5zaXRpdmUgYnV0IExvY2FsZSBhbHdheXMgY2Fub25pY2FsaXplcyB0byB0aXRsZSBjYXNlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGN1cnJlbnQgbG9jYWxlIGlzIGxhbmd1YWdlIGFuZCBjb3VudHJ5IGFzIGFyZ3VtZW50cywgcmV0dXJuIHRydWUuXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5lbnN1cmVDdXJyZW50TG9jYWxlID0gYXN5bmMgZnVuY3Rpb24gZW5zdXJlQ3VycmVudExvY2FsZSAobGFuZ3VhZ2UsIGNvdW50cnksIHNjcmlwdCA9IG51bGwpIHtcbiAgY29uc3QgaGFzTGFuZ3VhZ2UgPSBfLmlzU3RyaW5nKGxhbmd1YWdlKTtcbiAgY29uc3QgaGFzQ291bnRyeSA9IF8uaXNTdHJpbmcoY291bnRyeSk7XG5cbiAgaWYgKCFoYXNMYW5ndWFnZSAmJiAhaGFzQ291bnRyeSkge1xuICAgIGxvZy53YXJuKCdlbnN1cmVDdXJyZW50TG9jYWxlIHJlcXVpcmVzIGxhbmd1YWdlIG9yIGNvdW50cnknKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBnZXQgbG93ZXIgY2FzZSB2ZXJzaW9ucyBvZiB0aGUgc3RyaW5nc1xuICBsYW5ndWFnZSA9IChsYW5ndWFnZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgY291bnRyeSA9IChjb3VudHJ5IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGNvbnN0IGFwaUxldmVsID0gYXdhaXQgdGhpcy5nZXRBcGlMZXZlbCgpO1xuXG4gIHJldHVybiBhd2FpdCByZXRyeUludGVydmFsKDUsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKGFwaUxldmVsIDwgMjMpIHtcbiAgICAgICAgbGV0IGN1ckxhbmd1YWdlLCBjdXJDb3VudHJ5O1xuICAgICAgICBpZiAoaGFzTGFuZ3VhZ2UpIHtcbiAgICAgICAgICBjdXJMYW5ndWFnZSA9IChhd2FpdCB0aGlzLmdldERldmljZUxhbmd1YWdlKCkpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKCFoYXNDb3VudHJ5ICYmIGxhbmd1YWdlID09PSBjdXJMYW5ndWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDb3VudHJ5KSB7XG4gICAgICAgICAgY3VyQ291bnRyeSA9IChhd2FpdCB0aGlzLmdldERldmljZUNvdW50cnkoKSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoIWhhc0xhbmd1YWdlICYmIGNvdW50cnkgPT09IGN1ckNvdW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ3VhZ2UgPT09IGN1ckxhbmd1YWdlICYmIGNvdW50cnkgPT09IGN1ckNvdW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3VyTG9jYWxlID0gKGF3YWl0IHRoaXMuZ2V0RGV2aWNlTG9jYWxlKCkpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIHpoLWhhbnMtY24gOiB6aC1jblxuICAgICAgICBjb25zdCBsb2NhbGVDb2RlID0gc2NyaXB0ID8gYCR7bGFuZ3VhZ2V9LSR7c2NyaXB0LnRvTG93ZXJDYXNlKCl9LSR7Y291bnRyeX1gIDogYCR7bGFuZ3VhZ2V9LSR7Y291bnRyeX1gO1xuXG4gICAgICAgIGlmIChsb2NhbGVDb2RlID09PSBjdXJMb2NhbGUpIHtcbiAgICAgICAgICBsb2cuZGVidWcoYFJlcXVlc3RlZCBsb2NhbGUgaXMgZXF1YWwgdG8gY3VycmVudCBsb2NhbGU6ICcke2N1ckxvY2FsZX0nYCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGhhcyBiZWVuIGFuIGVycm9yLCByZXN0YXJ0IGFkYiBhbmQgcmV0cnlcbiAgICAgIGxvZy5lcnJvcihgVW5hYmxlIHRvIGNoZWNrIGRldmljZSBsb2NhbGl6YXRpb246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgfSBjYXRjaCAoaWduKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbG9jYWxlIG5hbWUgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSAtIExhbmd1YWdlLiBUaGUgbGFuZ3VhZ2UgZmllbGQgaXMgY2FzZSBpbnNlbnNpdGl2ZSwgYnV0IExvY2FsZSBhbHdheXMgY2Fub25pY2FsaXplcyB0byBsb3dlciBjYXNlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBbYS16QS1aXXsyLDh9LiBlLmcuIGVuLCBqYSA6IGh0dHBzOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9qYXZhL3V0aWwvTG9jYWxlLmh0bWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb3VudHJ5IC0gQ291bnRyeS4gVGhlIGNvdW50cnkgKHJlZ2lvbikgZmllbGQgaXMgY2FzZSBpbnNlbnNpdGl2ZSwgYnV0IExvY2FsZSBhbHdheXMgY2Fub25pY2FsaXplcyB0byB1cHBlciBjYXNlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBbYS16QS1aXXsyfSB8IFswLTldezN9LiBlLmcuIFVTLCBKUCA6IGh0dHBzOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9qYXZhL3V0aWwvTG9jYWxlLmh0bWxcbiAqIEBwYXJhbSB7P3N0cmluZ30gc2NyaXB0IC0gU2NyaXB0LiBUaGUgc2NyaXB0IGZpZWxkIGlzIGNhc2UgaW5zZW5zaXRpdmUgYnV0IExvY2FsZSBhbHdheXMgY2Fub25pY2FsaXplcyB0byB0aXRsZSBjYXNlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBbYS16QS1aXXs0fS4gZS5nLiBIYW5zIGluIHpoLUhhbnMtQ04gOiBodHRwczovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9yZWZlcmVuY2UvamF2YS91dGlsL0xvY2FsZS5odG1sXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5zZXREZXZpY2VMYW5ndWFnZUNvdW50cnkgPSBhc3luYyBmdW5jdGlvbiBzZXREZXZpY2VMYW5ndWFnZUNvdW50cnkgKGxhbmd1YWdlLCBjb3VudHJ5LCBzY3JpcHQgPSBudWxsKSB7XG4gIGxldCBoYXNMYW5ndWFnZSA9IGxhbmd1YWdlICYmIF8uaXNTdHJpbmcobGFuZ3VhZ2UpO1xuICBsZXQgaGFzQ291bnRyeSA9IGNvdW50cnkgJiYgXy5pc1N0cmluZyhjb3VudHJ5KTtcbiAgaWYgKCFoYXNMYW5ndWFnZSB8fCAhaGFzQ291bnRyeSkge1xuICAgIGxvZy53YXJuKGBzZXREZXZpY2VMYW5ndWFnZUNvdW50cnkgcmVxdWlyZXMgbGFuZ3VhZ2UgYW5kIGNvdW50cnkgYXQgbGVhc3RgKTtcbiAgICBsb2cud2FybihgR290IGxhbmd1YWdlOiAnJHtsYW5ndWFnZX0nIGFuZCBjb3VudHJ5OiAnJHtjb3VudHJ5fSdgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGFwaUxldmVsID0gYXdhaXQgdGhpcy5nZXRBcGlMZXZlbCgpO1xuXG4gIGxhbmd1YWdlID0gKGxhbmd1YWdlIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICBjb3VudHJ5ID0gKGNvdW50cnkgfHwgJycpLnRvVXBwZXJDYXNlKCk7XG5cbiAgaWYgKGFwaUxldmVsIDwgMjMpIHtcbiAgICBsZXQgY3VyTGFuZ3VhZ2UgPSAoYXdhaXQgdGhpcy5nZXREZXZpY2VMYW5ndWFnZSgpKS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBjdXJDb3VudHJ5ID0gKGF3YWl0IHRoaXMuZ2V0RGV2aWNlQ291bnRyeSgpKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKGxhbmd1YWdlICE9PSBjdXJMYW5ndWFnZSB8fCBjb3VudHJ5ICE9PSBjdXJDb3VudHJ5KSB7XG4gICAgICBhd2FpdCB0aGlzLnNldERldmljZVN5c0xvY2FsZVZpYVNldHRpbmdBcHAobGFuZ3VhZ2UsIGNvdW50cnkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgY3VyTG9jYWxlID0gYXdhaXQgdGhpcy5nZXREZXZpY2VMb2NhbGUoKTtcblxuICAgIC8vIHpoLUhhbnMtQ04gOiB6aC1DTlxuICAgIGNvbnN0IGxvY2FsZUNvZGUgPSBzY3JpcHQgPyBgJHtsYW5ndWFnZX0tJHtzY3JpcHR9LSR7Y291bnRyeX1gIDogYCR7bGFuZ3VhZ2V9LSR7Y291bnRyeX1gO1xuICAgIGxvZy5kZWJ1ZyhgQ3VycmVudCBsb2NhbGU6ICcke2N1ckxvY2FsZX0nOyByZXF1ZXN0ZWQgbG9jYWxlOiAnJHtsb2NhbGVDb2RlfSdgKTtcbiAgICBpZiAobG9jYWxlQ29kZS50b0xvd2VyQ2FzZSgpICE9PSBjdXJMb2NhbGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgYXdhaXQgdGhpcy5zZXREZXZpY2VTeXNMb2NhbGVWaWFTZXR0aW5nQXBwKGxhbmd1YWdlLCBjb3VudHJ5LCBzY3JpcHQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBcHBJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFBhY2thZ2UgbmFtZSwgZm9yIGV4YW1wbGUgJ2NvbS5hY21lLmFwcCcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmVyc2lvbkNvZGUgLSBWZXJzaW9uIGNvZGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmVyc2lvbk5hbWUgLSBWZXJzaW9uIG5hbWUsIGZvciBleGFtcGxlICcxLjAnLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSBwYWNrYWdlIGluZm8gZnJvbSBsb2NhbCBhcGsgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwUGF0aCAtIFRoZSBmdWxsIHBhdGggdG8gZXhpc3RpbmcgLmFwayhzKSBwYWNrYWdlIG9uIHRoZSBsb2NhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHN5c3RlbS5cbiAqIEByZXR1cm4gez9BcHBJbmZvfSBUaGUgcGFyc2VkIGFwcGxpY2F0aW9uIGluZm9ybWF0aW9uLlxuICovXG5hcGtVdGlsc01ldGhvZHMuZ2V0QXBrSW5mbyA9IGFzeW5jIGZ1bmN0aW9uIGdldEFwa0luZm8gKGFwcFBhdGgpIHtcbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMoYXBwUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaWxlIGF0IHBhdGggJHthcHBQYXRofSBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYWNjZXNzaWJsZWApO1xuICB9XG5cbiAgaWYgKGFwcFBhdGguZW5kc1dpdGgoQVBLU19FWFRFTlNJT04pKSB7XG4gICAgYXBwUGF0aCA9IGF3YWl0IHRoaXMuZXh0cmFjdEJhc2VBcGsoYXBwUGF0aCk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGFwa1JlYWRlciA9IGF3YWl0IEFwa1JlYWRlci5vcGVuKGFwcFBhdGgpO1xuICAgIGNvbnN0IG1hbmlmZXN0ID0gYXdhaXQgYXBrUmVhZGVyLnJlYWRNYW5pZmVzdCgpO1xuICAgIGNvbnN0IHtwa2csIHZlcnNpb25OYW1lLCB2ZXJzaW9uQ29kZX0gPSBwYXJzZU1hbmlmZXN0KG1hbmlmZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogcGtnLFxuICAgICAgdmVyc2lvbkNvZGUsXG4gICAgICB2ZXJzaW9uTmFtZSxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLndhcm4oYEVycm9yICcke2UubWVzc2FnZX0nIHdoaWxlIGdldHRpbmcgYmFkZ2luZyBpbmZvYCk7XG4gIH1cbiAgcmV0dXJuIHt9O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHBhY2thZ2UgaW5mbyBmcm9tIHRoZSBpbnN0YWxsZWQgYXBwbGljYXRpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBuYW1lIG9mIHRoZSBpbnN0YWxsZWQgcGFja2FnZS5cbiAqIEByZXR1cm4gez9BcHBJbmZvfSBUaGUgcGFyc2VkIGFwcGxpY2F0aW9uIGluZm9ybWF0aW9uLlxuICovXG5hcGtVdGlsc01ldGhvZHMuZ2V0UGFja2FnZUluZm8gPSBhc3luYyBmdW5jdGlvbiBnZXRQYWNrYWdlSW5mbyAocGtnKSB7XG4gIGxvZy5kZWJ1ZyhgR2V0dGluZyBwYWNrYWdlIGluZm8gZm9yICcke3BrZ30nYCk7XG4gIGxldCByZXN1bHQgPSB7bmFtZTogcGtnfTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnZHVtcHN5cycsICdwYWNrYWdlJywgcGtnXSk7XG4gICAgY29uc3QgdmVyc2lvbk5hbWVNYXRjaCA9IG5ldyBSZWdFeHAoL3ZlcnNpb25OYW1lPShbXFxkKy5dKykvKS5leGVjKHN0ZG91dCk7XG4gICAgaWYgKHZlcnNpb25OYW1lTWF0Y2gpIHtcbiAgICAgIHJlc3VsdC52ZXJzaW9uTmFtZSA9IHZlcnNpb25OYW1lTWF0Y2hbMV07XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb25Db2RlTWF0Y2ggPSBuZXcgUmVnRXhwKC92ZXJzaW9uQ29kZT0oXFxkKykvKS5leGVjKHN0ZG91dCk7XG4gICAgaWYgKHZlcnNpb25Db2RlTWF0Y2gpIHtcbiAgICAgIHJlc3VsdC52ZXJzaW9uQ29kZSA9IHBhcnNlSW50KHZlcnNpb25Db2RlTWF0Y2hbMV0sIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYEVycm9yICcke2Vyci5tZXNzYWdlfScgd2hpbGUgZHVtcGluZyBwYWNrYWdlIGluZm9gKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuYXBrVXRpbHNNZXRob2RzLnB1bGxBcGsgPSBhc3luYyBmdW5jdGlvbiBwdWxsQXBrIChwa2csIHRtcERpcikge1xuICBjb25zdCBwa2dQYXRoID0gKGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3NoZWxsJywgJ3BtJywgJ3BhdGgnLCBwa2ddKSkucmVwbGFjZSgncGFja2FnZTonLCAnJyk7XG4gIGNvbnN0IHRtcEFwcCA9IHBhdGgucmVzb2x2ZSh0bXBEaXIsIGAke3BrZ30uYXBrYCk7XG4gIGF3YWl0IHRoaXMucHVsbChwa2dQYXRoLCB0bXBBcHApO1xuICBsb2cuZGVidWcoYFB1bGxlZCBhcHAgZm9yIHBhY2thZ2UgJyR7cGtnfScgdG8gJyR7dG1wQXBwfSdgKTtcbiAgcmV0dXJuIHRtcEFwcDtcbn07XG5cbmV4cG9ydCB7IFJFTU9URV9DQUNIRV9ST09UIH07XG5leHBvcnQgZGVmYXVsdCBhcGtVdGlsc01ldGhvZHM7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBTUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsTUFBTUEsZUFBZSxHQUFHLEVBQXhCO0FBRUEsTUFBTUMsK0JBQStCLEdBQ25DLHlHQURGO0FBRUFELGVBQWUsQ0FBQ0UsaUJBQWhCLEdBQW9DO0VBQ2xDQyxPQUFPLEVBQUUsU0FEeUI7RUFFbENDLGFBQWEsRUFBRSxjQUZtQjtFQUdsQ0MsdUJBQXVCLEVBQUUsdUJBSFM7RUFJbENDLHNCQUFzQixFQUFFLHNCQUpVO0VBS2xDQyx1QkFBdUIsRUFBRTtBQUxTLENBQXBDO0FBT0EsTUFBTUMsaUJBQWlCLEdBQUcsOEJBQTFCOzs7QUFVQVIsZUFBZSxDQUFDUyxjQUFoQixHQUFpQyxlQUFlQSxjQUFmLENBQStCQyxHQUEvQixFQUFvQztFQUNuRUMsZUFBQSxDQUFJQyxLQUFKLENBQVcsOEJBQTZCRixHQUFJLEVBQTVDOztFQUNBLE1BQU1HLGdCQUFnQixHQUFHLElBQUlDLE1BQUosQ0FBWSxzQkFBcUJDLGVBQUEsQ0FBRUMsWUFBRixDQUFlTixHQUFmLENBQW9CLFlBQXJELEVBQWtFLEdBQWxFLENBQXpCOztFQUNBLElBQUk7SUFDRixNQUFNTyxNQUFNLEdBQUcsTUFBTSxL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
