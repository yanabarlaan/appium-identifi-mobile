"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _support = require("@appium/support");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _events = _interopRequireDefault(require("events"));

var _teen_process = require("teen_process");

const {
  EventEmitter
} = _events.default;

const log = _support.logger.getLogger('Logcat');

const MAX_BUFFER_SIZE = 10000;
const LOGCAT_PROC_STARTUP_TIMEOUT = 10000;
const SUPPORTED_FORMATS = ['brief', 'process', 'tag', 'thread', 'raw', 'time', 'threadtime', 'long'];
const SUPPORTED_PRIORITIES = ['v', 'd', 'i', 'w', 'e', 'f', 's'];
const DEFAULT_PRIORITY = 'v';
const DEFAULT_TAG = '*';
const DEFAULT_FORMAT = 'threadtime';

function requireFormat(format) {
  if (!SUPPORTED_FORMATS.includes(format)) {
    log.info(`The format value '${format}' is unknown. Supported values are: ${SUPPORTED_FORMATS}`);
    log.info(`Defaulting to '${DEFAULT_FORMAT}'`);
    return DEFAULT_FORMAT;
  }

  return format;
}

function requireSpec(spec) {
  const [tag, priority] = spec.split(':');
  let resultTag = tag;

  if (!resultTag) {
    log.info(`The tag value in spec '${spec}' cannot be empty`);
    log.info(`Defaulting to '${DEFAULT_TAG}'`);
    resultTag = DEFAULT_TAG;
  }

  if (!priority) {
    log.info(`The priority value in spec '${spec}' is empty. Defaulting to Verbose (${DEFAULT_PRIORITY})`);
    return `${resultTag}:${DEFAULT_PRIORITY}`;
  }

  if (!SUPPORTED_PRIORITIES.some(p => _lodash.default.toLower(priority) === _lodash.default.toLower(p))) {
    log.info(`The priority value in spec '${spec}' is unknown. Supported values are: ${SUPPORTED_PRIORITIES}`);
    log.info(`Defaulting to Verbose (${DEFAULT_PRIORITY})`);
    return `${resultTag}:${DEFAULT_PRIORITY}`;
  }

  return spec;
}

function formatFilterSpecs(filterSpecs) {
  if (!_lodash.default.isArray(filterSpecs)) {
    filterSpecs = [filterSpecs];
  }

  return filterSpecs.filter(spec => spec && _lodash.default.isString(spec) && !spec.startsWith('-')).map(spec => spec.includes(':') ? requireSpec(spec) : spec);
}

class Logcat extends EventEmitter {
  constructor(opts = {}) {
    super();
    this.adb = opts.adb;
    this.clearLogs = opts.clearDeviceLogsOnStart || false;
    this.debug = opts.debug;
    this.debugTrace = opts.debugTrace;
    this.maxBufferSize = opts.maxBufferSize || MAX_BUFFER_SIZE;
    this.logs = [];
    this.logIdxSinceLastRequest = 0;
  }

  async startCapture(opts = {}) {
    let started = false;
    return await new _bluebird.default(async (_resolve, _reject) => {
      const resolve = function (...args) {
        started = true;

        _resolve(...args);
      };

      const reject = function (...args) {
        started = true;

        _reject(...args);
      };

      if (this.clearLogs) {
        await this.clear();
      }

      const {
        format = DEFAULT_FORMAT,
        filterSpecs = []
      } = opts;
      const cmd = [...this.adb.defaultArgs, 'logcat', '-v', requireFormat(format), ...formatFilterSpecs(filterSpecs)];
      log.debug(`Starting logs capture with command: ${_support.util.quote([this.adb.path, ...cmd])}`);
      this.proc = new _teen_process.SubProcess(this.adb.path, cmd);
      this.proc.on('exit', (code, signal) => {
        log.error(`Logcat terminated with code ${code}, signal ${signal}`);
        this.proc = null;

        if (!started) {
          log.warn('Logcat not started. Continuing');
          resolve();
        }
      });
      this.proc.on('lines-stderr', lines => {
        for (let line of lines) {
          if (/execvp\(\)/.test(line)) {
            log.error('Logcat process failed to start');
            reject(new Error(`Logcat process failed to start. stderr: ${line}`));
          }

          this.outputHandler(_lodash.default.trim(line), 'STDERR: ');
        }

        resolve();
      });
      this.proc.on('lines-stdout', lines => {
        resolve();

        for (let line of lines) {
          this.outputHandler(_lodash.default.trim(line));
        }
      });
      await this.proc.start(0);
      setTimeout(resolve, LOGCAT_PROC_STARTUP_TIMEOUT);
    });
  }

  outputHandler(output, prefix = '') {
    if (!output) {
      return;
    }

    if (this.logs.length >= this.maxBufferSize) {
      this.logs.shift();

      if (this.logIdxSinceLastRequest > 0) {
        --this.logIdxSinceLastRequest;
      }
    }

    const outputObj = {
      timestamp: Date.now(),
      level: 'ALL',
      message: output
    };
    this.logs.push(outputObj);
    this.emit('output', outputObj);
    const isTrace = /W\/Trace/.test(output);

    if (this.debug && (!isTrace || this.debugTrace)) {
      log.debug(prefix + output);
    }
  }

  async stopCapture() {
    log.debug('Stopping logcat capture');

    if (!this.proc || !this.proc.isRunning) {
      log.debug('Logcat already stopped');
      this.proc = null;
      return;
    }

    this.proc.removeAllListeners('exit');
    await this.proc.stop();
    this.proc = null;
  }

  getLogs() {
    if (this.logIdxSinceLastRequest < this.logs.length) {
      const result = this.logs.slice(this.logIdxSinceLastRequest);
      this.logIdxSinceLastRequest = this.logs.length;
      return result;
    }

    return [];
  }

  getAllLogs() {
    return this.logs;
  }

  async clear() {
    log.debug('Clearing logcat logs from device');

    try {
      const args = [...this.adb.defaultArgs, 'logcat', '-c'];
      await (0, _teen_process.exec)(this.adb.path, args);
    } catch (err) {
      log.warn(`Failed to clear logcat logs: ${err.stderr || err.message}`);
    }
  }

}

var _default = Logcat;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL2xvZ2NhdC5qcyIsIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsImV2ZW50cyIsImxvZyIsImxvZ2dlciIsImdldExvZ2dlciIsIk1BWF9CVUZGRVJfU0laRSIsIkxPR0NBVF9QUk9DX1NUQVJUVVBfVElNRU9VVCIsIlNVUFBPUlRFRF9GT1JNQVRTIiwiU1VQUE9SVEVEX1BSSU9SSVRJRVMiLCJERUZBVUxUX1BSSU9SSVRZIiwiREVGQVVMVF9UQUciLCJERUZBVUxUX0ZPUk1BVCIsInJlcXVpcmVGb3JtYXQiLCJmb3JtYXQiLCJpbmNsdWRlcyIsImluZm8iLCJyZXF1aXJlU3BlYyIsInNwZWMiLCJ0YWciLCJwcmlvcml0eSIsInNwbGl0IiwicmVzdWx0VGFnIiwic29tZSIsInAiLCJfIiwidG9Mb3dlciIsImZvcm1hdEZpbHRlclNwZWNzIiwiZmlsdGVyU3BlY3MiLCJpc0FycmF5IiwiZmlsdGVyIiwiaXNTdHJpbmciLCJzdGFydHNXaXRoIiwibWFwIiwiTG9nY2F0IiwiY29uc3RydWN0b3IiLCJvcHRzIiwiYWRiIiwiY2xlYXJMb2dzIiwiY2xlYXJEZXZpY2VMb2dzT25TdGFydCIsImRlYnVnIiwiZGVidWdUcmFjZSIsIm1heEJ1ZmZlclNpemUiLCJsb2dzIiwibG9nSWR4U2luY2VMYXN0UmVxdWVzdCIsInN0YXJ0Q2FwdHVyZSIsInN0YXJ0ZWQiLCJCIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwicmVzb2x2ZSIsImFyZ3MiLCJyZWplY3QiLCJjbGVhciIsImNtZCIsImRlZmF1bHRBcmdzIiwidXRpbCIsInF1b3RlIiwicGF0aCIsInByb2MiLCJTdWJQcm9jZXNzIiwib24iLCJjb2RlIiwic2lnbmFsIiwiZXJyb3IiLCJ3YXJuIiwibGluZXMiLCJsaW5lIiwidGVzdCIsIkVycm9yIiwib3V0cHV0SGFuZGxlciIsInRyaW0iLCJzdGFydCIsInNldFRpbWVvdXQiLCJvdXRwdXQiLCJwcmVmaXgiLCJsZW5ndGgiLCJzaGlmdCIsIm91dHB1dE9iaiIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJsZXZlbCIsIm1lc3NhZ2UiLCJwdXNoIiwiZW1pdCIsImlzVHJhY2UiLCJzdG9wQ2FwdHVyZSIsImlzUnVubmluZyIsInJlbW92ZUFsbExpc3RlbmVycyIsInN0b3AiLCJnZXRMb2dzIiwicmVzdWx0Iiwic2xpY2UiLCJnZXRBbGxMb2dzIiwiZXhlYyIsImVyciIsInN0ZGVyciJdLCJzb3VyY2VSb290IjoiLi4vLi4iLCJzb3VyY2VzIjpbImxpYi9sb2djYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGxvZ2dlciwgdXRpbCB9IGZyb20gJ0BhcHBpdW0vc3VwcG9ydCc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gZXZlbnRzO1xuaW1wb3J0IHsgU3ViUHJvY2VzcywgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5cbmNvbnN0IGxvZyA9IGxvZ2dlci5nZXRMb2dnZXIoJ0xvZ2NhdCcpO1xuY29uc3QgTUFYX0JVRkZFUl9TSVpFID0gMTAwMDA7XG5jb25zdCBMT0dDQVRfUFJPQ19TVEFSVFVQX1RJTUVPVVQgPSAxMDAwMDtcbmNvbnN0IFNVUFBPUlRFRF9GT1JNQVRTID0gWydicmllZicsICdwcm9jZXNzJywgJ3RhZycsICd0aHJlYWQnLCAncmF3JywgJ3RpbWUnLCAndGhyZWFkdGltZScsICdsb25nJ107XG5jb25zdCBTVVBQT1JURURfUFJJT1JJVElFUyA9IFsndicsICdkJywgJ2knLCAndycsICdlJywgJ2YnLCAncyddO1xuY29uc3QgREVGQVVMVF9QUklPUklUWSA9ICd2JztcbmNvbnN0IERFRkFVTFRfVEFHID0gJyonO1xuY29uc3QgREVGQVVMVF9GT1JNQVQgPSAndGhyZWFkdGltZSc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVGb3JtYXQgKGZvcm1hdCkge1xuICBpZiAoIVNVUFBPUlRFRF9GT1JNQVRTLmluY2x1ZGVzKGZvcm1hdCkpIHtcbiAgICBsb2cuaW5mbyhgVGhlIGZvcm1hdCB2YWx1ZSAnJHtmb3JtYXR9JyBpcyB1bmtub3duLiBTdXBwb3J0ZWQgdmFsdWVzIGFyZTogJHtTVVBQT1JURURfRk9STUFUU31gKTtcbiAgICBsb2cuaW5mbyhgRGVmYXVsdGluZyB0byAnJHtERUZBVUxUX0ZPUk1BVH0nYCk7XG4gICAgcmV0dXJuIERFRkFVTFRfRk9STUFUO1xuICB9XG4gIHJldHVybiBmb3JtYXQ7XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVTcGVjIChzcGVjKSB7XG4gIGNvbnN0IFt0YWcsIHByaW9yaXR5XSA9IHNwZWMuc3BsaXQoJzonKTtcbiAgbGV0IHJlc3VsdFRhZyA9IHRhZztcbiAgaWYgKCFyZXN1bHRUYWcpIHtcbiAgICBsb2cuaW5mbyhgVGhlIHRhZyB2YWx1ZSBpbiBzcGVjICcke3NwZWN9JyBjYW5ub3QgYmUgZW1wdHlgKTtcbiAgICBsb2cuaW5mbyhgRGVmYXVsdGluZyB0byAnJHtERUZBVUxUX1RBR30nYCk7XG4gICAgcmVzdWx0VGFnID0gREVGQVVMVF9UQUc7XG4gIH1cbiAgaWYgKCFwcmlvcml0eSkge1xuICAgIGxvZy5pbmZvKGBUaGUgcHJpb3JpdHkgdmFsdWUgaW4gc3BlYyAnJHtzcGVjfScgaXMgZW1wdHkuIERlZmF1bHRpbmcgdG8gVmVyYm9zZSAoJHtERUZBVUxUX1BSSU9SSVRZfSlgKTtcbiAgICByZXR1cm4gYCR7cmVzdWx0VGFnfToke0RFRkFVTFRfUFJJT1JJVFl9YDtcbiAgfVxuICBpZiAoIVNVUFBPUlRFRF9QUklPUklUSUVTLnNvbWUoKHApID0+IF8udG9Mb3dlcihwcmlvcml0eSkgPT09IF8udG9Mb3dlcihwKSkpIHtcbiAgICBsb2cuaW5mbyhgVGhlIHByaW9yaXR5IHZhbHVlIGluIHNwZWMgJyR7c3BlY30nIGlzIHVua25vd24uIFN1cHBvcnRlZCB2YWx1ZXMgYXJlOiAke1NVUFBPUlRFRF9QUklPUklUSUVTfWApO1xuICAgIGxvZy5pbmZvKGBEZWZhdWx0aW5nIHRvIFZlcmJvc2UgKCR7REVGQVVMVF9QUklPUklUWX0pYCk7XG4gICAgcmV0dXJuIGAke3Jlc3VsdFRhZ306JHtERUZBVUxUX1BSSU9SSVRZfWA7XG4gIH1cbiAgcmV0dXJuIHNwZWM7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEZpbHRlclNwZWNzIChmaWx0ZXJTcGVjcykge1xuICBpZiAoIV8uaXNBcnJheShmaWx0ZXJTcGVjcykpIHtcbiAgICBmaWx0ZXJTcGVjcyA9IFtmaWx0ZXJTcGVjc107XG4gIH1cbiAgcmV0dXJuIGZpbHRlclNwZWNzXG4gICAgLmZpbHRlcigoc3BlYykgPT4gc3BlYyAmJiBfLmlzU3RyaW5nKHNwZWMpICYmICFzcGVjLnN0YXJ0c1dpdGgoJy0nKSlcbiAgICAubWFwKChzcGVjKSA9PiBzcGVjLmluY2x1ZGVzKCc6JykgPyByZXF1aXJlU3BlYyhzcGVjKSA6IHNwZWMpO1xufVxuXG5cbmNsYXNzIExvZ2NhdCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYWRiID0gb3B0cy5hZGI7XG4gICAgdGhpcy5jbGVhckxvZ3MgPSBvcHRzLmNsZWFyRGV2aWNlTG9nc09uU3RhcnQgfHwgZmFsc2U7XG4gICAgdGhpcy5kZWJ1ZyA9IG9wdHMuZGVidWc7XG4gICAgdGhpcy5kZWJ1Z1RyYWNlID0gb3B0cy5kZWJ1Z1RyYWNlO1xuICAgIHRoaXMubWF4QnVmZmVyU2l6ZSA9IG9wdHMubWF4QnVmZmVyU2l6ZSB8fCBNQVhfQlVGRkVSX1NJWkU7XG4gICAgdGhpcy5sb2dzID0gW107XG4gICAgdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID0gMDtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0Q2FwdHVyZSAob3B0cyA9IHt9KSB7XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gYXdhaXQgbmV3IEIoYXN5bmMgKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9wYXJhbS1uYW1lc1xuICAgICAgY29uc3QgcmVzb2x2ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBfcmVzb2x2ZSguLi5hcmdzKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZWplY3QgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgX3JlamVjdCguLi5hcmdzKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmNsZWFyTG9ncykge1xuICAgICAgICBhd2FpdCB0aGlzLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9ybWF0ID0gREVGQVVMVF9GT1JNQVQsXG4gICAgICAgIGZpbHRlclNwZWNzID0gW10sXG4gICAgICB9ID0gb3B0cztcbiAgICAgIGNvbnN0IGNtZCA9IFtcbiAgICAgICAgLi4udGhpcy5hZGIuZGVmYXVsdEFyZ3MsXG4gICAgICAgICdsb2djYXQnLFxuICAgICAgICAnLXYnLCByZXF1aXJlRm9ybWF0KGZvcm1hdCksXG4gICAgICAgIC4uLmZvcm1hdEZpbHRlclNwZWNzKGZpbHRlclNwZWNzKSxcbiAgICAgIF07XG4gICAgICBsb2cuZGVidWcoYFN0YXJ0aW5nIGxvZ3MgY2FwdHVyZSB3aXRoIGNvbW1hbmQ6ICR7dXRpbC5xdW90ZShbdGhpcy5hZGIucGF0aCwgLi4uY21kXSl9YCk7XG4gICAgICB0aGlzLnByb2MgPSBuZXcgU3ViUHJvY2Vzcyh0aGlzLmFkYi5wYXRoLCBjbWQpO1xuICAgICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICBsb2cuZXJyb3IoYExvZ2NhdCB0ZXJtaW5hdGVkIHdpdGggY29kZSAke2NvZGV9LCBzaWduYWwgJHtzaWduYWx9YCk7XG4gICAgICAgIHRoaXMucHJvYyA9IG51bGw7XG4gICAgICAgIGlmICghc3RhcnRlZCkge1xuICAgICAgICAgIGxvZy53YXJuKCdMb2djYXQgbm90IHN0YXJ0ZWQuIENvbnRpbnVpbmcnKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9jLm9uKCdsaW5lcy1zdGRlcnInLCAobGluZXMpID0+IHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgIGlmICgvZXhlY3ZwXFwoXFwpLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoJ0xvZ2NhdCBwcm9jZXNzIGZhaWxlZCB0byBzdGFydCcpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgTG9nY2F0IHByb2Nlc3MgZmFpbGVkIHRvIHN0YXJ0LiBzdGRlcnI6ICR7bGluZX1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub3V0cHV0SGFuZGxlcihfLnRyaW0obGluZSksICdTVERFUlI6ICcpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9jLm9uKCdsaW5lcy1zdGRvdXQnLCAobGluZXMpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRIYW5kbGVyKF8udHJpbShsaW5lKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0YXJ0KDApO1xuICAgICAgLy8gcmVzb2x2ZSBhZnRlciBhIHRpbWVvdXQsIGV2ZW4gaWYgbm8gb3V0cHV0IHdhcyByZWNvcmRlZFxuICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBMT0dDQVRfUFJPQ19TVEFSVFVQX1RJTUVPVVQpO1xuICAgIH0pO1xuICB9XG5cbiAgb3V0cHV0SGFuZGxlciAob3V0cHV0LCBwcmVmaXggPSAnJykge1xuICAgIGlmICghb3V0cHV0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubG9ncy5sZW5ndGggPj0gdGhpcy5tYXhCdWZmZXJTaXplKSB7XG4gICAgICB0aGlzLmxvZ3Muc2hpZnQoKTtcbiAgICAgIGlmICh0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPiAwKSB7XG4gICAgICAgIC0tdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvdXRwdXRPYmogPSB7XG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBsZXZlbDogJ0FMTCcsXG4gICAgICBtZXNzYWdlOiBvdXRwdXQsXG4gICAgfTtcbiAgICB0aGlzLmxvZ3MucHVzaChvdXRwdXRPYmopO1xuICAgIHRoaXMuZW1pdCgnb3V0cHV0Jywgb3V0cHV0T2JqKTtcbiAgICBjb25zdCBpc1RyYWNlID0gL1dcXC9UcmFjZS8udGVzdChvdXRwdXQpO1xuICAgIGlmICh0aGlzLmRlYnVnICYmICghaXNUcmFjZSB8fCB0aGlzLmRlYnVnVHJhY2UpKSB7XG4gICAgICBsb2cuZGVidWcocHJlZml4ICsgb3V0cHV0KTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzdG9wQ2FwdHVyZSAoKSB7XG4gICAgbG9nLmRlYnVnKCdTdG9wcGluZyBsb2djYXQgY2FwdHVyZScpO1xuICAgIGlmICghdGhpcy5wcm9jIHx8ICF0aGlzLnByb2MuaXNSdW5uaW5nKSB7XG4gICAgICBsb2cuZGVidWcoJ0xvZ2NhdCBhbHJlYWR5IHN0b3BwZWQnKTtcbiAgICAgIHRoaXMucHJvYyA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvYy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2V4aXQnKTtcbiAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgpO1xuICAgIHRoaXMucHJvYyA9IG51bGw7XG4gIH1cblxuICBnZXRMb2dzICgpIHtcbiAgICBpZiAodGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0IDwgdGhpcy5sb2dzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5sb2dzLnNsaWNlKHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCk7XG4gICAgICB0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPSB0aGlzLmxvZ3MubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZ2V0QWxsTG9ncyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9ncztcbiAgfVxuXG4gIGFzeW5jIGNsZWFyICgpIHtcbiAgICBsb2cuZGVidWcoJ0NsZWFyaW5nIGxvZ2NhdCBsb2dzIGZyb20gZGV2aWNlJyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBbLi4udGhpcy5hZGIuZGVmYXVsdEFyZ3MsICdsb2djYXQnLCAnLWMnXTtcbiAgICAgIGF3YWl0IGV4ZWModGhpcy5hZGIucGF0aCwgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgRmFpbGVkIHRvIGNsZWFyIGxvZ2NhdCBsb2dzOiAke2Vyci5zdGRlcnIgfHwgZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvZ2NhdDtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFEQSxNQUFNO0VBQUVBO0FBQUYsSUFBbUJDLGVBQXpCOztBQUdBLE1BQU1DLEdBQUcsR0FBR0MsZUFBQSxDQUFPQyxTQUFQLENBQWlCLFFBQWpCLENBQVo7O0FBQ0EsTUFBTUMsZUFBZSxHQUFHLEtBQXhCO0FBQ0EsTUFBTUMsMkJBQTJCLEdBQUcsS0FBcEM7QUFDQSxNQUFNQyxpQkFBaUIsR0FBRyxDQUFDLE9BQUQsRUFBVSxTQUFWLEVBQXFCLEtBQXJCLEVBQTRCLFFBQTVCLEVBQXNDLEtBQXRDLEVBQTZDLE1BQTdDLEVBQXFELFlBQXJELEVBQW1FLE1BQW5FLENBQTFCO0FBQ0EsTUFBTUMsb0JBQW9CLEdBQUcs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
