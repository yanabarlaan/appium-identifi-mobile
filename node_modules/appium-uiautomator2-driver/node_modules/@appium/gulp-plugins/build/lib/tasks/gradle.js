'use strict';

require("source-map-support/register");

const argv = require('yargs').argv;

const replace = require('replace-in-file');

const log = require('fancy-log');

const semver = require('semver');

const globby = require('globby');

function logFileChanges(changes = []) {
  changes = changes.filter(entry => entry.hasChanged).map(entry => entry.file);
  log(`Updated files: ${changes.join(', ')}`);
}

const configure = function configure(gulp) {
  gulp.task('gradle-version-update', async function gradleVersionUpdate() {
    const files = await globby(['app/build.gradle']);

    if (!files.length) {
      throw new Error('No app/build.gradle file found');
    }

    const gradleFile = files[0];
    const version = argv['package-version'];

    if (!version) {
      throw new Error('No package version argument (use `--package-version=xxx`)');
    }

    if (!semver.valid(version)) {
      throw new Error(`Invalid version specified '${version}'. Version should be in the form '1.2.3'`);
    }

    let changedFiles = await replace({
      files: gradleFile,
      from: /^\s*versionName\s+['"](.+)['"]$/gm,
      to: match => {
        log(`Updating gradle build file to version name '${version}'`);
        return match.replace(/\d+\.\d+\.\d+/, version);
      }
    });
    logFileChanges(changedFiles);
    changedFiles = await replace({
      files: gradleFile,
      from: /^\s*versionCode\s+(.+)$/gm,
      to: match => {
        const codeMatch = /\d+/.exec(match.trim());

        if (!codeMatch) {
          throw new Error('Unable to find existing version code');
        }

        const code = parseInt(codeMatch[0], 10) + 1;
        log(`Updating gradle build file to version code '${code}'`);
        return match.replace(/\d+/, code);
      }
    });
    logFileChanges(changedFiles);
  });
};

module.exports = {
  configure
};require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL3Rhc2tzL2dyYWRsZS5qcyIsIm5hbWVzIjpbImFyZ3YiLCJyZXF1aXJlIiwicmVwbGFjZSIsImxvZyIsInNlbXZlciIsImdsb2JieSIsImxvZ0ZpbGVDaGFuZ2VzIiwiY2hhbmdlcyIsImZpbHRlciIsImVudHJ5IiwiaGFzQ2hhbmdlZCIsIm1hcCIsImZpbGUiLCJqb2luIiwiY29uZmlndXJlIiwiZ3VscCIsInRhc2siLCJncmFkbGVWZXJzaW9uVXBkYXRlIiwiZmlsZXMiLCJsZW5ndGgiLCJFcnJvciIsImdyYWRsZUZpbGUiLCJ2ZXJzaW9uIiwidmFsaWQiLCJjaGFuZ2VkRmlsZXMiLCJmcm9tIiwidG8iLCJtYXRjaCIsImNvZGVNYXRjaCIsImV4ZWMiLCJ0cmltIiwiY29kZSIsInBhcnNlSW50IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4iLCJzb3VyY2VzIjpbImxpYi90YXNrcy9ncmFkbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcmd2ID0gcmVxdWlyZSgneWFyZ3MnKS5hcmd2O1xuY29uc3QgcmVwbGFjZSA9IHJlcXVpcmUoJ3JlcGxhY2UtaW4tZmlsZScpO1xuY29uc3QgbG9nID0gcmVxdWlyZSgnZmFuY3ktbG9nJyk7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbmNvbnN0IGdsb2JieSA9IHJlcXVpcmUoJ2dsb2JieScpO1xuXG5cbmZ1bmN0aW9uIGxvZ0ZpbGVDaGFuZ2VzIChjaGFuZ2VzID0gW10pIHtcbiAgLy8gYGNoYW5nZXNgIHdpbGwgaGF2ZSBlbnRyaWVzIGxpa2VcbiAgLy8gICB7IGZpbGU6IFwiYXBwL2J1aWxkLmdyYWRsZVwiLCBoYXNDaGFuZ2VkOiB0cnVlIH1cbiAgY2hhbmdlcyA9IGNoYW5nZXMuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkuaGFzQ2hhbmdlZCkubWFwKChlbnRyeSkgPT4gZW50cnkuZmlsZSk7XG4gIGxvZyhgVXBkYXRlZCBmaWxlczogJHtjaGFuZ2VzLmpvaW4oJywgJyl9YCk7XG59XG5cbmNvbnN0IGNvbmZpZ3VyZSA9IGZ1bmN0aW9uIGNvbmZpZ3VyZSAoZ3VscCkge1xuICBndWxwLnRhc2soJ2dyYWRsZS12ZXJzaW9uLXVwZGF0ZScsIGFzeW5jIGZ1bmN0aW9uIGdyYWRsZVZlcnNpb25VcGRhdGUgKCkge1xuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgZ2xvYmJ5KFsnYXBwL2J1aWxkLmdyYWRsZSddKTtcbiAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhcHAvYnVpbGQuZ3JhZGxlIGZpbGUgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgZ3JhZGxlRmlsZSA9IGZpbGVzWzBdO1xuXG4gICAgY29uc3QgdmVyc2lvbiA9IGFyZ3ZbJ3BhY2thZ2UtdmVyc2lvbiddO1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYWNrYWdlIHZlcnNpb24gYXJndW1lbnQgKHVzZSBgLS1wYWNrYWdlLXZlcnNpb249eHh4YCknKTtcbiAgICB9XG4gICAgaWYgKCFzZW12ZXIudmFsaWQodmVyc2lvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2ZXJzaW9uIHNwZWNpZmllZCAnJHt2ZXJzaW9ufScuIFZlcnNpb24gc2hvdWxkIGJlIGluIHRoZSBmb3JtICcxLjIuMydgKTtcbiAgICB9XG5cbiAgICBsZXQgY2hhbmdlZEZpbGVzID0gYXdhaXQgcmVwbGFjZSh7XG4gICAgICBmaWxlczogZ3JhZGxlRmlsZSxcbiAgICAgIGZyb206IC9eXFxzKnZlcnNpb25OYW1lXFxzK1snXCJdKC4rKVsnXCJdJC9nbSxcbiAgICAgIHRvOiAobWF0Y2gpID0+IHtcbiAgICAgICAgbG9nKGBVcGRhdGluZyBncmFkbGUgYnVpbGQgZmlsZSB0byB2ZXJzaW9uIG5hbWUgJyR7dmVyc2lvbn0nYCk7XG4gICAgICAgIC8vIG1hdGNoIHdpbGwgYmUgbGlrZSBgdmVyc2lvbk5hbWUgJzEuMi4zJ2BcbiAgICAgICAgcmV0dXJuIG1hdGNoLnJlcGxhY2UoL1xcZCtcXC5cXGQrXFwuXFxkKy8sIHZlcnNpb24pO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICBsb2dGaWxlQ2hhbmdlcyhjaGFuZ2VkRmlsZXMpO1xuXG4gICAgY2hhbmdlZEZpbGVzID0gYXdhaXQgcmVwbGFjZSh7XG4gICAgICBmaWxlczogZ3JhZGxlRmlsZSxcbiAgICAgIGZyb206IC9eXFxzKnZlcnNpb25Db2RlXFxzKyguKykkL2dtLFxuICAgICAgdG86IChtYXRjaCkgPT4ge1xuICAgICAgICAvLyBtYXRjaCB3aWxsIGJlIGxpa2UgYHZlcnNpb25Db2RlIDQyYFxuICAgICAgICBjb25zdCBjb2RlTWF0Y2ggPSAvXFxkKy8uZXhlYyhtYXRjaC50cmltKCkpO1xuICAgICAgICBpZiAoIWNvZGVNYXRjaCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgZXhpc3RpbmcgdmVyc2lvbiBjb2RlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KGNvZGVNYXRjaFswXSwgMTApICsgMTtcbiAgICAgICAgbG9nKGBVcGRhdGluZyBncmFkbGUgYnVpbGQgZmlsZSB0byB2ZXJzaW9uIGNvZGUgJyR7Y29kZX0nYCk7XG4gICAgICAgIHJldHVybiBtYXRjaC5yZXBsYWNlKC9cXGQrLywgY29kZSk7XG4gICAgICB9LFxuICAgIH0pO1xuICAgIGxvZ0ZpbGVDaGFuZ2VzKGNoYW5nZWRGaWxlcyk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbmZpZ3VyZSxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBRUEsTUFBTUEsSUFBSSxHQUFHQyxPQUFPLENBQUMsT0FBRCxDQUFQLENBQWlCRCxJQUE5Qjs7QUFDQSxNQUFNRSxPQUFPLEdBQUdELE9BQU8sQ0FBQyxpQkFBRCxDQUF2Qjs7QUFDQSxNQUFNRSxHQUFHLEdB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
