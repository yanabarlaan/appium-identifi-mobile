"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._extractEntryTo = _extractEntryTo;
exports.assertValidZip = assertValidZip;
exports.default = void 0;
exports.extractAllTo = extractAllTo;
exports.readEntries = readEntries;
exports.toArchive = toArchive;
exports.toInMemoryZip = toInMemoryZip;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _yauzl = _interopRequireDefault(require("yauzl"));

var _archiver = _interopRequireDefault(require("archiver"));

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _stream = _interopRequireDefault(require("stream"));

var _fs2 = _interopRequireDefault(require("./fs"));

var _system = require("./system");

var _base64Stream = require("base64-stream");

var _util = require("./util");

var _timing = _interopRequireDefault(require("./timing"));

var _logger = _interopRequireDefault(require("./logger"));

var _getStream = _interopRequireDefault(require("get-stream"));

var _teen_process = require("teen_process");

const openZip = _bluebird.default.promisify(_yauzl.default.open);

const pipeline = _bluebird.default.promisify(_stream.default.pipeline);

const ZIP_MAGIC = 'PK';
const IFMT = 61440;
const IFDIR = 16384;
const IFLNK = 40960;

class ZipExtractor {
  zipfile;

  constructor(sourcePath, opts = {}) {
    this.zipPath = sourcePath;
    this.opts = opts;
    this.canceled = false;
  }

  extractFileName(entry) {
    return _lodash.default.isBuffer(entry.fileName) ? entry.fileName.toString(this.opts.fileNamesEncoding) : entry.fileName;
  }

  async extract() {
    const {
      dir,
      fileNamesEncoding
    } = this.opts;
    this.zipfile = await openZip(this.zipPath, {
      lazyEntries: true,
      decodeStrings: !fileNamesEncoding
    });
    this.canceled = false;
    return new _bluebird.default((resolve, reject) => {
      this.zipfile.on('error', err => {
        this.canceled = true;
        reject(err);
      });
      this.zipfile.readEntry();
      this.zipfile.on('close', () => {
        if (!this.canceled) {
          resolve();
        }
      });
      this.zipfile.on('entry', async entry => {
        if (this.canceled) {
          return;
        }

        const fileName = this.extractFileName(entry);

        if (fileName.startsWith('__MACOSX/')) {
          this.zipfile.readEntry();
          return;
        }

        const destDir = _path.default.dirname(_path.default.join(dir, fileName));

        try {
          await _fs2.default.mkdir(destDir, {
            recursive: true
          });
          const canonicalDestDir = await _fs2.default.realpath(destDir);

          const relativeDestDir = _path.default.relative(dir, canonicalDestDir);

          if (relativeDestDir.split(_path.default.sep).includes('..')) {
            new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${fileName}`);
          }

          await this.extractEntry(entry);
          this.zipfile.readEntry();
        } catch (err) {
          this.canceled = true;
          this.zipfile.close();
          reject(err);
        }
      });
    });
  }

  async extractEntry(entry) {
    if (this.canceled) {
      return;
    }

    const {
      dir
    } = this.opts;
    const fileName = this.extractFileName(entry);

    const dest = _path.default.join(dir, fileName);

    const mode = entry.externalFileAttributes >> 16 & 0xFFFF;
    const isSymlink = (mode & IFMT) === IFLNK;
    const isDir = (mode & IFMT) === IFDIR || fileName.endsWith('/') || entry.versionMadeBy >> 8 === 0 && entry.externalFileAttributes === 16;
    const procMode = this.getExtractedMode(mode, isDir) & 0o777;
    const destDir = isDir ? dest : _path.default.dirname(dest);
    const mkdirOptions = {
      recursive: true
    };

    if (isDir) {
      mkdirOptions.mode = procMode;
    }

    await _fs2.default.mkdir(destDir, mkdirOptions);

    if (isDir) {
      return;
    }

    const openReadStream = _bluebird.default.promisify(this.zipfile.openReadStream.bind(this.zipfile));

    const readStream = await openReadStream(entry);

    if (isSymlink) {
      const link = await (0, _getStream.default)(readStream);
      await _fs2.default.symlink(link, dest);
    } else {
      await pipeline(readStream, _fs2.default.createWriteStream(dest, {
        mode: procMode
      }));
    }
  }

  getExtractedMode(entryMode, isDir) {
    const {
      defaultDirMode,
      defaultFileMode
    } = this.opts;
    let mode = entryMode;

    if (mode === 0) {
      if (isDir) {
        if (defaultDirMode) {
          mode = parseInt(defaultDirMode, 10);
        }

        if (!mode) {
          mode = 0o755;
        }
      } else {
        if (defaultFileMode) {
          mode = parseInt(defaultFileMode, 10);
        }

        if (!mode) {
          mode = 0o644;
        }
      }
    }

    return mode;
  }

}

async function extractAllTo(zipFilePath, destDir, opts = {}) {
  if (!_path.default.isAbsolute(destDir)) {
    throw new Error(`Target path '${destDir}' is expected to be absolute`);
  }

  await _fs2.default.mkdir(destDir, {
    recursive: true
  });
  const dir = await _fs2.default.realpath(destDir);

  if (opts.useSystemUnzip) {
    try {
      await extractWithSystemUnzip(zipFilePath, dir);
      return;
    } catch (err) {
      _logger.default.warn('unzip failed; falling back to JS: %s', err.stderr || err.message);
    }
  }

  const extractor = new ZipExtractor(zipFilePath, { ...opts,
    dir
  });
  await extractor.extract();
}

async function extractWithSystemUnzip(zipFilePath, destDir) {
  const isWindowsHost = (0, _system.isWindows)();
  let executablePath;

  try {
    executablePath = await getExecutablePath(isWindowsHost ? 'powershell.exe' : 'unzip');
  } catch (e) {
    throw new Error('Could not find system unzip');
  }

  if (isWindowsHost) {
    await (0, _teen_process.exec)(executablePath, ['-command', 'Expand-Archive', '-LiteralPath', zipFilePath, '-DestinationPath', destDir, '-Force']);
  } else {
    await (0, _teen_process.exec)(executablePath, ['-q', '-o', zipFilePath, '-d', destDir]);
  }
}

async function _extractEntryTo(zipFile, entry, destDir) {
  const dstPath = _path.default.resolve(destDir, entry.fileName);

  if (/\/$/.test(entry.fileName)) {
    if (!(await _fs2.default.exists(dstPath))) {
      await _fs2.default.mkdirp(dstPath);
    }

    return;
  } else if (!(await _fs2.default.exists(_path.default.dirname(dstPath)))) {
    await _fs2.default.mkdirp(_path.default.dirname(dstPath));
  }

  const writeStream = (0, _fs.createWriteStream)(dstPath, {
    flags: 'w'
  });
  const writeStreamPromise = new _bluebird.default((resolve, reject) => {
    writeStream.once('finish', resolve);
    writeStream.once('error', reject);
  });
  const zipReadStream = await new _bluebird.default((resolve, reject) => {
    zipFile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipReadStream.once('end', resolve);
    zipReadStream.once('error', reject);
  });
  zipReadStream.pipe(writeStream);
  return await _bluebird.default.all([zipReadStreamPromise, writeStreamPromise]);
}

async function readEntries(zipFilePath, onEntry) {
  const zipfile = await openZip(zipFilePath, {
    lazyEntries: true
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipfile.once('end', resolve);
    zipfile.once('error', reject);
    zipfile.on('entry', async entry => {
      const res = await onEntry({
        entry,
        extractEntryTo: async destDir => await _extractEntryTo(zipfile, entry, destDir)
      });

      if (res === false) {
        return zipfile.emit('end');
      }

      zipfile.readEntry();
    });
  });
  zipfile.readEntry();
  return await zipReadStreamPromise;
}

async function toInMemoryZip(srcPath, opts = {}) {
  if (!(await _fs2.default.exists(srcPath))) {
    throw new Error(`No such file or folder: ${srcPath}`);
  }

  const {
    isMetered = true,
    encodeToBase64 = false,
    maxSize = 1 * _util.GiB,
    level = 9
  } = opts;
  const resultBuffers = [];
  let resultBuffersSize = 0;
  const resultWriteStream = new _stream.default.Writable({
    write: (buffer, encoding, next) => {
      resultBuffers.push(buffer);
      resultBuffersSize += buffer.length;

      if (maxSize > 0 && resultBuffersSize > maxSize) {
        resultWriteStream.emit('error', new Error(`The size of the resulting ` + `archive must not be greater than ${(0, _util.toReadableSizeString)(maxSize)}`));
      }

      next();
    }
  });
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });
  let srcSize = null;
  const base64EncoderStream = encodeToBase64 ? new _base64Stream.Base64Encode() : null;
  const resultWriteStreamPromise = new _bluebird.default((resolve, reject) => {
    resultWriteStream.once('error', e => {
      if (base64EncoderStream) {
        archive.unpipe(base64EncoderStream);
        base64EncoderStream.unpipe(resultWriteStream);
      } else {
        archive.unpipe(resultWriteStream);
      }

      archive.abort();
      archive.destroy();
      reject(e);
    });
    resultWriteStream.once('finish', () => {
      srcSize = archive.pointer();
      resolve();
    });
  });
  const archiveStreamPromise = new _bluebird.default((resolve, reject) => {
    archive.once('finish', resolve);
    archive.once('error', e => reject(new Error(`Failed to archive '${srcPath}': ${e.message}`)));
  });
  const timer = isMetered ? new _timing.default().start() : null;

  if ((await _fs2.default.stat(srcPath)).isDirectory()) {
    archive.directory(srcPath, false);
  } else {
    archive.file(srcPath, {
      name: _path.default.basename(srcPath)
    });
  }

  if (base64EncoderStream) {
    archive.pipe(base64EncoderStream);
    base64EncoderStream.pipe(resultWriteStream);
  } else {
    archive.pipe(resultWriteStream);
  }

  archive.finalize();
  await _bluebird.default.all([archiveStreamPromise, resultWriteStreamPromise]);

  if (timer) {
    _logger.default.debug(`Zipped ${encodeToBase64 ? 'and base64-encoded ' : ''}` + `'${_path.default.basename(srcPath)}' ` + (srcSize ? `(${(0, _util.toReadableSizeString)(srcSize)}) ` : '') + `in ${timer.getDuration().asSeconds.toFixed(3)}s ` + `(compression level: ${level})`);
  }

  return Buffer.concat(resultBuffers);
}

async function assertValidZip(filePath) {
  if (!(await _fs2.default.exists(filePath))) {
    throw new Error(`The file at '${filePath}' does not exist`);
  }

  const {
    size
  } = await _fs2.default.stat(filePath);

  if (size < 4) {
    throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);
  }

  const fd = await _fs2.default.open(filePath, 'r');

  try {
    const buffer = Buffer.alloc(ZIP_MAGIC.length);
    await _fs2.default.read(fd, buffer, 0, ZIP_MAGIC.length, 0);
    const signature = buffer.toString('ascii');

    if (signature !== ZIP_MAGIC) {
      throw new Error(`The file signature '${signature}' of '${filePath}' ` + `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);
    }

    return true;
  } finally {
    await _fs2.default.close(fd);
  }
}

async function toArchive(dstPath, src = {}, opts = {}) {
  const {
    level = 9
  } = opts;
  const {
    pattern = '**/*',
    cwd = _path.default.dirname(dstPath),
    ignore = []
  } = src;
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });

  const stream = _fs2.default.createWriteStream(dstPath);

  return await new _bluebird.default((resolve, reject) => {
    archive.glob(pattern, {
      cwd,
      ignore
    }).on('error', reject).pipe(stream);
    stream.on('error', e => {
      archive.unpipe(stream);
      archive.abort();
      archive.destroy();
      reject(e);
    }).on('finish', resolve);
    archive.finalize();
  });
}

const getExecutablePath = _lodash.default.memoize(async function getExecutablePath(binaryName) {
  const fullPath = await _fs2.default.which(binaryName);

  _logger.default.debug(`Found '%s' at '%s'`, binaryName, fullPath);

  return fullPath;
});

var _default = {
  extractAllTo,
  readEntries,
  toInMemoryZip,
  assertValidZip,
  toArchive
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJvcGVuWmlwIiwiQiIsInByb21pc2lmeSIsInlhdXpsIiwib3BlbiIsInBpcGVsaW5lIiwic3RyZWFtIiwiWklQX01BR0lDIiwiSUZNVCIsIklGRElSIiwiSUZMTksiLCJaaXBFeHRyYWN0b3IiLCJ6aXBmaWxlIiwiY29uc3RydWN0b3IiLCJzb3VyY2VQYXRoIiwib3B0cyIsInppcFBhdGgiLCJjYW5jZWxlZCIsImV4dHJhY3RGaWxlTmFtZSIsImVudHJ5IiwiXyIsImlzQnVmZmVyIiwiZmlsZU5hbWUiLCJ0b1N0cmluZyIsImZpbGVOYW1lc0VuY29kaW5nIiwiZXh0cmFjdCIsImRpciIsImxhenlFbnRyaWVzIiwiZGVjb2RlU3RyaW5ncyIsInJlc29sdmUiLCJyZWplY3QiLCJvbiIsImVyciIsInJlYWRFbnRyeSIsInN0YXJ0c1dpdGgiLCJkZXN0RGlyIiwicGF0aCIsImRpcm5hbWUiLCJqb2luIiwiZnMiLCJta2RpciIsInJlY3Vyc2l2ZSIsImNhbm9uaWNhbERlc3REaXIiLCJyZWFscGF0aCIsInJlbGF0aXZlRGVzdERpciIsInJlbGF0aXZlIiwic3BsaXQiLCJzZXAiLCJpbmNsdWRlcyIsIkVycm9yIiwiZXh0cmFjdEVudHJ5IiwiY2xvc2UiLCJkZXN0IiwibW9kZSIsImV4dGVybmFsRmlsZUF0dHJpYnV0ZXMiLCJpc1N5bWxpbmsiLCJpc0RpciIsImVuZHNXaXRoIiwidmVyc2lvbk1hZGVCeSIsInByb2NNb2RlIiwiZ2V0RXh0cmFjdGVkTW9kZSIsIm1rZGlyT3B0aW9ucyIsIm9wZW5SZWFkU3RyZWFtIiwiYmluZCIsInJlYWRTdHJlYW0iLCJsaW5rIiwic3ltbGluayIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiZW50cnlNb2RlIiwiZGVmYXVsdERpck1vZGUiLCJkZWZhdWx0RmlsZU1vZGUiLCJwYXJzZUludCIsImV4dHJhY3RBbGxUbyIsInppcEZpbGVQYXRoIiwiaXNBYnNvbHV0ZSIsInVzZVN5c3RlbVVuemlwIiwiZXh0cmFjdFdpdGhTeXN0ZW1VbnppcCIsImxvZyIsIndhcm4iLCJzdGRlcnIiLCJtZXNzYWdlIiwiZXh0cmFjdG9yIiwiaXNXaW5kb3dzSG9zdCIsImV4ZWN1dGFibGVQYXRoIiwiZ2V0RXhlY3V0YWJsZVBhdGgiLCJlIiwiX2V4dHJhY3RFbnRyeVRvIiwiemlwRmlsZSIsImRzdFBhdGgiLCJ0ZXN0IiwiZXhpc3RzIiwibWtkaXJwIiwid3JpdGVTdHJlYW0iLCJmbGFncyIsIndyaXRlU3RyZWFtUHJvbWlzZSIsIm9uY2UiLCJ6aXBSZWFkU3RyZWFtIiwiemlwUmVhZFN0cmVhbVByb21pc2UiLCJwaXBlIiwiYWxsIiwicmVhZEVudHJpZXMiLCJvbkVudHJ5IiwicmVzIiwiZXh0cmFjdEVudHJ5VG8iLCJlbWl0IiwidG9Jbk1lbW9yeVppcCIsInNyY1BhdGgiLCJpc01ldGVyZWQiLCJlbmNvZGVUb0Jhc2U2NCIsIm1heFNpemUiLCJHaUIiLCJsZXZlbCIsInJlc3VsdEJ1ZmZlcnMiLCJyZXN1bHRCdWZmZXJzU2l6ZSIsInJlc3VsdFdyaXRlU3RyZWFtIiwiV3JpdGFibGUiLCJ3cml0ZSIsImJ1ZmZlciIsImVuY29kaW5nIiwibmV4dCIsInB1c2giLCJsZW5ndGgiLCJhcmNoaXZlIiwiemxpYiIsInNyY1NpemUiLCJiYXNlNjRFbmNvZGVyU3RyZWFtIiwiQmFzZTY0RW5jb2RlIiwicmVzdWx0V3JpdGVTdHJlYW1Qcm9taXNlIiwidW5waXBlIiwiYWJvcnQiLCJkZXN0cm95IiwicG9pbnRlciIsImFyY2hpdmVTdHJlYW1Qcm9taXNlIiwidGltZXIiLCJUaW1lciIsInN0YXJ0Iiwic3RhdCIsImlzRGlyZWN0b3J5IiwiZGlyZWN0b3J5IiwiZmlsZSIsIm5hbWUiLCJiYXNlbmFtZSIsImZpbmFsaXplIiwiZGVidWciLCJnZXREdXJhdGlvbiIsImFzU2Vjb25kcyIsInRvRml4ZWQiLCJCdWZmZXIiLCJjb25jYXQiLCJhc3NlcnRWYWxpZFppcCIsImZpbGVQYXRoIiwic2l6ZSIsImZkIiwiYWxsb2MiLCJyZWFkIiwic2lnbmF0dXJlIiwidG9BcmNoaXZlIiwic3JjIiwicGF0dGVybiIsImN3ZCIsImlnbm9yZSIsImdsb2IiLCJtZW1vaXplIiwiYmluYXJ5TmFtZSIsImZ1bGxQYXRoIiwid2hpY2giXSwic291cmNlcyI6WyIuLi8uLi9saWIvemlwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeWF1emwgZnJvbSAneWF1emwnO1xuaW1wb3J0IGFyY2hpdmVyIGZyb20gJ2FyY2hpdmVyJztcbmltcG9ydCB7IGNyZWF0ZVdyaXRlU3RyZWFtIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgZnMgZnJvbSAnLi9mcyc7XG5pbXBvcnQgeyBpc1dpbmRvd3MgfSBmcm9tICcuL3N5c3RlbSc7XG5pbXBvcnQgeyBCYXNlNjRFbmNvZGUgfSBmcm9tICdiYXNlNjQtc3RyZWFtJztcbmltcG9ydCB7IHRvUmVhZGFibGVTaXplU3RyaW5nLCBHaUIgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vdGltaW5nJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IGdldFN0cmVhbSBmcm9tICdnZXQtc3RyZWFtJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuXG4vKipcbiAqIEB0eXBlIHsocGF0aDogc3RyaW5nLCBvcHRpb25zPzogeWF1emwuT3B0aW9ucykgPT4gUHJvbWlzZTx5YXV6bC5aaXBGaWxlPn1cbiAqL1xuY29uc3Qgb3BlblppcCA9IEIucHJvbWlzaWZ5KHlhdXpsLm9wZW4pO1xuLyoqXG4gKiBAdHlwZSB7KHNvdXJjZTogTm9kZUpTLlJlYWRhYmxlU3RyZWFtLCBkZXN0aW5hdGlvbjogTm9kZUpTLldyaXRhYmxlU3RyZWFtKSA9PiBQcm9taXNlPE5vZGVKUy5Xcml0YWJsZVN0cmVhbT59XG4gKi9cbmNvbnN0IHBpcGVsaW5lID0gQi5wcm9taXNpZnkoc3RyZWFtLnBpcGVsaW5lKTtcbmNvbnN0IFpJUF9NQUdJQyA9ICdQSyc7XG5jb25zdCBJRk1UID0gNjE0NDA7XG5jb25zdCBJRkRJUiA9IDE2Mzg0O1xuY29uc3QgSUZMTksgPSA0MDk2MDtcblxuLy8gVGhpcyBjbGFzcyBpcyBtb3N0bHkgY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21heG9nZGVuL2V4dHJhY3QtemlwL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5jbGFzcyBaaXBFeHRyYWN0b3Ige1xuICAvKiogQHR5cGUge3lhdXpsLlppcEZpbGV9ICovXG4gIHppcGZpbGU7XG5cbiAgY29uc3RydWN0b3IgKHNvdXJjZVBhdGgsIG9wdHMgPSB7fSkge1xuICAgIHRoaXMuemlwUGF0aCA9IHNvdXJjZVBhdGg7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG4gIH1cblxuICBleHRyYWN0RmlsZU5hbWUgKGVudHJ5KSB7XG4gICAgcmV0dXJuIF8uaXNCdWZmZXIoZW50cnkuZmlsZU5hbWUpID8gZW50cnkuZmlsZU5hbWUudG9TdHJpbmcodGhpcy5vcHRzLmZpbGVOYW1lc0VuY29kaW5nKSA6IGVudHJ5LmZpbGVOYW1lO1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdCAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGlyLFxuICAgICAgZmlsZU5hbWVzRW5jb2RpbmcsXG4gICAgfSA9IHRoaXMub3B0cztcbiAgICB0aGlzLnppcGZpbGUgPSBhd2FpdCBvcGVuWmlwKHRoaXMuemlwUGF0aCwge1xuICAgICAgbGF6eUVudHJpZXM6IHRydWUsXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGhlam9zaHdvbGZlL3lhdXpsL2NvbW1pdC9jYzc0NTVhYzc4OWJhODQ5NzMxODRlNWViZGUwNTgxY2RjNGMzYjM5I2RpZmYtMDRjNmU5MGZhYWMyNjc1YWE4OWUyMTc2ZDJlZWM3ZDhSOTVcbiAgICAgIGRlY29kZVN0cmluZ3M6ICFmaWxlTmFtZXNFbmNvZGluZyxcbiAgICB9KTtcbiAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy56aXBmaWxlLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnppcGZpbGUucmVhZEVudHJ5KCk7XG5cbiAgICAgIHRoaXMuemlwZmlsZS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5jYW5jZWxlZCkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuemlwZmlsZS5vbignZW50cnknLCBhc3luYyAoZW50cnkpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZXh0cmFjdEZpbGVOYW1lKGVudHJ5KTtcbiAgICAgICAgaWYgKGZpbGVOYW1lLnN0YXJ0c1dpdGgoJ19fTUFDT1NYLycpKSB7XG4gICAgICAgICAgdGhpcy56aXBmaWxlLnJlYWRFbnRyeSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlc3REaXIgPSBwYXRoLmRpcm5hbWUocGF0aC5qb2luKGRpciwgZmlsZU5hbWUpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBmcy5ta2RpcihkZXN0RGlyLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG5cbiAgICAgICAgICBjb25zdCBjYW5vbmljYWxEZXN0RGlyID0gYXdhaXQgZnMucmVhbHBhdGgoZGVzdERpcik7XG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVEZXN0RGlyID0gcGF0aC5yZWxhdGl2ZShkaXIsIGNhbm9uaWNhbERlc3REaXIpO1xuXG4gICAgICAgICAgaWYgKHJlbGF0aXZlRGVzdERpci5zcGxpdChwYXRoLnNlcCkuaW5jbHVkZXMoJy4uJykpIHtcbiAgICAgICAgICAgIG5ldyBFcnJvcihgT3V0IG9mIGJvdW5kIHBhdGggXCIke2Nhbm9uaWNhbERlc3REaXJ9XCIgZm91bmQgd2hpbGUgcHJvY2Vzc2luZyBmaWxlICR7ZmlsZU5hbWV9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdGhpcy5leHRyYWN0RW50cnkoZW50cnkpO1xuICAgICAgICAgIHRoaXMuemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy56aXBmaWxlLmNsb3NlKCk7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdEVudHJ5IChlbnRyeSkge1xuICAgIGlmICh0aGlzLmNhbmNlbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGlyLFxuICAgIH0gPSB0aGlzLm9wdHM7XG5cbiAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZXh0cmFjdEZpbGVOYW1lKGVudHJ5KTtcbiAgICBjb25zdCBkZXN0ID0gcGF0aC5qb2luKGRpciwgZmlsZU5hbWUpO1xuXG4gICAgLy8gY29udmVydCBleHRlcm5hbCBmaWxlIGF0dHIgaW50IGludG8gYSBmcyBzdGF0IG1vZGUgaW50XG4gICAgY29uc3QgbW9kZSA9IChlbnRyeS5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID4+IDE2KSAmIDB4RkZGRjtcbiAgICAvLyBjaGVjayBpZiBpdCdzIGEgc3ltbGluayBvciBkaXIgKHVzaW5nIHN0YXQgbW9kZSBjb25zdGFudHMpXG4gICAgY29uc3QgaXNTeW1saW5rID0gKG1vZGUgJiBJRk1UKSA9PT0gSUZMTks7XG4gICAgY29uc3QgaXNEaXIgPSAobW9kZSAmIElGTVQpID09PSBJRkRJUlxuICAgICAgLy8gRmFpbHNhZmUsIGJvcnJvd2VkIGZyb20ganNaaXBcbiAgICAgIHx8IGZpbGVOYW1lLmVuZHNXaXRoKCcvJylcbiAgICAgIC8vIGNoZWNrIGZvciB3aW5kb3dzIHdlaXJkIHdheSBvZiBzcGVjaWZ5aW5nIGEgZGlyZWN0b3J5XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vZXh0cmFjdC16aXAvaXNzdWVzLzEzI2lzc3VlY29tbWVudC0xNTQ0OTQ1NjZcbiAgICAgIHx8IChlbnRyeS52ZXJzaW9uTWFkZUJ5ID4+IDggPT09IDAgJiYgZW50cnkuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA9PT0gMTYpO1xuICAgIGNvbnN0IHByb2NNb2RlID0gdGhpcy5nZXRFeHRyYWN0ZWRNb2RlKG1vZGUsIGlzRGlyKSAmIDBvNzc3O1xuICAgIC8vIGFsd2F5cyBlbnN1cmUgZm9sZGVycyBhcmUgY3JlYXRlZFxuICAgIGNvbnN0IGRlc3REaXIgPSBpc0RpciA/IGRlc3QgOiBwYXRoLmRpcm5hbWUoZGVzdCk7XG4gICAgY29uc3QgbWtkaXJPcHRpb25zID0geyByZWN1cnNpdmU6IHRydWUgfTtcbiAgICBpZiAoaXNEaXIpIHtcbiAgICAgIG1rZGlyT3B0aW9ucy5tb2RlID0gcHJvY01vZGU7XG4gICAgfVxuICAgIGF3YWl0IGZzLm1rZGlyKGRlc3REaXIsIG1rZGlyT3B0aW9ucyk7XG4gICAgaWYgKGlzRGlyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHsoZW50cnk6IHlhdXpsLkVudHJ5KSA9PiBQcm9taXNlPE5vZGVKUy5SZWFkYWJsZVN0cmVhbT59ICovXG4gICAgY29uc3Qgb3BlblJlYWRTdHJlYW0gPSBCLnByb21pc2lmeSh0aGlzLnppcGZpbGUub3BlblJlYWRTdHJlYW0uYmluZCh0aGlzLnppcGZpbGUpKTtcbiAgICBjb25zdCByZWFkU3RyZWFtID0gYXdhaXQgb3BlblJlYWRTdHJlYW0oZW50cnkpO1xuICAgIGlmIChpc1N5bWxpbmspIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBhd2FpdCBnZXRTdHJlYW0ocmVhZFN0cmVhbSk7XG4gICAgICBhd2FpdCBmcy5zeW1saW5rKGxpbmssIGRlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBwaXBlbGluZShyZWFkU3RyZWFtLCBmcy5jcmVhdGVXcml0ZVN0cmVhbShkZXN0LCB7IG1vZGU6IHByb2NNb2RlIH0pKTtcbiAgICB9XG4gIH1cblxuICBnZXRFeHRyYWN0ZWRNb2RlIChlbnRyeU1vZGUsIGlzRGlyKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVmYXVsdERpck1vZGUsXG4gICAgICBkZWZhdWx0RmlsZU1vZGUsXG4gICAgfSA9IHRoaXMub3B0cztcblxuICAgIGxldCBtb2RlID0gZW50cnlNb2RlO1xuICAgIC8vIFNldCBkZWZhdWx0cywgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKG1vZGUgPT09IDApIHtcbiAgICAgIGlmIChpc0Rpcikge1xuICAgICAgICBpZiAoZGVmYXVsdERpck1vZGUpIHtcbiAgICAgICAgICBtb2RlID0gcGFyc2VJbnQoZGVmYXVsdERpck1vZGUsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgIG1vZGUgPSAwbzc1NTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRlZmF1bHRGaWxlTW9kZSkge1xuICAgICAgICAgIG1vZGUgPSBwYXJzZUludChkZWZhdWx0RmlsZU1vZGUsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgIG1vZGUgPSAwbzY0NDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2RlO1xuICB9XG59XG5cblxuLyoqXG4gKiBAdHlwZWRlZiBFeHRyYWN0QWxsT3B0aW9uc1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSBmaWxlTmFtZXNFbmNvZGluZyBUaGUgZW5jb2RpbmcgdG8gdXNlIGZvciBleHRyYWN0ZWQgZmlsZSBuYW1lcy5cbiAqIEZvciBaSVAgYXJjaGl2ZXMgY3JlYXRlZCBvbiBNYWNPUyBpdCBpcyB1c3VhbGx5IGV4cGVjdGVkIHRvIGJlIGB1dGY4YC5cbiAqIEJ5IGRlZmF1bHQgaXQgaXMgYXV0b2RldGVjdGVkIGJhc2VkIG9uIHRoZSBlbnRyeSBtZXRhZGF0YSBhbmQgaXMgb25seSBuZWVkZWQgdG8gYmUgc2V0IGV4cGxpY2l0bHlcbiAqIGlmIHRoZSBwYXJ0aWN1bGFyIGFyY2hpdmUgZG9lcyBub3QgY29tcGx5IHRvIHRoZSBzdGFuZGFyZHMsIHdoaWNoIGxlYWRzIHRvIGNvcnJ1cHRlZCBmaWxlIG5hbWVzXG4gKiBhZnRlciBleHRyYWN0aW9uLiBPbmx5IGFwcGxpY2FibGUgaWYgc3lzdGVtIHVuemlwIGJpbmFyeSBpcyBOT1QgYmVpbmcgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHVzZVN5c3RlbVVuemlwIFtmYWxzZV0gSWYgdHJ1ZSwgYXR0ZW1wdCB0byB1c2Ugc3lzdGVtIHVuemlwOyBpZiB0aGlzIGZhaWxzLFxuICogZmFsbGJhY2sgdG8gdGhlIEpTIHVuemlwIGltcGxlbWVudGF0aW9uLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCB6aXBmaWxlIHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHppcEZpbGVQYXRoIFRoZSBmdWxsIHBhdGggdG8gdGhlIHNvdXJjZSBaSVAgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3REaXIgVGhlIGZ1bGwgcGF0aCB0byB0aGUgZGVzdGluYXRpb24gZm9sZGVyXG4gKiBAcGFyYW0ge0V4dHJhY3RBbGxPcHRpb25zfSBbb3B0c11cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEFsbFRvICh6aXBGaWxlUGF0aCwgZGVzdERpciwgb3B0cyA9IC8qKiBAdHlwZSB7RXh0cmFjdEFsbE9wdGlvbnN9ICovKHt9KSkge1xuICBpZiAoIXBhdGguaXNBYnNvbHV0ZShkZXN0RGlyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGFyZ2V0IHBhdGggJyR7ZGVzdERpcn0nIGlzIGV4cGVjdGVkIHRvIGJlIGFic29sdXRlYCk7XG4gIH1cblxuICBhd2FpdCBmcy5ta2RpcihkZXN0RGlyLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG4gIGNvbnN0IGRpciA9IGF3YWl0IGZzLnJlYWxwYXRoKGRlc3REaXIpO1xuICBpZiAob3B0cy51c2VTeXN0ZW1VbnppcCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBleHRyYWN0V2l0aFN5c3RlbVVuemlwKHppcEZpbGVQYXRoLCBkaXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oJ3VuemlwIGZhaWxlZDsgZmFsbGluZyBiYWNrIHRvIEpTOiAlcycsIGVyci5zdGRlcnIgfHwgZXJyLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBjb25zdCBleHRyYWN0b3IgPSBuZXcgWmlwRXh0cmFjdG9yKHppcEZpbGVQYXRoLCB7XG4gICAgLi4ub3B0cyxcbiAgICBkaXIsXG4gIH0pO1xuICBhd2FpdCBleHRyYWN0b3IuZXh0cmFjdCgpO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHN5c3RlbSB1bnppcCAoZS5nLiwgYC91c3IvYmluL3VuemlwYCkuIElmIGF2YWlsYWJsZSwgaXQgaXNcbiAqIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gdGhlIEpTIGltcGxlbWVudGF0aW9uLlxuICogQnkgZGVmYXVsdCBhbGwgZmlsZXMgaW4gdGhlIGRlc3REaXIgZ2V0IG92ZXJyaWRkZW4gaWYgYWxyZWFkeSBleGlzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZVBhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgc291cmNlIFpJUCBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIuXG4gKiBUaGlzIGZvbGRlciBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGV4aXN0IGJlZm9yZSBleHRyYWN0aW5nIHRoZSBhcmNoaXZlLlxuICovXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0V2l0aFN5c3RlbVVuemlwICh6aXBGaWxlUGF0aCwgZGVzdERpcikge1xuICBjb25zdCBpc1dpbmRvd3NIb3N0ID0gaXNXaW5kb3dzKCk7XG4gIGxldCBleGVjdXRhYmxlUGF0aDtcbiAgdHJ5IHtcbiAgICBleGVjdXRhYmxlUGF0aCA9IGF3YWl0IGdldEV4ZWN1dGFibGVQYXRoKFxuICAgICAgaXNXaW5kb3dzSG9zdCA/ICdwb3dlcnNoZWxsLmV4ZScgOiAndW56aXAnXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgc3lzdGVtIHVuemlwJyk7XG4gIH1cblxuICBpZiAoaXNXaW5kb3dzSG9zdCkge1xuICAgIC8vIG9uIFdpbmRvd3Mgd2UgdXNlIFBvd2VyU2hlbGwgdG8gdW56aXAgZmlsZXNcbiAgICBhd2FpdCBleGVjKGV4ZWN1dGFibGVQYXRoLCBbXG4gICAgICAnLWNvbW1hbmQnLCAnRXhwYW5kLUFyY2hpdmUnLFxuICAgICAgJy1MaXRlcmFsUGF0aCcsIHppcEZpbGVQYXRoLFxuICAgICAgJy1EZXN0aW5hdGlvblBhdGgnLCBkZXN0RGlyLFxuICAgICAgJy1Gb3JjZSdcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyAtcSBtZWFucyBxdWlldCAobm8gc3Rkb3V0KVxuICAgIC8vIC1vIG1lYW5zIG92ZXJ3cml0ZVxuICAgIC8vIC1kIGlzIHRoZSBkZXN0IGRpclxuICAgIGF3YWl0IGV4ZWMoZXhlY3V0YWJsZVBhdGgsIFtcbiAgICAgICctcScsXG4gICAgICAnLW8nLCB6aXBGaWxlUGF0aCxcbiAgICAgICctZCcsIGRlc3REaXJcbiAgICBdKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBzaW5nbGUgemlwIGVudHJ5IHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHt5YXV6bC5aaXBGaWxlfSB6aXBGaWxlIFRoZSBzb3VyY2UgWklQIHN0cmVhbVxuICogQHBhcmFtIHt5YXV6bC5FbnRyeX0gZW50cnkgVGhlIGVudHJ5IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2V4dHJhY3RFbnRyeVRvICh6aXBGaWxlLCBlbnRyeSwgZGVzdERpcikge1xuICBjb25zdCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKGRlc3REaXIsIGVudHJ5LmZpbGVOYW1lKTtcblxuICAvLyBDcmVhdGUgZGVzdCBkaXJlY3RvcnkgaWYgZG9lc24ndCBleGlzdCBhbHJlYWR5XG4gIGlmICgvXFwvJC8udGVzdChlbnRyeS5maWxlTmFtZSkpIHtcbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhkc3RQYXRoKSkge1xuICAgICAgYXdhaXQgZnMubWtkaXJwKGRzdFBhdGgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwYXRoLmRpcm5hbWUoZHN0UGF0aCkpKSB7XG4gICAgYXdhaXQgZnMubWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSB3cml0ZSBzdHJlYW1cbiAgY29uc3Qgd3JpdGVTdHJlYW0gPSBjcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoLCB7ZmxhZ3M6ICd3J30pO1xuICBjb25zdCB3cml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZXJyb3InLCByZWplY3QpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgemlwUmVhZFN0cmVhbSBhbmQgcGlwZSBkYXRhIHRvIHRoZSB3cml0ZSBzdHJlYW1cbiAgLy8gKGZvciBzb21lIG9kZCByZWFzb24gQi5wcm9taXNpZnkgZG9lc24ndCB3b3JrIG9uIHppcGZpbGUub3BlblJlYWRTdHJlYW0sIGl0IGNhdXNlcyBhbiBlcnJvciAnY2xvc2VkJylcbiAgY29uc3QgemlwUmVhZFN0cmVhbSA9IGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB6aXBGaWxlLm9wZW5SZWFkU3RyZWFtKGVudHJ5LCAoZXJyLCByZWFkU3RyZWFtKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVhZFN0cmVhbSkpO1xuICB9KTtcbiAgY29uc3QgemlwUmVhZFN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgemlwUmVhZFN0cmVhbS5vbmNlKCdlbmQnLCByZXNvbHZlKTtcbiAgICB6aXBSZWFkU3RyZWFtLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgfSk7XG4gIHppcFJlYWRTdHJlYW0ucGlwZSh3cml0ZVN0cmVhbSk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIHppcFJlYWRTdHJlYW0gYW5kIHdyaXRlU3RyZWFtIHRvIGVuZCBiZWZvcmUgcmV0dXJuaW5nXG4gIHJldHVybiBhd2FpdCBCLmFsbChbXG4gICAgemlwUmVhZFN0cmVhbVByb21pc2UsXG4gICAgd3JpdGVTdHJlYW1Qcm9taXNlLFxuICBdKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBaaXBFbnRyeVxuICogQHByb3BlcnR5IHt5YXV6bC5FbnRyeX0gZW50cnkgVGhlIGFjdHVhbCBlbnRyeSBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZXh0cmFjdEVudHJ5VG8gQW4gYXN5bmMgZnVuY3Rpb24sIHdoaWNoIGFjY2VwdHMgb25lIHBhcmFtZXRlci5cbiAqIFRoaXMgcGFyYW1ldGVyIGNvbnRhaW5zIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIgcGF0aCB0byB3aGljaCB0aGlzIGZ1bmN0aW9uIGlzIGdvaW5nIHRvIGV4dHJhY3QgdGhlIGVudHJ5LlxuICovXG5cbi8qKlxuICogR2V0IGVudHJpZXMgZm9yIGEgemlwIGZvbGRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB6aXBGaWxlUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBzb3VyY2UgWklQIGZpbGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uRW50cnkgQ2FsbGJhY2sgd2hlbiBlbnRyeSBpcyByZWFkLlxuICogVGhlIGNhbGxiYWNrIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBvbmUgYXJndW1lbnQgb2YgWmlwRW50cnkgdHlwZS5cbiAqIFRoZSBpdGVyYXRpb24gdGhyb3VnaCB0aGUgc291cmNlIHppcCBmaWxlIHdpbGwgYmkgdGVybWluYXRlZCBhcyBzb29uIGFzXG4gKiB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gZXF1YWxzIHRvIGBmYWxzZWAuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRFbnRyaWVzICh6aXBGaWxlUGF0aCwgb25FbnRyeSkge1xuICAvLyBPcGVuIGEgemlwIGZpbGUgYW5kIHN0YXJ0IHJlYWRpbmcgZW50cmllc1xuICBjb25zdCB6aXBmaWxlID0gYXdhaXQgb3BlblppcCh6aXBGaWxlUGF0aCwge2xhenlFbnRyaWVzOiB0cnVlfSk7XG4gIGNvbnN0IHppcFJlYWRTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHppcGZpbGUub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgemlwZmlsZS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICAvLyBPbiBlYWNoIGVudHJ5LCBjYWxsICdvbkVudHJ5JyBhbmQgdGhlbiByZWFkIHRoZSBuZXh0IGVudHJ5XG4gICAgemlwZmlsZS5vbignZW50cnknLCBhc3luYyAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG9uRW50cnkoe1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgZXh0cmFjdEVudHJ5VG86IGFzeW5jIChkZXN0RGlyKSA9PiBhd2FpdCBfZXh0cmFjdEVudHJ5VG8oemlwZmlsZSwgZW50cnksIGRlc3REaXIpXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB6aXBmaWxlLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHppcGZpbGUucmVhZEVudHJ5KCk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIGVudHJpZXMgdG8gZmluaXNoIGJlaW5nIGl0ZXJhdGVkIHRocm91Z2hcbiAgcmV0dXJuIGF3YWl0IHppcFJlYWRTdHJlYW1Qcm9taXNlO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFppcE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5jb2RlVG9CYXNlNjQgW2ZhbHNlXSBXaGV0aGVyIHRvIGVuY29kZVxuICogdGhlIHJlc3VsdGluZyBhcmNoaXZlIHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzTWV0ZXJlZCBbdHJ1ZV0gV2hldGhlciB0byBsb2cgdGhlIGFjdHVhbFxuICogYXJjaGl2ZXIgcGVyZm9ybWFuY2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhTaXplIFsxMDczNzQxODI0XSBUaGUgbWF4aW11bSBzaXplIG9mXG4gKiB0aGUgcmVzdWx0aW5nIGFyY2hpdmUgaW4gYnl0ZXMuIFRoaXMgaXMgc2V0IHRvIDFHQiBieSBkZWZhdWx0LCBiZWNhdXNlXG4gKiBBcHBpdW0gbGltaXRzIHRoZSBtYXhpbXVtIEhUVFAgYm9keSBzaXplIHRvIDFHQi4gQWxzbywgdGhlIE5vZGVKUyBoZWFwXG4gKiBzaXplIG11c3QgYmUgZW5vdWdoIHRvIGtlZXAgdGhlIHJlc3VsdGluZyBvYmplY3QgKHVzdWFsbHkgdGhpcyBzaXplIGlzXG4gKiBsaW1pdGVkIHRvIDEuNCBHQilcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbCBbOV0gVGhlIGNvbXByZXNzaW9uIGxldmVsLiBUaGUgbWF4aW11bVxuICogbGV2ZWwgaXMgOSAodGhlIGJlc3QgY29tcHJlc3Npb24sIHdvcnN0IHBlcmZvcm1hbmNlKS4gVGhlIG1pbmltdW1cbiAqIGNvbXByZXNzaW9uIGxldmVsIGlzIDAgKG5vIGNvbXByZXNzaW9uKS5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGNvbnRlbnRzIG9mIGxvY2FsIGRpcmVjdG9yeSB0byBhbiBpbi1tZW1vcnkgLnppcCBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBmb2xkZXIgb3IgZmlsZSBiZWluZyB6aXBwZWRcbiAqIEBwYXJhbSB7WmlwT3B0aW9uc30gb3B0cyBaaXBwaW5nIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFppcHBlZCAoYW5kIGVuY29kZWQgaWYgYGVuY29kZVRvQmFzZTY0YCBpcyB0cnV0aHkpXG4gKiBjb250ZW50IG9mIHRoZSBzb3VyY2UgcGF0aCBhcyBtZW1vcnkgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHJlYWRpbmcgdGhlIHNvdXJjZVxuICogb3IgdGhlIHNvdXJjZSBpcyB0b28gYmlnXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRvSW5NZW1vcnlaaXAgKHNyY1BhdGgsIG9wdHMgPSAvKiogQHR5cGUge1ppcE9wdGlvbnN9ICovKHt9KSkge1xuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhzcmNQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCBmaWxlIG9yIGZvbGRlcjogJHtzcmNQYXRofWApO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGlzTWV0ZXJlZCA9IHRydWUsXG4gICAgZW5jb2RlVG9CYXNlNjQgPSBmYWxzZSxcbiAgICBtYXhTaXplID0gMSAqIEdpQixcbiAgICBsZXZlbCA9IDksXG4gIH0gPSBvcHRzO1xuICBjb25zdCByZXN1bHRCdWZmZXJzID0gW107XG4gIGxldCByZXN1bHRCdWZmZXJzU2l6ZSA9IDA7XG4gIC8vIENyZWF0ZSBhIHdyaXRhYmxlIHN0cmVhbSB0aGF0IHppcCBidWZmZXJzIHdpbGwgYmUgc3RyZWFtZWQgdG9cbiAgY29uc3QgcmVzdWx0V3JpdGVTdHJlYW0gPSBuZXcgc3RyZWFtLldyaXRhYmxlKHtcbiAgICB3cml0ZTogKGJ1ZmZlciwgZW5jb2RpbmcsIG5leHQpID0+IHtcbiAgICAgIHJlc3VsdEJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgcmVzdWx0QnVmZmVyc1NpemUgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIGlmIChtYXhTaXplID4gMCAmJiByZXN1bHRCdWZmZXJzU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgcmVzdWx0V3JpdGVTdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoYFRoZSBzaXplIG9mIHRoZSByZXN1bHRpbmcgYCArXG4gICAgICAgICAgYGFyY2hpdmUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuICR7dG9SZWFkYWJsZVNpemVTdHJpbmcobWF4U2l6ZSl9YCkpO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8vIFppcCAnc3JjRGlyJyBhbmQgc3RyZWFtIGl0IHRvIHRoZSBhYm92ZSB3cml0YWJsZSBzdHJlYW1cbiAgY29uc3QgYXJjaGl2ZSA9IGFyY2hpdmVyKCd6aXAnLCB7XG4gICAgemxpYjoge2xldmVsfVxuICB9KTtcbiAgbGV0IHNyY1NpemUgPSBudWxsO1xuICBjb25zdCBiYXNlNjRFbmNvZGVyU3RyZWFtID0gZW5jb2RlVG9CYXNlNjQgPyBuZXcgQmFzZTY0RW5jb2RlKCkgOiBudWxsO1xuICBjb25zdCByZXN1bHRXcml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzdWx0V3JpdGVTdHJlYW0ub25jZSgnZXJyb3InLCAoZSkgPT4ge1xuICAgICAgaWYgKGJhc2U2NEVuY29kZXJTdHJlYW0pIHtcbiAgICAgICAgYXJjaGl2ZS51bnBpcGUoYmFzZTY0RW5jb2RlclN0cmVhbSk7XG4gICAgICAgIGJhc2U2NEVuY29kZXJTdHJlYW0udW5waXBlKHJlc3VsdFdyaXRlU3RyZWFtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyY2hpdmUudW5waXBlKHJlc3VsdFdyaXRlU3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIGFyY2hpdmUuYWJvcnQoKTtcbiAgICAgIGFyY2hpdmUuZGVzdHJveSgpO1xuICAgICAgcmVqZWN0KGUpO1xuICAgIH0pO1xuICAgIHJlc3VsdFdyaXRlU3RyZWFtLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIHNyY1NpemUgPSBhcmNoaXZlLnBvaW50ZXIoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGFyY2hpdmVTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFyY2hpdmUub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgYXJjaGl2ZS5vbmNlKCdlcnJvcicsIChlKSA9PiByZWplY3QoXG4gICAgICBuZXcgRXJyb3IoYEZhaWxlZCB0byBhcmNoaXZlICcke3NyY1BhdGh9JzogJHtlLm1lc3NhZ2V9YCkpKTtcbiAgfSk7XG4gIGNvbnN0IHRpbWVyID0gaXNNZXRlcmVkID8gbmV3IFRpbWVyKCkuc3RhcnQoKSA6IG51bGw7XG4gIGlmICgoYXdhaXQgZnMuc3RhdChzcmNQYXRoKSkuaXNEaXJlY3RvcnkoKSkge1xuICAgIGFyY2hpdmUuZGlyZWN0b3J5KHNyY1BhdGgsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBhcmNoaXZlLmZpbGUoc3JjUGF0aCwge1xuICAgICAgbmFtZTogcGF0aC5iYXNlbmFtZShzcmNQYXRoKSxcbiAgICB9KTtcbiAgfVxuICBpZiAoYmFzZTY0RW5jb2RlclN0cmVhbSkge1xuICAgIGFyY2hpdmUucGlwZShiYXNlNjRFbmNvZGVyU3RyZWFtKTtcbiAgICBiYXNlNjRFbmNvZGVyU3RyZWFtLnBpcGUocmVzdWx0V3JpdGVTdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIGFyY2hpdmUucGlwZShyZXN1bHRXcml0ZVN0cmVhbSk7XG4gIH1cbiAgYXJjaGl2ZS5maW5hbGl6ZSgpO1xuXG4gIC8vIFdhaXQgZm9yIHRoZSBzdHJlYW1zIHRvIGZpbmlzaFxuICBhd2FpdCBCLmFsbChbYXJjaGl2ZVN0cmVhbVByb21pc2UsIHJlc3VsdFdyaXRlU3RyZWFtUHJvbWlzZV0pO1xuXG4gIGlmICh0aW1lcikge1xuICAgIGxvZy5kZWJ1ZyhgWmlwcGVkICR7ZW5jb2RlVG9CYXNlNjQgPyAnYW5kIGJhc2U2NC1lbmNvZGVkICcgOiAnJ31gICtcbiAgICAgIGAnJHtwYXRoLmJhc2VuYW1lKHNyY1BhdGgpfScgYCArXG4gICAgICAoc3JjU2l6ZSA/IGAoJHt0b1JlYWRhYmxlU2l6ZVN0cmluZyhzcmNTaXplKX0pIGAgOiAnJykgK1xuICAgICAgYGluICR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHMudG9GaXhlZCgzKX1zIGAgK1xuICAgICAgYChjb21wcmVzc2lvbiBsZXZlbDogJHtsZXZlbH0pYCk7XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSBhcnJheSBvZiB6aXAgYnVmZmVycyBjb25jYXRlbmF0ZWQgaW50byBvbmUgYnVmZmVyXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KHJlc3VsdEJ1ZmZlcnMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHdoZXRoZXIgdGhlIGdpdmVuIGZpbGUgaXMgYSB2YWxpZCBaSVAgYXJjaGl2ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aCAtIEZ1bGwgcGF0aCB0byB0aGUgZmlsZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhIHZhbGlkIFpJUCBhcmNoaXZlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFzc2VydFZhbGlkWmlwIChmaWxlUGF0aCkge1xuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhmaWxlUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaWxlIGF0ICcke2ZpbGVQYXRofScgZG9lcyBub3QgZXhpc3RgKTtcbiAgfVxuXG4gIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQoZmlsZVBhdGgpO1xuICBpZiAoc2l6ZSA8IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaWxlIGF0ICcke2ZpbGVQYXRofScgaXMgdG9vIHNtYWxsIHRvIGJlIGEgWklQIGFyY2hpdmVgKTtcbiAgfVxuICBjb25zdCBmZCA9IGF3YWl0IGZzLm9wZW4oZmlsZVBhdGgsICdyJyk7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKFpJUF9NQUdJQy5sZW5ndGgpO1xuICAgIGF3YWl0IGZzLnJlYWQoZmQsIGJ1ZmZlciwgMCwgWklQX01BR0lDLmxlbmd0aCwgMCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYnVmZmVyLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmIChzaWduYXR1cmUgIT09IFpJUF9NQUdJQykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBzaWduYXR1cmUgJyR7c2lnbmF0dXJlfScgb2YgJyR7ZmlsZVBhdGh9JyBgICtcbiAgICAgICAgYGlzIG5vdCBlcXVhbCB0byB0aGUgZXhwZWN0ZWQgWklQIGFyY2hpdmUgc2lnbmF0dXJlICcke1pJUF9NQUdJQ30nYCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLmNsb3NlKGZkKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIFppcENvbXByZXNzaW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsIFs5XSAtIENvbXByZXNzaW9uIGxldmVsIGluIHJhbmdlIDAuLjlcbiAqIChncmVhdGVyIG51bWJlcnMgbWVhbiBiZXR0ZXIgY29tcHJlc3Npb24sIGJ1dCBsb25nZXIgcHJvY2Vzc2luZyB0aW1lKVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgWmlwU291cmNlT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdHRlcm4gWycqKlxcLyonXSAtIEdMT0IgcGF0dGVybiBmb3IgY29tcHJlc3Npb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjd2QgLSBUaGUgc291cmNlIHJvb3QgZm9sZGVyICh0aGUgcGFyZW50IGZvbGRlciBvZlxuICogdGhlIGRlc3RpbmF0aW9uIGZpbGUgYnkgZGVmYXVsdClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtpZ25vcmVdIC0gVGhlIGxpc3Qgb2YgaWdub3JlZCBwYXR0ZXJuc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcmNoaXZlIGJhc2VkIG9uIHRoZSBnaXZlbiBnbG9iIHBhdHRlcm5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZHN0UGF0aCAtIFRoZSByZXN1bHRpbmcgYXJjaGl2ZSBwYXRoXG4gKiBAcGFyYW0ge1ppcFNvdXJjZU9wdGlvbnN9IHNyYyAtIFNvdXJjZSBvcHRpb25zXG4gKiBAcGFyYW0ge1ppcENvbXByZXNzaW9uT3B0aW9uc30gb3B0cyAtIENvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGFyY2hpdmVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdG9BcmNoaXZlIChkc3RQYXRoLCBzcmMgPSAvKiogQHR5cGUge1ppcFNvdXJjZU9wdGlvbnN9ICovKHt9KSwgb3B0cyA9IC8qKiBAdHlwZSB7WmlwQ29tcHJlc3Npb25PcHRpb25zfSAqLyh7fSkpIHtcbiAgY29uc3Qge1xuICAgIGxldmVsID0gOSxcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IHtcbiAgICBwYXR0ZXJuID0gJyoqLyonLFxuICAgIGN3ZCA9IHBhdGguZGlybmFtZShkc3RQYXRoKSxcbiAgICBpZ25vcmUgPSBbXSxcbiAgfSA9IHNyYztcbiAgY29uc3QgYXJjaGl2ZSA9IGFyY2hpdmVyKCd6aXAnLCB7IHpsaWI6IHsgbGV2ZWwgfX0pO1xuICBjb25zdCBzdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoKTtcbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhcmNoaXZlXG4gICAgICAuZ2xvYihwYXR0ZXJuLCB7XG4gICAgICAgIGN3ZCxcbiAgICAgICAgaWdub3JlLFxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAucGlwZShzdHJlYW0pO1xuICAgIHN0cmVhbVxuICAgICAgLm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgIGFyY2hpdmUudW5waXBlKHN0cmVhbSk7XG4gICAgICAgIGFyY2hpdmUuYWJvcnQoKTtcbiAgICAgICAgYXJjaGl2ZS5kZXN0cm95KCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0pXG4gICAgICAub24oJ2ZpbmlzaCcsIHJlc29sdmUpO1xuICAgIGFyY2hpdmUuZmluYWxpemUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRmluZHMgYW5kIG1lbW9pemVzIHRoZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGV4ZWN1dGFibGUuXG4gKiBSZWplY3RzIGlmIGl0IGlzIG5vdCBmb3VuZC5cbiAqL1xuY29uc3QgZ2V0RXhlY3V0YWJsZVBhdGggPSBfLm1lbW9pemUoXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBGdWxsIFBhdGggdG8gdGhlIGV4ZWN1dGFibGVcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEV4ZWN1dGFibGVQYXRoIChiaW5hcnlOYW1lKSB7XG4gICAgY29uc3QgZnVsbFBhdGggPSBhd2FpdCBmcy53aGljaChiaW5hcnlOYW1lKTtcbiAgICBsb2cuZGVidWcoYEZvdW5kICclcycgYXQgJyVzJ2AsIGJpbmFyeU5hbWUsIGZ1bGxQYXRoKTtcbiAgICByZXR1cm4gZnVsbFBhdGg7XG4gIH1cbik7XG5cbmV4cG9ydCB7IGV4dHJhY3RBbGxUbywgcmVhZEVudHJpZXMsIHRvSW5NZW1vcnlaaXAsIF9leHRyYWN0RW50cnlUbyxcbiAgYXNzZXJ0VmFsaWRaaXAsIHRvQXJjaGl2ZSB9O1xuZXhwb3J0IGRlZmF1bHQgeyBleHRyYWN0QWxsVG8sIHJlYWRFbnRyaWVzLCB0b0luTWVtb3J5WmlwLCBhc3NlcnRWYWxpZFppcCwgdG9BcmNoaXZlIH07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBS0EsTUFBTUEsT0FBTyxHQUFHQyxrQkFBRUMsU0FBRixDQUFZQyxlQUFNQyxJQUFsQixDQUFoQjs7QUFJQSxNQUFNQyxRQUFRLEdBQUdKLGtCQUFFQyxTQUFGLENBQVlJLGdCQUFPRCxRQUFuQixDQUFqQjs7QUFDQSxNQUFNRSxTQUFTLEdBQUcsSUFBbEI7QUFDQSxNQUFNQyxJQUFJLEdBQUcsS0FBYjtBQUNBLE1BQU1DLEtBQUssR0FBRyxLQUFkO0FBQ0EsTUFBTUMsS0FBSyxHQUFHLEtBQWQ7O0FBR0EsTUFBTUMsWUFBTixDQUFtQjtFQUVqQkMsT0FBTzs7RUFFUEMsV0FBVyxDQUFFQyxVQUFGLEVBQWNDLElBQUksR0FBRyxFQUFyQixFQUF5QjtJQUNsQyxLQUFLQyxPQUFMLEdBQWVGLFVBQWY7SUFDQSxLQUFLQyxJQUFMLEdBQVlBLElBQVo7SUFDQSxLQUFLRSxRQUFMLEdBQWdCLEtBQWhCO0VBQ0Q7O0VBRURDLGVBQWUsQ0FBRUMsS0FBRixFQUFTO0lBQ3RCLE9BQU9DLGdCQUFFQyxRQUFGLENBQVdGLEtBQUssQ0FBQ0csUUFBakIsSUFBNkJILEtBQUssQ0FBQ0csUUFBTixDQUFlQyxRQUFmLENBQXdCLEtBQUtSLElBQUwsQ0FBVVMsaUJBQWxDLENBQTdCLEdBQW9GTCxLQUFLLENBQUNHLFFBQWpHO0VBQ0Q7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