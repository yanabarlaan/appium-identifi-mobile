"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureApp = configureApp;
exports.default = void 0;
exports.duplicateKeys = duplicateKeys;
exports.generateDriverLogPrefix = generateDriverLogPrefix;
exports.isPackageOrBundle = isPackageOrBundle;
exports.parseCapsArray = parseCapsArray;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _url = _interopRequireDefault(require("url"));

var _logger = _interopRequireDefault(require("./logger"));

var _support = require("@appium/support");

var _lruCache = _interopRequireDefault(require("lru-cache"));

var _asyncLock = _interopRequireDefault(require("async-lock"));

var _axios = _interopRequireDefault(require("axios"));

const IPA_EXT = '.ipa';
const ZIP_EXTS = ['.zip', IPA_EXT];
const ZIP_MIME_TYPES = ['application/zip', 'application/x-zip-compressed', 'multipart/x-zip'];
const CACHED_APPS_MAX_AGE = 1000 * 60 * 60 * 24;
const MAX_CACHED_APPS = 1024;
const APPLICATIONS_CACHE = new _lruCache.default({
  max: MAX_CACHED_APPS,
  ttl: CACHED_APPS_MAX_AGE,
  updateAgeOnGet: true,
  dispose: (app, {
    fullPath
  }) => {
    _logger.default.info(`The application '${app}' cached at '${fullPath}' has ` + `expired after ${CACHED_APPS_MAX_AGE}ms`);

    if (fullPath) {
      _support.fs.rimraf(fullPath);
    }
  },
  noDisposeOnSet: true
});
const APPLICATIONS_CACHE_GUARD = new _asyncLock.default();
const SANITIZE_REPLACEMENT = '-';
const DEFAULT_BASENAME = 'appium-app';
const APP_DOWNLOAD_TIMEOUT_MS = 120 * 1000;
process.on('exit', () => {
  if (APPLICATIONS_CACHE.size === 0) {
    return;
  }

  const appPaths = [...APPLICATIONS_CACHE.values()].map(({
    fullPath
  }) => fullPath);

  _logger.default.debug(`Performing cleanup of ${appPaths.length} cached ` + _support.util.pluralize('application', appPaths.length));

  for (const appPath of appPaths) {
    try {
      _support.fs.rimrafSync(appPath);
    } catch (e) {
      _logger.default.warn(e.message);
    }
  }
});

async function retrieveHeaders(link) {
  try {
    return (await (0, _axios.default)({
      url: link,
      method: 'HEAD',
      timeout: 5000
    })).headers;
  } catch (e) {
    _logger.default.info(`Cannot send HEAD request to '${link}'. Original error: ${e.message}`);
  }

  return {};
}

function getCachedApplicationPath(link, currentAppProps = {}, cachedAppInfo = {}) {
  const refresh = () => {
    _logger.default.debug(`A fresh copy of the application is going to be downloaded from ${link}`);

    return null;
  };

  if (!_lodash.default.isPlainObject(cachedAppInfo) || !_lodash.default.isPlainObject(currentAppProps)) {
    return refresh();
  }

  const {
    lastModified: currentModified,
    immutable: currentImmutable,
    maxAge: currentMaxAge
  } = currentAppProps;
  const {
    lastModified,
    immutable,
    timestamp,
    fullPath
  } = cachedAppInfo;

  if (lastModified && currentModified) {
    if (currentModified.getTime() <= lastModified.getTime()) {
      _logger.default.debug(`The application at ${link} has not been modified since ${lastModified}`);

      return fullPath;
    }

    _logger.default.debug(`The application at ${link} has been modified since ${lastModified}`);

    return refresh();
  }

  if (immutable && currentImmutable) {
    _logger.default.debug(`The application at ${link} is immutable`);

    return fullPath;
  }

  if (currentMaxAge && timestamp) {
    const msLeft = timestamp + currentMaxAge * 1000 - Date.now();

    if (msLeft > 0) {
      _logger.default.debug(`The cached application '${_path.default.basename(fullPath)}' will expire in ${msLeft / 1000}s`);

      return fullPath;
    }

    _logger.default.debug(`The cached application '${_path.default.basename(fullPath)}' has expired`);
  }

  return refresh();
}

function verifyAppExtension(app, supportedAppExtensions) {
  if (supportedAppExtensions.map(_lodash.default.toLower).includes(_lodash.default.toLower(_path.default.extname(app)))) {
    return app;
  }

  throw new Error(`New app path '${app}' did not have ` + `${_support.util.pluralize('extension', supportedAppExtensions.length, false)}: ` + supportedAppExtensions);
}

async function calculateFolderIntegrity(folderPath) {
  return (await _support.fs.glob('**/*', {
    cwd: folderPath,
    strict: false,
    nosort: true
  })).length;
}

async function calculateFileIntegrity(filePath) {
  return await _support.fs.hash(filePath);
}

async function isAppIntegrityOk(currentPath, expectedIntegrity = {}) {
  if (!(await _support.fs.exists(currentPath))) {
    return false;
  }

  return (await _support.fs.stat(currentPath)).isDirectory() ? (await calculateFolderIntegrity(currentPath)) >= (expectedIntegrity === null || expectedIntegrity === void 0 ? void 0 : expectedIntegrity.folder) : (await calculateFileIntegrity(currentPath)) === (expectedIntegrity === null || expectedIntegrity === void 0 ? void 0 : expectedIntegrity.file);
}

async function configureApp(app, options = {}) {
  if (!_lodash.default.isString(app)) {
    return;
  }

  let supportedAppExtensions;
  const {
    onPostProcess
  } = _lodash.default.isPlainObject(options) ? options : {};

  if (_lodash.default.isString(options)) {
    supportedAppExtensions = [options];
  } else if (_lodash.default.isArray(options)) {
    supportedAppExtensions = options;
  } else if (_lodash.default.isPlainObject(options)) {
    supportedAppExtensions = options.supportedExtensions;
  }

  if (_lodash.default.isEmpty(supportedAppExtensions)) {
    throw new Error(`One or more supported app extensions must be provided`);
  }

  let newApp = app;
  let shouldUnzipApp = false;
  let packageHash = null;
  let headers = null;
  const remoteAppProps = {
    lastModified: null,
    immutable: false,
    maxAge: null
  };

  const {
    protocol,
    pathname
  } = _url.default.parse(newApp);

  const isUrl = ['http:', 'https:'].includes(protocol);
  const cachedAppInfo = APPLICATIONS_CACHE.get(app);
  return await APPLICATIONS_CACHE_GUARD.acquire(app, async () => {
    if (isUrl) {
      _logger.default.info(`Using downloadable app '${newApp}'`);

      headers = await retrieveHeaders(newApp);

      if (!_lodash.default.isEmpty(headers)) {
        if (headers['last-modified']) {
          remoteAppProps.lastModified = new Date(headers['last-modified']);
        }

        _logger.default.debug(`Last-Modified: ${headers['last-modified']}`);

        if (headers['cache-control']) {
          remoteAppProps.immutable = /\bimmutable\b/i.test(headers['cache-control']);
          const maxAgeMatch = /\bmax-age=(\d+)\b/i.exec(headers['cache-control']);

          if (maxAgeMatch) {
            remoteAppProps.maxAge = parseInt(maxAgeMatch[1], 10);
          }
        }

        _logger.default.debug(`Cache-Control: ${headers['cache-control']}`);
      }

      const cachedPath = getCachedApplicationPath(app, remoteAppProps, cachedAppInfo);

      if (cachedPath) {
        if (await isAppIntegrityOk(cachedPath, cachedAppInfo === null || cachedAppInfo === void 0 ? void 0 : cachedAppInfo.integrity)) {
          _logger.default.info(`Reusing previously downloaded application at '${cachedPath}'`);

          return verifyAppExtension(cachedPath, supportedAppExtensions);
        }

        _logger.default.info(`The application at '${cachedPath}' does not exist anymore ` + `or its integrity has been damaged. Deleting it from the internal cache`);

        APPLICATIONS_CACHE.delete(app);
      }

      let fileName = null;

      const basename = _support.fs.sanitizeName(_path.default.basename(decodeURIComponent(pathname)), {
        replacement: SANITIZE_REPLACEMENT
      });

      const extname = _path.default.extname(basename);

      if (ZIP_EXTS.includes(extname)) {
        fileName = basename;
        shouldUnzipApp = true;
      }

      if (headers['content-type']) {
        const ct = headers['content-type'];

        _logger.default.debug(`Content-Type: ${ct}`);

        if (ZIP_MIME_TYPES.some(mimeType => new RegExp(`\\b${_lodash.default.escapeRegExp(mimeType)}\\b`).test(ct))) {
          if (!fileName) {
            fileName = `${DEFAULT_BASENAME}.zip`;
          }

          shouldUnzipApp = true;
        }
      }

      if (headers['content-disposition'] && /^attachment/i.test(headers['content-disposition'])) {
        _logger.default.debug(`Content-Disposition: ${headers['content-disposition']}`);

        const match = /filename="([^"]+)/i.exec(headers['content-disposition']);

        if (match) {
          fileName = _support.fs.sanitizeName(match[1], {
            replacement: SANITIZE_REPLACEMENT
          });
          shouldUnzipApp = shouldUnzipApp || ZIP_EXTS.includes(_path.default.extname(fileName));
        }
      }

      if (!fileName) {
        const resultingName = basename ? basename.substring(0, basename.length - extname.length) : DEFAULT_BASENAME;
        let resultingExt = extname;

        if (!supportedAppExtensions.includes(resultingExt)) {
          _logger.default.info(`The current file extension '${resultingExt}' is not supported. ` + `Defaulting to '${_lodash.default.first(supportedAppExtensions)}'`);

          resultingExt = _lodash.default.first(supportedAppExtensions);
        }

        fileName = `${resultingName}${resultingExt}`;
      }

      const targetPath = await _support.tempDir.path({
        prefix: fileName,
        suffix: ''
      });
      newApp = await downloadApp(newApp, targetPath);
    } else if (await _support.fs.exists(newApp)) {
      _logger.default.info(`Using local app '${newApp}'`);

      shouldUnzipApp = ZIP_EXTS.includes(_path.default.extname(newApp));
    } else {
      let errorMessage = `The application at '${newApp}' does not exist or is not accessible`;

      if (_lodash.default.isString(protocol) && protocol.length > 2) {
        errorMessage = `The protocol '${protocol}' used in '${newApp}' is not supported. ` + `Only http: and https: protocols are supported`;
      }

      throw new Error(errorMessage);
    }

    const isPackageAFile = (await _support.fs.stat(newApp)).isFile();

    if (isPackageAFile) {
      packageHash = await calculateFileIntegrity(newApp);
    }

    if (isPackageAFile && shouldUnzipApp && !_lodash.default.isFunction(onPostProcess)) {
      const archivePath = newApp;

      if (packageHash === (cachedAppInfo === null || cachedAppInfo === void 0 ? void 0 : cachedAppInfo.packageHash)) {
        const {
          fullPath
        } = cachedAppInfo;

        if (await isAppIntegrityOk(fullPath, cachedAppInfo === null || cachedAppInfo === void 0 ? void 0 : cachedAppInfo.integrity)) {
          if (archivePath !== app) {
            await _support.fs.rimraf(archivePath);
          }

          _logger.default.info(`Will reuse previously cached application at '${fullPath}'`);

          return verifyAppExtension(fullPath, supportedAppExtensions);
        }

        _logger.default.info(`The application at '${fullPath}' does not exist anymore ` + `or its integrity has been damaged. Deleting it from the cache`);

        APPLICATIONS_CACHE.delete(app);
      }

      const tmpRoot = await _support.tempDir.openDir();

      try {
        newApp = await unzipApp(archivePath, tmpRoot, supportedAppExtensions);
      } finally {
        if (newApp !== archivePath && archivePath !== app) {
          await _support.fs.rimraf(archivePath);
        }
      }

      _logger.default.info(`Unzipped local app to '${newApp}'`);
    } else if (!_path.default.isAbsolute(newApp)) {
      newApp = _path.default.resolve(process.cwd(), newApp);

      _logger.default.warn(`The current application path '${app}' is not absolute ` + `and has been rewritten to '${newApp}'. Consider using absolute paths rather than relative`);

      app = newApp;
    }

    const storeAppInCache = async appPathToCache => {
      const cachedFullPath = cachedAppInfo === null || cachedAppInfo === void 0 ? void 0 : cachedAppInfo.fullPath;

      if (cachedFullPath && cachedFullPath !== appPathToCache) {
        await _support.fs.rimraf(cachedFullPath);
      }

      const integrity = {};

      if ((await _support.fs.stat(appPathToCache)).isDirectory()) {
        integrity.folder = await calculateFolderIntegrity(appPathToCache);
      } else {
        integrity.file = await calculateFileIntegrity(appPathToCache);
      }

      APPLICATIONS_CACHE.set(app, { ...remoteAppProps,
        timestamp: Date.now(),
        packageHash,
        integrity,
        fullPath: appPathToCache
      });
      return appPathToCache;
    };

    if (_lodash.default.isFunction(onPostProcess)) {
      const result = await onPostProcess({
        cachedAppInfo: _lodash.default.clone(cachedAppInfo),
        isUrl,
        headers: _lodash.default.clone(headers),
        appPath: newApp
      });
      return !(result !== null && result !== void 0 && result.appPath) || app === (result === null || result === void 0 ? void 0 : result.appPath) || !(await _support.fs.exists(result === null || result === void 0 ? void 0 : result.appPath)) ? newApp : await storeAppInCache(result.appPath);
    }

    verifyAppExtension(newApp, supportedAppExtensions);
    return app !== newApp && (packageHash || _lodash.default.values(remoteAppProps).some(Boolean)) ? await storeAppInCache(newApp) : newApp;
  });
}

async function downloadApp(app, targetPath) {
  const {
    href
  } = _url.default.parse(app);

  try {
    await _support.net.downloadFile(href, targetPath, {
      timeout: APP_DOWNLOAD_TIMEOUT_MS
    });
  } catch (err) {
    throw new Error(`Unable to download the app: ${err.message}`);
  }

  return targetPath;
}

async function unzipApp(zipPath, dstRoot, supportedAppExtensions) {
  await _support.zip.assertValidZip(zipPath);

  if (!_lodash.default.isArray(supportedAppExtensions)) {
    supportedAppExtensions = [supportedAppExtensions];
  }

  const tmpRoot = await _support.tempDir.openDir();

  try {
    _logger.default.debug(`Unzipping '${zipPath}'`);

    const timer = new _support.timing.Timer().start();
    const useSystemUnzipEnv = process.env.APPIUM_PREFER_SYSTEM_UNZIP;
    const useSystemUnzip = _lodash.default.isEmpty(useSystemUnzipEnv) || !['0', 'false'].includes(_lodash.default.toLower(useSystemUnzipEnv));
    const extractionOpts = {
      useSystemUnzip
    };

    if (_path.default.extname(zipPath) === IPA_EXT) {
      _logger.default.debug(`Enforcing UTF-8 encoding on the extracted file names for '${_path.default.basename(zipPath)}'`);

      extractionOpts.fileNamesEncoding = 'utf8';
    }

    await _support.zip.extractAllTo(zipPath, tmpRoot, extractionOpts);
    const globPattern = `**/*.+(${supportedAppExtensions.map(ext => ext.replace(/^\./, '')).join('|')})`;
    const sortedBundleItems = (await _support.fs.glob(globPattern, {
      cwd: tmpRoot,
      strict: false
    })).sort((a, b) => a.split(_path.default.sep).length - b.split(_path.default.sep).length);

    if (_lodash.default.isEmpty(sortedBundleItems)) {
      _logger.default.errorAndThrow(`App unzipped OK, but we could not find any '${supportedAppExtensions}' ` + _support.util.pluralize('bundle', supportedAppExtensions.length, false) + ` in it. Make sure your archive contains at least one package having ` + `'${supportedAppExtensions}' ${_support.util.pluralize('extension', supportedAppExtensions.length, false)}`);
    }

    _logger.default.debug(`Extracted ${_support.util.pluralize('bundle item', sortedBundleItems.length, true)} ` + `from '${zipPath}' in ${Math.round(timer.getDuration().asMilliSeconds)}ms: ${sortedBundleItems}`);

    const matchedBundle = _lodash.default.first(sortedBundleItems);

    _logger.default.info(`Assuming '${matchedBundle}' is the correct bundle`);

    const dstPath = _path.default.resolve(dstRoot, _path.default.basename(matchedBundle));

    await _support.fs.mv(_path.default.resolve(tmpRoot, matchedBundle), dstPath, {
      mkdirp: true
    });
    return dstPath;
  } finally {
    await _support.fs.rimraf(tmpRoot);
  }
}

function isPackageOrBundle(app) {
  return /^([a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+)+$/.test(app);
}

function duplicateKeys(input, firstKey, secondKey) {
  if (_lodash.default.isArray(input)) {
    return input.map(item => duplicateKeys(item, firstKey, secondKey));
  }

  if (_lodash.default.isPlainObject(input)) {
    const resultObj = {};

    for (let [key, value] of _lodash.default.toPairs(input)) {
      const recursivelyCalledValue = duplicateKeys(value, firstKey, secondKey);

      if (key === firstKey) {
        resultObj[secondKey] = recursivelyCalledValue;
      } else if (key === secondKey) {
        resultObj[firstKey] = recursivelyCalledValue;
      }

      resultObj[key] = recursivelyCalledValue;
    }

    return resultObj;
  }

  return input;
}

function parseCapsArray(cap) {
  if (_lodash.default.isArray(cap)) {
    return cap;
  }

  let parsedCaps;

  try {
    parsedCaps = JSON.parse(cap);

    if (_lodash.default.isArray(parsedCaps)) {
      return parsedCaps;
    }
  } catch (ign) {
    _logger.default.warn(`Failed to parse capability as JSON array`);
  }

  if (_lodash.default.isString(cap)) {
    return [cap];
  }

  throw new Error(`must provide a string or JSON Array; received ${cap}`);
}

function generateDriverLogPrefix(obj, sessionId = null) {
  const instanceName = `${obj.constructor.name}@${_support.node.getObjectId(obj).substring(0, 4)}`;
  return sessionId ? `${instanceName} (${sessionId.substring(0, 8)})` : instanceName;
}

var _default = {
  configureApp,
  isPackageOrBundle,
  duplicateKeys,
  parseCapsArray,
  generateDriverLogPrefix
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJJUEFfRVhUIiwiWklQX0VYVFMiLCJaSVBfTUlNRV9UWVBFUyIsIkNBQ0hFRF9BUFBTX01BWF9BR0UiLCJNQVhfQ0FDSEVEX0FQUFMiLCJBUFBMSUNBVElPTlNfQ0FDSEUiLCJMUlUiLCJtYXgiLCJ0dGwiLCJ1cGRhdGVBZ2VPbkdldCIsImRpc3Bvc2UiLCJhcHAiLCJmdWxsUGF0aCIsImxvZ2dlciIsImluZm8iLCJmcyIsInJpbXJhZiIsIm5vRGlzcG9zZU9uU2V0IiwiQVBQTElDQVRJT05TX0NBQ0hFX0dVQVJEIiwiQXN5bmNMb2NrIiwiU0FOSVRJWkVfUkVQTEFDRU1FTlQiLCJERUZBVUxUX0JBU0VOQU1FIiwiQVBQX0RPV05MT0FEX1RJTUVPVVRfTVMiLCJwcm9jZXNzIiwib24iLCJzaXplIiwiYXBwUGF0aHMiLCJ2YWx1ZXMiLCJtYXAiLCJkZWJ1ZyIsImxlbmd0aCIsInV0aWwiLCJwbHVyYWxpemUiLCJhcHBQYXRoIiwicmltcmFmU3luYyIsImUiLCJ3YXJuIiwibWVzc2FnZSIsInJldHJpZXZlSGVhZGVycyIsImxpbmsiLCJ1cmwiLCJtZXRob2QiLCJ0aW1lb3V0IiwiaGVhZGVycyIsImdldENhY2hlZEFwcGxpY2F0aW9uUGF0aCIsImN1cnJlbnRBcHBQcm9wcyIsImNhY2hlZEFwcEluZm8iLCJyZWZyZXNoIiwiXyIsImlzUGxhaW5PYmplY3QiLCJsYXN0TW9kaWZpZWQiLCJjdXJyZW50TW9kaWZpZWQiLCJpbW11dGFibGUiLCJjdXJyZW50SW1tdXRhYmxlIiwibWF4QWdlIiwiY3VycmVudE1heEFnZSIsInRpbWVzdGFtcCIsImdldFRpbWUiLCJtc0xlZnQiLCJEYXRlIiwibm93IiwicGF0aCIsImJhc2VuYW1lIiwidmVyaWZ5QXBwRXh0ZW5zaW9uIiwic3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyIsInRvTG93ZXIiLCJpbmNsdWRlcyIsImV4dG5hbWUiLCJFcnJvciIsImNhbGN1bGF0ZUZvbGRlckludGVncml0eSIsImZvbGRlclBhdGgiLCJnbG9iIiwiY3dkIiwic3RyaWN0Iiwibm9zb3J0IiwiY2FsY3VsYXRlRmlsZUludGVncml0eSIsImZpbGVQYXRoIiwiaGFzaCIsImlzQXBwSW50ZWdyaXR5T2siLCJjdXJyZW50UGF0aCIsImV4cGVjdGVkSW50ZWdyaXR5IiwiZXhpc3RzIiwic3RhdCIsImlzRGlyZWN0b3J5IiwiZm9sZGVyIiwiZmlsZSIsImNvbmZpZ3VyZUFwcCIsIm9wdGlvbnMiLCJpc1N0cmluZyIsIm9uUG9zdFByb2Nlc3MiLCJpc0FycmF5Iiwic3VwcG9ydGVkRXh0ZW5zaW9ucyIsImlzRW1wdHkiLCJuZXdBcHAiLCJzaG91bGRVbnppcEFwcCIsInBhY2thZ2VIYXNoIiwicmVtb3RlQXBwUHJvcHMiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwicGFyc2UiLCJpc1VybCIsImdldCIsImFjcXVpcmUiLCJ0ZXN0IiwibWF4QWdlTWF0Y2giLCJleGVjIiwicGFyc2VJbnQiLCJjYWNoZWRQYXRoIiwiaW50ZWdyaXR5IiwiZGVsZXRlIiwiZmlsZU5hbWUiLCJzYW5pdGl6ZU5hbWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlbWVudCIsImN0Iiwic29tZSIsIm1pbWVUeXBlIiwiUmVnRXhwIiwiZXNjYXBlUmVnRXhwIiwibWF0Y2giLCJyZXN1bHRpbmdOYW1lIiwic3Vic3RyaW5nIiwicmVzdWx0aW5nRXh0IiwiZmlyc3QiLCJ0YXJnZXRQYXRoIiwidGVtcERpciIsInByZWZpeCIsInN1ZmZpeCIsImRvd25sb2FkQXBwIiwiZXJyb3JNZXNzYWdlIiwiaXNQYWNrYWdlQUZpbGUiLCJpc0ZpbGUiLCJpc0Z1bmN0aW9uIiwiYXJjaGl2ZVBhdGgiLCJ0bXBSb290Iiwib3BlbkRpciIsInVuemlwQXBwIiwiaXNBYnNvbHV0ZSIsInJlc29sdmUiLCJzdG9yZUFwcEluQ2FjaGUiLCJhcHBQYXRoVG9DYWNoZSIsImNhY2hlZEZ1bGxQYXRoIiwic2V0IiwicmVzdWx0IiwiY2xvbmUiLCJCb29sZWFuIiwiaHJlZiIsIm5ldCIsImRvd25sb2FkRmlsZSIsImVyciIsInppcFBhdGgiLCJkc3RSb290IiwiemlwIiwiYXNzZXJ0VmFsaWRaaXAiLCJ0aW1lciIsInRpbWluZyIsIlRpbWVyIiwic3RhcnQiLCJ1c2VTeXN0ZW1VbnppcEVudiIsImVudiIsIkFQUElVTV9QUkVGRVJfU1lTVEVNX1VOWklQIiwidXNlU3lzdGVtVW56aXAiLCJleHRyYWN0aW9uT3B0cyIsImZpbGVOYW1lc0VuY29kaW5nIiwiZXh0cmFjdEFsbFRvIiwiZ2xvYlBhdHRlcm4iLCJleHQiLCJyZXBsYWNlIiwiam9pbiIsInNvcnRlZEJ1bmRsZUl0ZW1zIiwic29ydCIsImEiLCJiIiwic3BsaXQiLCJzZXAiLCJlcnJvckFuZFRocm93IiwiTWF0aCIsInJvdW5kIiwiZ2V0RHVyYXRpb24iLCJhc01pbGxpU2Vjb25kcyIsIm1hdGNoZWRCdW5kbGUiLCJkc3RQYXRoIiwibXYiLCJta2RpcnAiLCJpc1BhY2thZ2VPckJ1bmRsZSIsImR1cGxpY2F0ZUtleXMiLCJpbnB1dCIsImZpcnN0S2V5Iiwic2Vjb25kS2V5IiwiaXRlbSIsInJlc3VsdE9iaiIsImtleSIsInZhbHVlIiwidG9QYWlycyIsInJlY3Vyc2l2ZWx5Q2FsbGVkVmFsdWUiLCJwYXJzZUNhcHNBcnJheSIsImNhcCIsInBhcnNlZENhcHMiLCJKU09OIiwiaWduIiwiZ2VuZXJhdGVEcml2ZXJMb2dQcmVmaXgiLCJvYmoiLCJzZXNzaW9uSWQiLCJpbnN0YW5jZU5hbWUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJub2RlIiwiZ2V0T2JqZWN0SWQiXSwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYmFzZWRyaXZlci9oZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcbmltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgdGVtcERpciwgZnMsIHV0aWwsIHppcCwgbmV0LCB0aW1pbmcsIG5vZGUgfSBmcm9tICdAYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IExSVSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IEFzeW5jTG9jayBmcm9tICdhc3luYy1sb2NrJztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5cbmNvbnN0IElQQV9FWFQgPSAnLmlwYSc7XG5jb25zdCBaSVBfRVhUUyA9IFsnLnppcCcsIElQQV9FWFRdO1xuY29uc3QgWklQX01JTUVfVFlQRVMgPSBbXG4gICdhcHBsaWNhdGlvbi96aXAnLFxuICAnYXBwbGljYXRpb24veC16aXAtY29tcHJlc3NlZCcsXG4gICdtdWx0aXBhcnQveC16aXAnLFxuXTtcbmNvbnN0IENBQ0hFRF9BUFBTX01BWF9BR0UgPSAxMDAwICogNjAgKiA2MCAqIDI0OyAvLyBtc1xuY29uc3QgTUFYX0NBQ0hFRF9BUFBTID0gMTAyNDtcbmNvbnN0IEFQUExJQ0FUSU9OU19DQUNIRSA9IG5ldyBMUlUoe1xuICBtYXg6IE1BWF9DQUNIRURfQVBQUyxcbiAgdHRsOiBDQUNIRURfQVBQU19NQVhfQUdFLCAvLyBleHBpcmUgYWZ0ZXIgMjQgaG91cnNcbiAgdXBkYXRlQWdlT25HZXQ6IHRydWUsXG4gIGRpc3Bvc2U6IChhcHAsIHtmdWxsUGF0aH0pID0+IHtcbiAgICBsb2dnZXIuaW5mbyhgVGhlIGFwcGxpY2F0aW9uICcke2FwcH0nIGNhY2hlZCBhdCAnJHtmdWxsUGF0aH0nIGhhcyBgICtcbiAgICAgIGBleHBpcmVkIGFmdGVyICR7Q0FDSEVEX0FQUFNfTUFYX0FHRX1tc2ApO1xuICAgIGlmIChmdWxsUGF0aCkge1xuICAgICAgZnMucmltcmFmKGZ1bGxQYXRoKTtcbiAgICB9XG4gIH0sXG4gIG5vRGlzcG9zZU9uU2V0OiB0cnVlLFxufSk7XG5jb25zdCBBUFBMSUNBVElPTlNfQ0FDSEVfR1VBUkQgPSBuZXcgQXN5bmNMb2NrKCk7XG5jb25zdCBTQU5JVElaRV9SRVBMQUNFTUVOVCA9ICctJztcbmNvbnN0IERFRkFVTFRfQkFTRU5BTUUgPSAnYXBwaXVtLWFwcCc7XG5jb25zdCBBUFBfRE9XTkxPQURfVElNRU9VVF9NUyA9IDEyMCAqIDEwMDA7XG5cbnByb2Nlc3Mub24oJ2V4aXQnLCAoKSA9PiB7XG4gIGlmIChBUFBMSUNBVElPTlNfQ0FDSEUuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFwcFBhdGhzID0gWy4uLkFQUExJQ0FUSU9OU19DQUNIRS52YWx1ZXMoKV1cbiAgICAubWFwKCh7ZnVsbFBhdGh9KSA9PiBmdWxsUGF0aCk7XG4gIGxvZ2dlci5kZWJ1ZyhgUGVyZm9ybWluZyBjbGVhbnVwIG9mICR7YXBwUGF0aHMubGVuZ3RofSBjYWNoZWQgYCArXG4gICAgdXRpbC5wbHVyYWxpemUoJ2FwcGxpY2F0aW9uJywgYXBwUGF0aHMubGVuZ3RoKSk7XG4gIGZvciAoY29uc3QgYXBwUGF0aCBvZiBhcHBQYXRocykge1xuICAgIHRyeSB7XG4gICAgICAvLyBBc3luY2hyb25vdXMgY2FsbHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gb25FeGl0IGhhbmRsZXJcbiAgICAgIGZzLnJpbXJhZlN5bmMoYXBwUGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbmFzeW5jIGZ1bmN0aW9uIHJldHJpZXZlSGVhZGVycyAobGluaykge1xuICB0cnkge1xuICAgIHJldHVybiAoYXdhaXQgYXhpb3Moe1xuICAgICAgdXJsOiBsaW5rLFxuICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICB0aW1lb3V0OiA1MDAwLFxuICAgIH0pKS5oZWFkZXJzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmluZm8oYENhbm5vdCBzZW5kIEhFQUQgcmVxdWVzdCB0byAnJHtsaW5rfScuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlZEFwcGxpY2F0aW9uUGF0aCAobGluaywgY3VycmVudEFwcFByb3BzID0ge30sIGNhY2hlZEFwcEluZm8gPSB7fSkge1xuICBjb25zdCByZWZyZXNoID0gKCkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhgQSBmcmVzaCBjb3B5IG9mIHRoZSBhcHBsaWNhdGlvbiBpcyBnb2luZyB0byBiZSBkb3dubG9hZGVkIGZyb20gJHtsaW5rfWApO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGlmICghXy5pc1BsYWluT2JqZWN0KGNhY2hlZEFwcEluZm8pIHx8ICFfLmlzUGxhaW5PYmplY3QoY3VycmVudEFwcFByb3BzKSkge1xuICAgIC8vIGlmIGFuIGludmFsaWQgYXJnIGlzIHBhc3NlZCB0aGVuIGFzc3VtZSBjYWNoZSBtaXNzXG4gICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBsYXN0TW9kaWZpZWQ6IGN1cnJlbnRNb2RpZmllZCxcbiAgICBpbW11dGFibGU6IGN1cnJlbnRJbW11dGFibGUsXG4gICAgLy8gbWF4QWdlIGlzIGluIHNlY29uZHNcbiAgICBtYXhBZ2U6IGN1cnJlbnRNYXhBZ2UsXG4gIH0gPSBjdXJyZW50QXBwUHJvcHM7XG4gIGNvbnN0IHtcbiAgICAvLyBEYXRlIGluc3RhbmNlXG4gICAgbGFzdE1vZGlmaWVkLFxuICAgIC8vIGJvb2xlYW5cbiAgICBpbW11dGFibGUsXG4gICAgLy8gVW5peCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgIHRpbWVzdGFtcCxcbiAgICBmdWxsUGF0aCxcbiAgfSA9IGNhY2hlZEFwcEluZm87XG4gIGlmIChsYXN0TW9kaWZpZWQgJiYgY3VycmVudE1vZGlmaWVkKSB7XG4gICAgaWYgKGN1cnJlbnRNb2RpZmllZC5nZXRUaW1lKCkgPD0gbGFzdE1vZGlmaWVkLmdldFRpbWUoKSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBUaGUgYXBwbGljYXRpb24gYXQgJHtsaW5rfSBoYXMgbm90IGJlZW4gbW9kaWZpZWQgc2luY2UgJHtsYXN0TW9kaWZpZWR9YCk7XG4gICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgfVxuICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIGFwcGxpY2F0aW9uIGF0ICR7bGlua30gaGFzIGJlZW4gbW9kaWZpZWQgc2luY2UgJHtsYXN0TW9kaWZpZWR9YCk7XG4gICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgfVxuICBpZiAoaW1tdXRhYmxlICYmIGN1cnJlbnRJbW11dGFibGUpIHtcbiAgICBsb2dnZXIuZGVidWcoYFRoZSBhcHBsaWNhdGlvbiBhdCAke2xpbmt9IGlzIGltbXV0YWJsZWApO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbiAgfVxuICBpZiAoY3VycmVudE1heEFnZSAmJiB0aW1lc3RhbXApIHtcbiAgICBjb25zdCBtc0xlZnQgPSB0aW1lc3RhbXAgKyBjdXJyZW50TWF4QWdlICogMTAwMCAtIERhdGUubm93KCk7XG4gICAgaWYgKG1zTGVmdCA+IDApIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIGNhY2hlZCBhcHBsaWNhdGlvbiAnJHtwYXRoLmJhc2VuYW1lKGZ1bGxQYXRoKX0nIHdpbGwgZXhwaXJlIGluICR7bXNMZWZ0IC8gMTAwMH1zYCk7XG4gICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgfVxuICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIGNhY2hlZCBhcHBsaWNhdGlvbiAnJHtwYXRoLmJhc2VuYW1lKGZ1bGxQYXRoKX0nIGhhcyBleHBpcmVkYCk7XG4gIH1cbiAgcmV0dXJuIHJlZnJlc2goKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5QXBwRXh0ZW5zaW9uIChhcHAsIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMpIHtcbiAgaWYgKHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMubWFwKF8udG9Mb3dlcikuaW5jbHVkZXMoXy50b0xvd2VyKHBhdGguZXh0bmFtZShhcHApKSkpIHtcbiAgICByZXR1cm4gYXBwO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgTmV3IGFwcCBwYXRoICcke2FwcH0nIGRpZCBub3QgaGF2ZSBgICtcbiAgICBgJHt1dGlsLnBsdXJhbGl6ZSgnZXh0ZW5zaW9uJywgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucy5sZW5ndGgsIGZhbHNlKX06IGAgK1xuICAgIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVGb2xkZXJJbnRlZ3JpdHkgKGZvbGRlclBhdGgpIHtcbiAgcmV0dXJuIChhd2FpdCBmcy5nbG9iKCcqKi8qJywge2N3ZDogZm9sZGVyUGF0aCwgc3RyaWN0OiBmYWxzZSwgbm9zb3J0OiB0cnVlfSkpLmxlbmd0aDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlRmlsZUludGVncml0eSAoZmlsZVBhdGgpIHtcbiAgcmV0dXJuIGF3YWl0IGZzLmhhc2goZmlsZVBhdGgpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpc0FwcEludGVncml0eU9rIChjdXJyZW50UGF0aCwgZXhwZWN0ZWRJbnRlZ3JpdHkgPSB7fSkge1xuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhjdXJyZW50UGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGb2xkZXIgaW50ZWdyaXR5IGNoZWNrIGlzIHNpbXBsZTpcbiAgLy8gVmVyaWZ5IHRoZSBwcmV2aW91cyBhbW91bnQgb2YgZmlsZXMgaXMgbm90IGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBvbmUuXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gdXNlIGVxdWFsaXR5IGNvbXBhcmlzb24gYmVjYXVzZSBvZiBhbiBhc3N1bXB0aW9uIHRoYXQgdGhlIE9TIG1pZ2h0XG4gIC8vIGNyZWF0ZSBzb21lIHVud2FudGVkIHNlcnZpY2UgZmlsZXMvY2FjaGVkIGluc2lkZSBvZiB0aGF0IGZvbGRlciBvciBpdHMgc3ViZm9sZGVycy5cbiAgLy8gT2ZjLCB2YWxpZGF0aW5nIHRoZSBoYXNoIHN1bSBvZiBlYWNoIGZpbGUgKG9yIGF0IGxlYXN0IG9mIGZpbGUgcGF0aCkgd291bGQgYmUgbXVjaFxuICAvLyBtb3JlIHByZWNpc2UsIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIGJlIHZlcnkgcHJlY2lzZSBoZXJlIGFuZCBhbHNvIGRvbid0IHdhbnQgdG9cbiAgLy8gb3ZlcnVzZSBSQU0gYW5kIGhhdmUgYSBwZXJmb3JtYW5jZSBkcm9wLlxuICByZXR1cm4gKGF3YWl0IGZzLnN0YXQoY3VycmVudFBhdGgpKS5pc0RpcmVjdG9yeSgpXG4gICAgPyBhd2FpdCBjYWxjdWxhdGVGb2xkZXJJbnRlZ3JpdHkoY3VycmVudFBhdGgpID49IGV4cGVjdGVkSW50ZWdyaXR5Py5mb2xkZXJcbiAgICA6IGF3YWl0IGNhbGN1bGF0ZUZpbGVJbnRlZ3JpdHkoY3VycmVudFBhdGgpID09PSBleHBlY3RlZEludGVncml0eT8uZmlsZTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQb3N0UHJvY2Vzc09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P09iamVjdH0gY2FjaGVkQXBwSW5mbyBUaGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHByZXZpb3VzbHkgY2FjaGVkIGFwcCBpbnN0YW5jZSAoaWYgZXhpc3RzKTpcbiAqICAgIC0gcGFja2FnZUhhc2g6IFNIQTEgaGFzaCBvZiB0aGUgcGFja2FnZSBpZiBpdCBpcyBhIGZpbGUgYW5kIG5vdCBhIGZvbGRlclxuICogICAgLSBsYXN0TW9kaWZpZWQ6IE9wdGlvbmFsIERhdGUgaW5zdGFuY2UsIHRoZSB2YWx1ZSBvZiBmaWxlJ3MgYExhc3QtTW9kaWZpZWRgIGhlYWRlclxuICogICAgLSBpbW11dGFibGU6IE9wdGlvbmFsIGJvb2xlYW4gdmFsdWUuIENvbnRhaW5zIHRydWUgaWYgdGhlIGZpbGUgaGFzIGFuIGBpbW11dGFibGVgIG1hcmtcbiAqICAgICAgICAgICAgICAgICBpbiBgQ2FjaGUtY29udHJvbGAgaGVhZGVyXG4gKiAgICAtIG1heEFnZTogT3B0aW9uYWwgaW50ZWdlciByZXByZXNlbnRhdGlvbiBvZiBgbWF4QWdlYCBwYXJhbWV0ZXIgaW4gYENhY2hlLWNvbnRyb2xgIGhlYWRlclxuICogICAgLSB0aW1lc3RhbXA6IFRoZSB0aW1lc3RhbXAgdGhpcyBpdGVtIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBjYWNoZSAobWVhc3VyZWQgaW4gVW5peCBlcG9jaFxuICogICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcylcbiAqICAgIC0gaW50ZWdyaXR5OiBBbiBvYmplY3QgY29udGFpbmluZyBlaXRoZXIgYGZpbGVgIHByb3BlcnR5IHdpdGggU0hBMSBoYXNoIG9mIHRoZSBmaWxlXG4gKiAgICAgICAgICAgICAgICAgb3IgYGZvbGRlcmAgcHJvcGVydHkgd2l0aCB0b3RhbCBhbW91bnQgb2YgY2FjaGVkIGZpbGVzIGFuZCBzdWJmb2xkZXJzXG4gKiAgICAtIGZ1bGxQYXRoOiB0aGUgZnVsbCBwYXRoIHRvIHRoZSBjYWNoZWQgYXBwXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzVXJsIFdoZXRoZXIgdGhlIGFwcCBoYXMgYmVlbiBkb3dubG9hZGVkIGZyb20gYSByZW1vdGUgVVJMXG4gKiBAcHJvcGVydHkgez9PYmplY3R9IGhlYWRlcnMgT3B0aW9uYWwgaGVhZGVycyBvYmplY3QuIE9ubHkgcHJlc2VudCBpZiBgaXNVcmxgIGlzIHRydWUgYW5kIGlmIHRoZSBzZXJ2ZXJcbiAqIHJlc3BvbmRzIHRvIEhFQUQgcmVxdWVzdHMuIEFsbCBoZWFkZXIgbmFtZXMgYXJlIG5vcm1hbGl6ZWQgdG8gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFwcFBhdGggQSBzdHJpbmcgY29udGFpbmluZyBmdWxsIHBhdGggdG8gdGhlIHByZXByb2Nlc3NlZCBhcHBsaWNhdGlvbiBwYWNrYWdlIChlaXRoZXJcbiAqIGRvd25sb2FkZWQgb3IgYSBsb2NhbCBvbmUpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBQb3N0UHJvY2Vzc1Jlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFwcFBhdGggVGhlIGZ1bGwgcGFzdCB0byB0aGUgcG9zdC1wcm9jZXNzZWQgYXBwbGljYXRpb24gcGFja2FnZSBvbiB0aGVcbiAqIGxvY2FsIGZpbGUgc3lzdGVtIChtaWdodCBiZSBhIGZpbGUgb3IgYSBmb2xkZXIgcGF0aClcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIENvbmZpZ3VyZUFwcE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7KG9iajogUG9zdFByb2Nlc3NPcHRpb25zKSA9PiAoUHJvbWlzZTxQb3N0UHJvY2Vzc1Jlc3VsdHx1bmRlZmluZWQ+fFBvc3RQcm9jZXNzUmVzdWx0fHVuZGVmaW5lZCl9IG9uUG9zdFByb2Nlc3NcbiAqIE9wdGlvbmFsIGZ1bmN0aW9uLCB3aGljaCBzaG91bGQgYmUgYXBwbGllZFxuICogdG8gdGhlIGFwcGxpY2F0aW9uIGFmdGVyIGl0IGlzIGRvd25sb2FkZWQvcHJlcHJvY2Vzc2VkLiBUaGlzIGZ1bmN0aW9uIG1heSBiZSBhc3luY1xuICogYW5kIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBzaW5nbGUgb2JqZWN0IHBhcmFtZXRlci5cbiAqIFRoZSBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byBlaXRoZXIgcmV0dXJuIGEgZmFsc3kgdmFsdWUsIHdoaWNoIG1lYW5zIHRoZSBhcHAgbXVzdCBub3QgYmVcbiAqIGNhY2hlZCBhbmQgYSBmcmVzaCBjb3B5IG9mIGl0IGlzIGRvd25sb2FkZWQgZWFjaCB0aW1lLiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0XG4gKiBjb250YWluaW5nIGBhcHBQYXRoYCBwcm9wZXJ0eSB0aGVuIHRoZSBpbnRlZ3JpdHkgb2YgaXQgd2lsbCBiZSB2ZXJpZmllZCBhbmQgc3RvcmVkIGludG9cbiAqIHRoZSBjYWNoZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHN1cHBvcnRlZEV4dGVuc2lvbnMgTGlzdCBvZiBzdXBwb3J0ZWQgYXBwbGljYXRpb24gZXh0ZW5zaW9ucyAoXG4gKiBpbmNsdWRpbmcgc3RhcnRpbmcgZG90cykuIFRoaXMgcHJvcGVydHkgaXMgbWFuZGF0b3J5IGFuZCBtdXN0IG5vdCBiZSBlbXB0eS5cbiAqL1xuXG4vKipcbiAqIFByZXBhcmVzIGFuIGFwcCB0byBiZSB1c2VkIGluIGFuIGF1dG9tYXRlZCB0ZXN0LiBUaGUgYXBwIGdldHMgY2FjaGVkIGF1dG9tYXRpY2FsbHlcbiAqIGlmIGl0IGlzIGFuIGFyY2hpdmUgb3IgaWYgaXQgaXMgZG93bmxvYWRlZCBmcm9tIGFuIFVSTC5cbiAqIElmIHRoZSBkb3dubG9hZGVkIGFwcCBoYXMgYC56aXBgIGV4dGVuc2lvbiwgdGhpcyBtZXRob2Qgd2lsbCB1bnppcCBpdC5cbiAqIFRoZSB1bnppcCBkb2VzIG5vdCB3b3JrIHdoZW4gYG9uUG9zdFByb2Nlc3NgIGlzIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHAgRWl0aGVyIGEgZnVsbCBwYXRoIHRvIHRoZSBhcHAgb3IgYSByZW1vdGUgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXxDb25maWd1cmVBcHBPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZnVsbCBwYXRoIHRvIHRoZSByZXN1bHRpbmcgYXBwbGljYXRpb24gYnVuZGxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbmZpZ3VyZUFwcCAoYXBwLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFfLmlzU3RyaW5nKGFwcCkpIHtcbiAgICAvLyBpbW1lZGlhdGVseSBzaG9ydGNpcmN1aXQgaWYgbm90IGdpdmVuIGFuIGFwcFxuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zO1xuICBjb25zdCB7XG4gICAgb25Qb3N0UHJvY2VzcyxcbiAgfSA9IF8uaXNQbGFpbk9iamVjdChvcHRpb25zKSA/IG9wdGlvbnMgOiB7fTtcbiAgaWYgKF8uaXNTdHJpbmcob3B0aW9ucykpIHtcbiAgICBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zID0gW29wdGlvbnNdO1xuICB9IGVsc2UgaWYgKF8uaXNBcnJheShvcHRpb25zKSkge1xuICAgIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMgPSBvcHRpb25zO1xuICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMgPSBvcHRpb25zLnN1cHBvcnRlZEV4dGVuc2lvbnM7XG4gIH1cbiAgaWYgKF8uaXNFbXB0eShzdXBwb3J0ZWRBcHBFeHRlbnNpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgT25lIG9yIG1vcmUgc3VwcG9ydGVkIGFwcCBleHRlbnNpb25zIG11c3QgYmUgcHJvdmlkZWRgKTtcbiAgfVxuXG4gIGxldCBuZXdBcHAgPSBhcHA7XG4gIGxldCBzaG91bGRVbnppcEFwcCA9IGZhbHNlO1xuICBsZXQgcGFja2FnZUhhc2ggPSBudWxsO1xuICBsZXQgaGVhZGVycyA9IG51bGw7XG4gIGNvbnN0IHJlbW90ZUFwcFByb3BzID0ge1xuICAgIGxhc3RNb2RpZmllZDogbnVsbCxcbiAgICBpbW11dGFibGU6IGZhbHNlLFxuICAgIG1heEFnZTogbnVsbCxcbiAgfTtcbiAgY29uc3Qge3Byb3RvY29sLCBwYXRobmFtZX0gPSB1cmwucGFyc2UobmV3QXBwKTtcbiAgY29uc3QgaXNVcmwgPSBbJ2h0dHA6JywgJ2h0dHBzOiddLmluY2x1ZGVzKHByb3RvY29sKTtcblxuICBjb25zdCBjYWNoZWRBcHBJbmZvID0gQVBQTElDQVRJT05TX0NBQ0hFLmdldChhcHApO1xuXG4gIHJldHVybiBhd2FpdCBBUFBMSUNBVElPTlNfQ0FDSEVfR1VBUkQuYWNxdWlyZShhcHAsIGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNVcmwpIHtcbiAgICAgIC8vIFVzZSB0aGUgYXBwIGZyb20gcmVtb3RlIFVSTFxuICAgICAgbG9nZ2VyLmluZm8oYFVzaW5nIGRvd25sb2FkYWJsZSBhcHAgJyR7bmV3QXBwfSdgKTtcbiAgICAgIGhlYWRlcnMgPSBhd2FpdCByZXRyaWV2ZUhlYWRlcnMobmV3QXBwKTtcbiAgICAgIGlmICghXy5pc0VtcHR5KGhlYWRlcnMpKSB7XG4gICAgICAgIGlmIChoZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10pIHtcbiAgICAgICAgICByZW1vdGVBcHBQcm9wcy5sYXN0TW9kaWZpZWQgPSBuZXcgRGF0ZShoZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgTGFzdC1Nb2RpZmllZDogJHtoZWFkZXJzWydsYXN0LW1vZGlmaWVkJ119YCk7XG4gICAgICAgIGlmIChoZWFkZXJzWydjYWNoZS1jb250cm9sJ10pIHtcbiAgICAgICAgICByZW1vdGVBcHBQcm9wcy5pbW11dGFibGUgPSAvXFxiaW1tdXRhYmxlXFxiL2kudGVzdChoZWFkZXJzWydjYWNoZS1jb250cm9sJ10pO1xuICAgICAgICAgIGNvbnN0IG1heEFnZU1hdGNoID0gL1xcYm1heC1hZ2U9KFxcZCspXFxiL2kuZXhlYyhoZWFkZXJzWydjYWNoZS1jb250cm9sJ10pO1xuICAgICAgICAgIGlmIChtYXhBZ2VNYXRjaCkge1xuICAgICAgICAgICAgcmVtb3RlQXBwUHJvcHMubWF4QWdlID0gcGFyc2VJbnQobWF4QWdlTWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBDYWNoZS1Db250cm9sOiAke2hlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhY2hlZFBhdGggPSBnZXRDYWNoZWRBcHBsaWNhdGlvblBhdGgoYXBwLCByZW1vdGVBcHBQcm9wcywgY2FjaGVkQXBwSW5mbyk7XG4gICAgICBpZiAoY2FjaGVkUGF0aCkge1xuICAgICAgICBpZiAoYXdhaXQgaXNBcHBJbnRlZ3JpdHlPayhjYWNoZWRQYXRoLCBjYWNoZWRBcHBJbmZvPy5pbnRlZ3JpdHkpKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYFJldXNpbmcgcHJldmlvdXNseSBkb3dubG9hZGVkIGFwcGxpY2F0aW9uIGF0ICcke2NhY2hlZFBhdGh9J2ApO1xuICAgICAgICAgIHJldHVybiB2ZXJpZnlBcHBFeHRlbnNpb24oY2FjaGVkUGF0aCwgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmluZm8oYFRoZSBhcHBsaWNhdGlvbiBhdCAnJHtjYWNoZWRQYXRofScgZG9lcyBub3QgZXhpc3QgYW55bW9yZSBgICtcbiAgICAgICAgICBgb3IgaXRzIGludGVncml0eSBoYXMgYmVlbiBkYW1hZ2VkLiBEZWxldGluZyBpdCBmcm9tIHRoZSBpbnRlcm5hbCBjYWNoZWApO1xuICAgICAgICBBUFBMSUNBVElPTlNfQ0FDSEUuZGVsZXRlKGFwcCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBmaWxlTmFtZSA9IG51bGw7XG4gICAgICBjb25zdCBiYXNlbmFtZSA9IGZzLnNhbml0aXplTmFtZShwYXRoLmJhc2VuYW1lKGRlY29kZVVSSUNvbXBvbmVudChwYXRobmFtZSkpLCB7XG4gICAgICAgIHJlcGxhY2VtZW50OiBTQU5JVElaRV9SRVBMQUNFTUVOVFxuICAgICAgfSk7XG4gICAgICBjb25zdCBleHRuYW1lID0gcGF0aC5leHRuYW1lKGJhc2VuYW1lKTtcbiAgICAgIC8vIHRvIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIHVuemlwIHRoZSBhcHAsIHdlIGhhdmUgYSBudW1iZXIgb2YgcGxhY2VzXG4gICAgICAvLyB0byBsb29rOiBjb250ZW50IHR5cGUsIGNvbnRlbnQgZGlzcG9zaXRpb24sIG9yIHRoZSBmaWxlIGV4dGVuc2lvblxuICAgICAgaWYgKFpJUF9FWFRTLmluY2x1ZGVzKGV4dG5hbWUpKSB7XG4gICAgICAgIGZpbGVOYW1lID0gYmFzZW5hbWU7XG4gICAgICAgIHNob3VsZFVuemlwQXBwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWFkZXJzWydjb250ZW50LXR5cGUnXSkge1xuICAgICAgICBjb25zdCBjdCA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICBsb2dnZXIuZGVidWcoYENvbnRlbnQtVHlwZTogJHtjdH1gKTtcbiAgICAgICAgLy8gdGhlIGZpbGV0eXBlIG1heSBub3QgYmUgb2J2aW91cyBmb3IgY2VydGFpbiB1cmxzLCBzbyBjaGVjayB0aGUgbWltZSB0eXBlIHRvb1xuICAgICAgICBpZiAoWklQX01JTUVfVFlQRVMuc29tZSgobWltZVR5cGUpID0+IG5ldyBSZWdFeHAoYFxcXFxiJHtfLmVzY2FwZVJlZ0V4cChtaW1lVHlwZSl9XFxcXGJgKS50ZXN0KGN0KSkpIHtcbiAgICAgICAgICBpZiAoIWZpbGVOYW1lKSB7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IGAke0RFRkFVTFRfQkFTRU5BTUV9LnppcGA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNob3VsZFVuemlwQXBwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhlYWRlcnNbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSAmJiAvXmF0dGFjaG1lbnQvaS50ZXN0KGhlYWRlcnNbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSkpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBDb250ZW50LURpc3Bvc2l0aW9uOiAke2hlYWRlcnNbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXX1gKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvZmlsZW5hbWU9XCIoW15cIl0rKS9pLmV4ZWMoaGVhZGVyc1snY29udGVudC1kaXNwb3NpdGlvbiddKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgZmlsZU5hbWUgPSBmcy5zYW5pdGl6ZU5hbWUobWF0Y2hbMV0sIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50OiBTQU5JVElaRV9SRVBMQUNFTUVOVFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNob3VsZFVuemlwQXBwID0gc2hvdWxkVW56aXBBcHAgfHwgWklQX0VYVFMuaW5jbHVkZXMocGF0aC5leHRuYW1lKGZpbGVOYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZmlsZU5hbWUpIHtcbiAgICAgICAgLy8gYXNzaWduIHRoZSBkZWZhdWx0IGZpbGUgbmFtZSBhbmQgdGhlIGV4dGVuc2lvbiBpZiBub25lIGhhcyBiZWVuIGRldGVjdGVkXG4gICAgICAgIGNvbnN0IHJlc3VsdGluZ05hbWUgPSBiYXNlbmFtZVxuICAgICAgICAgID8gYmFzZW5hbWUuc3Vic3RyaW5nKDAsIGJhc2VuYW1lLmxlbmd0aCAtIGV4dG5hbWUubGVuZ3RoKVxuICAgICAgICAgIDogREVGQVVMVF9CQVNFTkFNRTtcbiAgICAgICAgbGV0IHJlc3VsdGluZ0V4dCA9IGV4dG5hbWU7XG4gICAgICAgIGlmICghc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucy5pbmNsdWRlcyhyZXN1bHRpbmdFeHQpKSB7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYFRoZSBjdXJyZW50IGZpbGUgZXh0ZW5zaW9uICcke3Jlc3VsdGluZ0V4dH0nIGlzIG5vdCBzdXBwb3J0ZWQuIGAgK1xuICAgICAgICAgICAgYERlZmF1bHRpbmcgdG8gJyR7Xy5maXJzdChzdXBwb3J0ZWRBcHBFeHRlbnNpb25zKX0nYCk7XG4gICAgICAgICAgcmVzdWx0aW5nRXh0ID0gXy5maXJzdChzdXBwb3J0ZWRBcHBFeHRlbnNpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBmaWxlTmFtZSA9IGAke3Jlc3VsdGluZ05hbWV9JHtyZXN1bHRpbmdFeHR9YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldFBhdGggPSBhd2FpdCB0ZW1wRGlyLnBhdGgoe1xuICAgICAgICBwcmVmaXg6IGZpbGVOYW1lLFxuICAgICAgICBzdWZmaXg6ICcnLFxuICAgICAgfSk7XG4gICAgICBuZXdBcHAgPSBhd2FpdCBkb3dubG9hZEFwcChuZXdBcHAsIHRhcmdldFBhdGgpO1xuICAgIH0gZWxzZSBpZiAoYXdhaXQgZnMuZXhpc3RzKG5ld0FwcCkpIHtcbiAgICAgIC8vIFVzZSB0aGUgbG9jYWwgYXBwXG4gICAgICBsb2dnZXIuaW5mbyhgVXNpbmcgbG9jYWwgYXBwICcke25ld0FwcH0nYCk7XG4gICAgICBzaG91bGRVbnppcEFwcCA9IFpJUF9FWFRTLmluY2x1ZGVzKHBhdGguZXh0bmFtZShuZXdBcHApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGBUaGUgYXBwbGljYXRpb24gYXQgJyR7bmV3QXBwfScgZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IGFjY2Vzc2libGVgO1xuICAgICAgLy8gcHJvdG9jb2wgdmFsdWUgZm9yICdDOlxcXFx0ZW1wJyBpcyAnYzonLCBzbyB3ZSBjaGVjayB0aGUgbGVuZ3RoIGFzIHdlbGxcbiAgICAgIGlmIChfLmlzU3RyaW5nKHByb3RvY29sKSAmJiBwcm90b2NvbC5sZW5ndGggPiAyKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IGBUaGUgcHJvdG9jb2wgJyR7cHJvdG9jb2x9JyB1c2VkIGluICcke25ld0FwcH0nIGlzIG5vdCBzdXBwb3J0ZWQuIGAgK1xuICAgICAgICAgIGBPbmx5IGh0dHA6IGFuZCBodHRwczogcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWRgO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNQYWNrYWdlQUZpbGUgPSAoYXdhaXQgZnMuc3RhdChuZXdBcHApKS5pc0ZpbGUoKTtcbiAgICBpZiAoaXNQYWNrYWdlQUZpbGUpIHtcbiAgICAgIHBhY2thZ2VIYXNoID0gYXdhaXQgY2FsY3VsYXRlRmlsZUludGVncml0eShuZXdBcHApO1xuICAgIH1cblxuICAgIGlmIChpc1BhY2thZ2VBRmlsZSAmJiBzaG91bGRVbnppcEFwcCAmJiAhXy5pc0Z1bmN0aW9uKG9uUG9zdFByb2Nlc3MpKSB7XG4gICAgICBjb25zdCBhcmNoaXZlUGF0aCA9IG5ld0FwcDtcbiAgICAgIGlmIChwYWNrYWdlSGFzaCA9PT0gY2FjaGVkQXBwSW5mbz8ucGFja2FnZUhhc2gpIHtcbiAgICAgICAgY29uc3Qge2Z1bGxQYXRofSA9IGNhY2hlZEFwcEluZm87XG4gICAgICAgIGlmIChhd2FpdCBpc0FwcEludGVncml0eU9rKGZ1bGxQYXRoLCBjYWNoZWRBcHBJbmZvPy5pbnRlZ3JpdHkpKSB7XG4gICAgICAgICAgaWYgKGFyY2hpdmVQYXRoICE9PSBhcHApIHtcbiAgICAgICAgICAgIGF3YWl0IGZzLnJpbXJhZihhcmNoaXZlUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5pbmZvKGBXaWxsIHJldXNlIHByZXZpb3VzbHkgY2FjaGVkIGFwcGxpY2F0aW9uIGF0ICcke2Z1bGxQYXRofSdgKTtcbiAgICAgICAgICByZXR1cm4gdmVyaWZ5QXBwRXh0ZW5zaW9uKGZ1bGxQYXRoLCBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuaW5mbyhgVGhlIGFwcGxpY2F0aW9uIGF0ICcke2Z1bGxQYXRofScgZG9lcyBub3QgZXhpc3QgYW55bW9yZSBgICtcbiAgICAgICAgICBgb3IgaXRzIGludGVncml0eSBoYXMgYmVlbiBkYW1hZ2VkLiBEZWxldGluZyBpdCBmcm9tIHRoZSBjYWNoZWApO1xuICAgICAgICBBUFBMSUNBVElPTlNfQ0FDSEUuZGVsZXRlKGFwcCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gICAgICB0cnkge1xuICAgICAgICBuZXdBcHAgPSBhd2FpdCB1bnppcEFwcChhcmNoaXZlUGF0aCwgdG1wUm9vdCwgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobmV3QXBwICE9PSBhcmNoaXZlUGF0aCAmJiBhcmNoaXZlUGF0aCAhPT0gYXBwKSB7XG4gICAgICAgICAgYXdhaXQgZnMucmltcmFmKGFyY2hpdmVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9nZ2VyLmluZm8oYFVuemlwcGVkIGxvY2FsIGFwcCB0byAnJHtuZXdBcHB9J2ApO1xuICAgIH0gZWxzZSBpZiAoIXBhdGguaXNBYnNvbHV0ZShuZXdBcHApKSB7XG4gICAgICBuZXdBcHAgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgbmV3QXBwKTtcbiAgICAgIGxvZ2dlci53YXJuKGBUaGUgY3VycmVudCBhcHBsaWNhdGlvbiBwYXRoICcke2FwcH0nIGlzIG5vdCBhYnNvbHV0ZSBgICtcbiAgICAgICAgYGFuZCBoYXMgYmVlbiByZXdyaXR0ZW4gdG8gJyR7bmV3QXBwfScuIENvbnNpZGVyIHVzaW5nIGFic29sdXRlIHBhdGhzIHJhdGhlciB0aGFuIHJlbGF0aXZlYCk7XG4gICAgICBhcHAgPSBuZXdBcHA7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmVBcHBJbkNhY2hlID0gYXN5bmMgKGFwcFBhdGhUb0NhY2hlKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZWRGdWxsUGF0aCA9IGNhY2hlZEFwcEluZm8/LmZ1bGxQYXRoO1xuICAgICAgaWYgKGNhY2hlZEZ1bGxQYXRoICYmIGNhY2hlZEZ1bGxQYXRoICE9PSBhcHBQYXRoVG9DYWNoZSkge1xuICAgICAgICBhd2FpdCBmcy5yaW1yYWYoY2FjaGVkRnVsbFBhdGgpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW50ZWdyaXR5ID0ge307XG4gICAgICBpZiAoKGF3YWl0IGZzLnN0YXQoYXBwUGF0aFRvQ2FjaGUpKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIGludGVncml0eS5mb2xkZXIgPSBhd2FpdCBjYWxjdWxhdGVGb2xkZXJJbnRlZ3JpdHkoYXBwUGF0aFRvQ2FjaGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZWdyaXR5LmZpbGUgPSBhd2FpdCBjYWxjdWxhdGVGaWxlSW50ZWdyaXR5KGFwcFBhdGhUb0NhY2hlKTtcbiAgICAgIH1cbiAgICAgIEFQUExJQ0FUSU9OU19DQUNIRS5zZXQoYXBwLCB7XG4gICAgICAgIC4uLnJlbW90ZUFwcFByb3BzLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIHBhY2thZ2VIYXNoLFxuICAgICAgICBpbnRlZ3JpdHksXG4gICAgICAgIGZ1bGxQYXRoOiBhcHBQYXRoVG9DYWNoZSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFwcFBhdGhUb0NhY2hlO1xuICAgIH07XG5cbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9uUG9zdFByb2Nlc3MpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvblBvc3RQcm9jZXNzKHtcbiAgICAgICAgY2FjaGVkQXBwSW5mbzogXy5jbG9uZShjYWNoZWRBcHBJbmZvKSxcbiAgICAgICAgaXNVcmwsXG4gICAgICAgIGhlYWRlcnM6IF8uY2xvbmUoaGVhZGVycyksXG4gICAgICAgIGFwcFBhdGg6IG5ld0FwcCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICghcmVzdWx0Py5hcHBQYXRoIHx8IGFwcCA9PT0gcmVzdWx0Py5hcHBQYXRoIHx8ICFhd2FpdCBmcy5leGlzdHMocmVzdWx0Py5hcHBQYXRoKSlcbiAgICAgICAgPyBuZXdBcHBcbiAgICAgICAgOiBhd2FpdCBzdG9yZUFwcEluQ2FjaGUocmVzdWx0LmFwcFBhdGgpO1xuICAgIH1cblxuICAgIHZlcmlmeUFwcEV4dGVuc2lvbihuZXdBcHAsIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMpO1xuICAgIHJldHVybiAoYXBwICE9PSBuZXdBcHAgJiYgKHBhY2thZ2VIYXNoIHx8IF8udmFsdWVzKHJlbW90ZUFwcFByb3BzKS5zb21lKEJvb2xlYW4pKSlcbiAgICAgID8gYXdhaXQgc3RvcmVBcHBJbkNhY2hlKG5ld0FwcClcbiAgICAgIDogbmV3QXBwO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRBcHAgKGFwcCwgdGFyZ2V0UGF0aCkge1xuICBjb25zdCB7aHJlZn0gPSB1cmwucGFyc2UoYXBwKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBuZXQuZG93bmxvYWRGaWxlKGhyZWYsIHRhcmdldFBhdGgsIHtcbiAgICAgIHRpbWVvdXQ6IEFQUF9ET1dOTE9BRF9USU1FT1VUX01TLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBkb3dubG9hZCB0aGUgYXBwOiAke2Vyci5tZXNzYWdlfWApO1xuICB9XG4gIHJldHVybiB0YXJnZXRQYXRoO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBidW5kbGUgZnJvbSBhbiBhcmNoaXZlIGludG8gdGhlIGdpdmVuIGZvbGRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB6aXBQYXRoIEZ1bGwgcGF0aCB0byB0aGUgYXJjaGl2ZSBjb250YWluaW5nIHRoZSBidW5kbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBkc3RSb290IEZ1bGwgcGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBleHRyYWN0ZWQgYnVuZGxlXG4gKiBzaG91bGQgYmUgcGxhY2VkXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz58c3RyaW5nfSBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zIFRoZSBsaXN0IG9mIGV4dGVuc2lvbnNcbiAqIHRoZSB0YXJnZXQgYXBwbGljYXRpb24gYnVuZGxlIHN1cHBvcnRzLCBmb3IgZXhhbXBsZSBbJy5hcGsnLCAnLmFwa3MnXSBmb3JcbiAqIEFuZHJvaWQgcGFja2FnZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgYnVuZGxlIGluIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZ2l2ZW4gYXJjaGl2ZSBpcyBpbnZhbGlkIG9yIG5vIGFwcGxpY2F0aW9uIGJ1bmRsZXNcbiAqIGhhdmUgYmVlbiBmb3VuZCBpbnNpZGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdW56aXBBcHAgKHppcFBhdGgsIGRzdFJvb3QsIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMpIHtcbiAgYXdhaXQgemlwLmFzc2VydFZhbGlkWmlwKHppcFBhdGgpO1xuXG4gIGlmICghXy5pc0FycmF5KHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMpKSB7XG4gICAgc3VwcG9ydGVkQXBwRXh0ZW5zaW9ucyA9IFtzdXBwb3J0ZWRBcHBFeHRlbnNpb25zXTtcbiAgfVxuXG4gIGNvbnN0IHRtcFJvb3QgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgdHJ5IHtcbiAgICBsb2dnZXIuZGVidWcoYFVuemlwcGluZyAnJHt6aXBQYXRofSdgKTtcbiAgICBjb25zdCB0aW1lciA9IG5ldyB0aW1pbmcuVGltZXIoKS5zdGFydCgpO1xuICAgIGNvbnN0IHVzZVN5c3RlbVVuemlwRW52ID0gcHJvY2Vzcy5lbnYuQVBQSVVNX1BSRUZFUl9TWVNURU1fVU5aSVA7XG4gICAgY29uc3QgdXNlU3lzdGVtVW56aXAgPSBfLmlzRW1wdHkodXNlU3lzdGVtVW56aXBFbnYpXG4gICAgICB8fCAhWycwJywgJ2ZhbHNlJ10uaW5jbHVkZXMoXy50b0xvd2VyKHVzZVN5c3RlbVVuemlwRW52KSk7XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byB1c2UgdXNlIHRoZSBzeXN0ZW0gYHVuemlwYCAoZS5nLiwgYC91c3IvYmluL3VuemlwYCkgZHVlXG4gICAgICogdG8gdGhlIHNpZ25pZmljYW50IHBlcmZvcm1hbmNlIGltcHJvdmVtZW50IGl0IHByb3ZpZGVzIG92ZXIgdGhlIG5hdGl2ZVxuICAgICAqIEpTIFwidW56aXBcIiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KCdAYXBwaXVtL3N1cHBvcnQvbGliL3ppcCcpLkV4dHJhY3RBbGxPcHRpb25zfVxuICAgICAqL1xuICAgIGNvbnN0IGV4dHJhY3Rpb25PcHRzID0ge3VzZVN5c3RlbVVuemlwfTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL2FwcGl1bS9pc3N1ZXMvMTQxMDBcbiAgICBpZiAocGF0aC5leHRuYW1lKHppcFBhdGgpID09PSBJUEFfRVhUKSB7XG4gICAgICBsb2dnZXIuZGVidWcoYEVuZm9yY2luZyBVVEYtOCBlbmNvZGluZyBvbiB0aGUgZXh0cmFjdGVkIGZpbGUgbmFtZXMgZm9yICcke3BhdGguYmFzZW5hbWUoemlwUGF0aCl9J2ApO1xuICAgICAgZXh0cmFjdGlvbk9wdHMuZmlsZU5hbWVzRW5jb2RpbmcgPSAndXRmOCc7XG4gICAgfVxuICAgIGF3YWl0IHppcC5leHRyYWN0QWxsVG8oemlwUGF0aCwgdG1wUm9vdCwgZXh0cmFjdGlvbk9wdHMpO1xuICAgIGNvbnN0IGdsb2JQYXR0ZXJuID0gYCoqLyouKygke3N1cHBvcnRlZEFwcEV4dGVuc2lvbnMubWFwKChleHQpID0+IGV4dC5yZXBsYWNlKC9eXFwuLywgJycpKS5qb2luKCd8Jyl9KWA7XG4gICAgY29uc3Qgc29ydGVkQnVuZGxlSXRlbXMgPSAoYXdhaXQgZnMuZ2xvYihnbG9iUGF0dGVybiwge1xuICAgICAgY3dkOiB0bXBSb290LFxuICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICAvLyBHZXQgdGhlIHRvcCBsZXZlbCBtYXRjaFxuICAgIH0pKS5zb3J0KChhLCBiKSA9PiBhLnNwbGl0KHBhdGguc2VwKS5sZW5ndGggLSBiLnNwbGl0KHBhdGguc2VwKS5sZW5ndGgpO1xuICAgIGlmIChfLmlzRW1wdHkoc29ydGVkQnVuZGxlSXRlbXMpKSB7XG4gICAgICBsb2dnZXIuZXJyb3JBbmRUaHJvdyhgQXBwIHVuemlwcGVkIE9LLCBidXQgd2UgY291bGQgbm90IGZpbmQgYW55ICcke3N1cHBvcnRlZEFwcEV4dGVuc2lvbnN9JyBgICtcbiAgICAgICAgdXRpbC5wbHVyYWxpemUoJ2J1bmRsZScsIHN1cHBvcnRlZEFwcEV4dGVuc2lvbnMubGVuZ3RoLCBmYWxzZSkgK1xuICAgICAgICBgIGluIGl0LiBNYWtlIHN1cmUgeW91ciBhcmNoaXZlIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBwYWNrYWdlIGhhdmluZyBgICtcbiAgICAgICAgYCcke3N1cHBvcnRlZEFwcEV4dGVuc2lvbnN9JyAke3V0aWwucGx1cmFsaXplKCdleHRlbnNpb24nLCBzdXBwb3J0ZWRBcHBFeHRlbnNpb25zLmxlbmd0aCwgZmFsc2UpfWApO1xuICAgIH1cbiAgICBsb2dnZXIuZGVidWcoYEV4dHJhY3RlZCAke3V0aWwucGx1cmFsaXplKCdidW5kbGUgaXRlbScsIHNvcnRlZEJ1bmRsZUl0ZW1zLmxlbmd0aCwgdHJ1ZSl9IGAgK1xuICAgICAgYGZyb20gJyR7emlwUGF0aH0nIGluICR7TWF0aC5yb3VuZCh0aW1lci5nZXREdXJhdGlvbigpLmFzTWlsbGlTZWNvbmRzKX1tczogJHtzb3J0ZWRCdW5kbGVJdGVtc31gKTtcbiAgICBjb25zdCBtYXRjaGVkQnVuZGxlID0gXy5maXJzdChzb3J0ZWRCdW5kbGVJdGVtcyk7XG4gICAgbG9nZ2VyLmluZm8oYEFzc3VtaW5nICcke21hdGNoZWRCdW5kbGV9JyBpcyB0aGUgY29ycmVjdCBidW5kbGVgKTtcbiAgICBjb25zdCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKGRzdFJvb3QsIHBhdGguYmFzZW5hbWUobWF0Y2hlZEJ1bmRsZSkpO1xuICAgIGF3YWl0IGZzLm12KHBhdGgucmVzb2x2ZSh0bXBSb290LCBtYXRjaGVkQnVuZGxlKSwgZHN0UGF0aCwge21rZGlycDogdHJ1ZX0pO1xuICAgIHJldHVybiBkc3RQYXRoO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1BhY2thZ2VPckJ1bmRsZSAoYXBwKSB7XG4gIHJldHVybiAoL14oW2EtekEtWjAtOVxcLV9dK1xcLlthLXpBLVowLTlcXC1fXSspKyQvKS50ZXN0KGFwcCk7XG59XG5cbi8qKlxuICogRmluZHMgYWxsIGluc3RhbmNlcyAnZmlyc3RLZXknIGFuZCBjcmVhdGUgYSBkdXBsaWNhdGUgd2l0aCB0aGUga2V5ICdzZWNvbmRLZXknLFxuICogRG8gdGhlIHNhbWUgdGhpbmcgaW4gcmV2ZXJzZS4gSWYgd2UgZmluZCAnc2Vjb25kS2V5JywgY3JlYXRlIGEgZHVwbGljYXRlIHdpdGggdGhlIGtleSAnZmlyc3RLZXknLlxuICpcbiAqIFRoaXMgd2lsbCBjYXVzZSBrZXlzIHRvIGJlIG92ZXJ3cml0dGVuIGlmIHRoZSBvYmplY3QgY29udGFpbnMgJ2ZpcnN0S2V5JyBhbmQgJ3NlY29uZEtleScuXG5cbiAqIEBwYXJhbSB7Kn0gaW5wdXQgQW55IHR5cGUgb2YgaW5wdXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaXJzdEtleSBUaGUgZmlyc3Qga2V5IHRvIGR1cGxpY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNlY29uZEtleSBUaGUgc2Vjb25kIGtleSB0byBkdXBsaWNhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGljYXRlS2V5cyAoaW5wdXQsIGZpcnN0S2V5LCBzZWNvbmRLZXkpIHtcbiAgLy8gSWYgYXJyYXkgcHJvdmlkZWQsIHJlY3Vyc2l2ZWx5IGNhbGwgb24gYWxsIGVsZW1lbnRzXG4gIGlmIChfLmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0Lm1hcCgoaXRlbSkgPT4gZHVwbGljYXRlS2V5cyhpdGVtLCBmaXJzdEtleSwgc2Vjb25kS2V5KSk7XG4gIH1cblxuICAvLyBJZiBvYmplY3QsIGNyZWF0ZSBkdXBsaWNhdGVzIGZvciBrZXlzIGFuZCB0aGVuIHJlY3Vyc2l2ZWx5IGNhbGwgb24gdmFsdWVzXG4gIGlmIChfLmlzUGxhaW5PYmplY3QoaW5wdXQpKSB7XG4gICAgY29uc3QgcmVzdWx0T2JqID0ge307XG4gICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIF8udG9QYWlycyhpbnB1dCkpIHtcbiAgICAgIGNvbnN0IHJlY3Vyc2l2ZWx5Q2FsbGVkVmFsdWUgPSBkdXBsaWNhdGVLZXlzKHZhbHVlLCBmaXJzdEtleSwgc2Vjb25kS2V5KTtcbiAgICAgIGlmIChrZXkgPT09IGZpcnN0S2V5KSB7XG4gICAgICAgIHJlc3VsdE9ialtzZWNvbmRLZXldID0gcmVjdXJzaXZlbHlDYWxsZWRWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBzZWNvbmRLZXkpIHtcbiAgICAgICAgcmVzdWx0T2JqW2ZpcnN0S2V5XSA9IHJlY3Vyc2l2ZWx5Q2FsbGVkVmFsdWU7XG4gICAgICB9XG4gICAgICByZXN1bHRPYmpba2V5XSA9IHJlY3Vyc2l2ZWx5Q2FsbGVkVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRPYmo7XG4gIH1cblxuICAvLyBCYXNlIGNhc2UuIFJldHVybiBwcmltaXRpdmVzIHdpdGhvdXQgZG9pbmcgYW55dGhpbmcuXG4gIHJldHVybiBpbnB1dDtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIGRlc2lyZWQgY2FwYWJpbGl0eSBhbmQgdHJpZXMgdG8gSlNPTi5wYXJzZSBpdCBhcyBhbiBhcnJheSxcbiAqIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgcGFyc2VkIGFycmF5IG9yIGEgc2luZ2xldG9uIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PFN0cmluZz59IGNhcCBBIGRlc2lyZWQgY2FwYWJpbGl0eVxuICovXG5mdW5jdGlvbiBwYXJzZUNhcHNBcnJheSAoY2FwKSB7XG4gIGlmIChfLmlzQXJyYXkoY2FwKSkge1xuICAgIHJldHVybiBjYXA7XG4gIH1cblxuICBsZXQgcGFyc2VkQ2FwcztcbiAgdHJ5IHtcbiAgICBwYXJzZWRDYXBzID0gSlNPTi5wYXJzZShjYXApO1xuICAgIGlmIChfLmlzQXJyYXkocGFyc2VkQ2FwcykpIHtcbiAgICAgIHJldHVybiBwYXJzZWRDYXBzO1xuICAgIH1cbiAgfSBjYXRjaCAoaWduKSB7XG4gICAgbG9nZ2VyLndhcm4oYEZhaWxlZCB0byBwYXJzZSBjYXBhYmlsaXR5IGFzIEpTT04gYXJyYXlgKTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyhjYXApKSB7XG4gICAgcmV0dXJuIFtjYXBdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgbXVzdCBwcm92aWRlIGEgc3RyaW5nIG9yIEpTT04gQXJyYXk7IHJlY2VpdmVkICR7Y2FwfWApO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIHRoYXQgdW5pcXVlbHkgZGVzY3JpYmVzIGRyaXZlciBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCdAYXBwaXVtL3R5cGVzJykuQ29yZX0gb2JqIGRyaXZlciBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmc/fSBzZXNzaW9uSWQgc2Vzc2lvbiBpZGVudGlmaWVyIChpZiBleGlzdHMpXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZURyaXZlckxvZ1ByZWZpeCAob2JqLCBzZXNzaW9uSWQgPSBudWxsKSB7XG4gIGNvbnN0IGluc3RhbmNlTmFtZSA9IGAke29iai5jb25zdHJ1Y3Rvci5uYW1lfUAke25vZGUuZ2V0T2JqZWN0SWQob2JqKS5zdWJzdHJpbmcoMCwgNCl9YDtcbiAgcmV0dXJuIHNlc3Npb25JZCA/IGAke2luc3RhbmNlTmFtZX0gKCR7c2Vzc2lvbklkLnN1YnN0cmluZygwLCA4KX0pYCA6IGluc3RhbmNlTmFtZTtcbn1cblxuLyoqIEB0eXBlIHtpbXBvcnQoJ0BhcHBpdW0vdHlwZXMnKS5Ecml2ZXJIZWxwZXJzfSAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBjb25maWd1cmVBcHAsIGlzUGFja2FnZU9yQnVuZGxlLCBkdXBsaWNhdGVLZXlzLCBwYXJzZUNhcHNBcnJheSwgZ2VuZXJhdGVEcml2ZXJMb2dQcmVmaXhcbn07XG5leHBvcnQge1xuICBjb25maWd1cmVBcHAsIGlzUGFja2FnZU9yQnVuZGxlLCBkdXBsaWNhdGVLZXlzLCBwYXJzZUNhcHNBcnJheSwgZ2VuZXJhdGVEcml2ZXJMb2dQcmVmaXhcbn07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxPQUFPLEdBQUcsTUFBaEI7QUFDQSxNQUFNQyxRQUFRLEdBQUcsQ0FBQyxNQUFELEVBQVNELE9BQVQsQ0FBakI7QUFDQSxNQUFNRSxjQUFjLEdBQUcsQ0FDckIsaUJBRHFCLEVBRXJCLDhCQUZxQixFQUdyQixpQkFIcUIsQ0FBdkI7QUFLQSxNQUFNQyxtQkFBbUIsR0FBRyxPQUFPLEVBQVAsR0FBWSxFQUFaLEdBQWlCLEVBQTdDO0FBQ0EsTUFBTUMsZUFBZSxHQUFHLElBQXhCO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUcsSUFBSUMsaUJBQUosQ0FBUTtFQUNqQ0MsR0FBRyxFQUFFSCxlQUQ0QjtFQUVqQ0ksR0FBRyxFQUFFTCxtQkFGNEI7RUFHakNNLGNBQWMsRUFBRSxJQUhpQjtFQUlqQ0MsT0FBTyxFQUFFLENBQUNDLEdBQUQsRUFBTTtJQUFDQztFQUFELENBQU4sS0FBcUI7SUFDNUJDLGdCQUFPQyxJQUFQLENBQWEsb0JBQW1CSCxHQUFJLGdCQUFlQyxRQUFTLFFBQWhELEdBQ1QsaUJBQWdCVCxtQkFBb0IsSUFEdkM7O0lBRUEsSUFBSVMsUUFBSixFQUFjO01BQ1pHLFlBQUdDLE1BQUgsQ0FBVUosUUFBVjtJQUNEO0VBQ0YsQ0FWZ0M7RUFXakNLLGNBQWMsRUFBRTtBQVhpQixDQUFSLENBQTNCO0FBYUEsTUFBTUMsd0JBQXdCLEdBQUcsSUFBSUMsa0JBQUosRUFBakM7QUFDQSxNQUFNQyxvQkFBb0IsR0FBRyxHQUE3QjtBQUNBLE1BQU1DLGdCQUFnQixHQUFHLFlBQXpCO0FBQ0EsTUFBTUMsdUJBQXVCLEdBQUcsTUFBTSxJQUF0QztBQUVBQyxPQUFPLENBQUNDLEVBQVIsQ0FBVyxNQUFYLEVBQW1CLE1BQU07RUFDdkIsSUFBSW5CLGtCQUFrQixDQUFDb0IsSUFBbkIsS0FBNEIsQ0FBaEMsRUFBbUM7SUFDakM7RUFDRDs7RUFFRCxNQUFNQyxRQUFRLEdBQUcsQ0FBQyxHQUFHckIsa0JBQWtCLENBQUNzQixNQUFuQixFQUFKLEVBQ2RDLEdBRGMsQ0FDVixDQUFDO0lBQUNoQjtFQUFELENBQUQsS0FBZ0JBLFFBRE4sQ0FBakI7O0VBRUFDLGdCQUFPZ0IsS0FBUCxDQUFjLHlCQUF3QkgsUUFBUSxDQUFDSSxNQUFPLFVBQXpDLEdBQ1hDLGNBQUtDLFNBQUwsQ0FBZSxhQUFmLEVBQThCTixRQUFRLENBQUNJLE1BQXZDLENBREY7O0VBRUEsS0FBSyxNQUFNRyxPQUFYLElBQXNCUCxRQUF0QixFQUFnQztJQUM5QixJQUFJO01BRUZYLFlBQUdtQixVQUFILENBQWNELE9BQWQ7SUFDRCxDQUhELENBR0UsT0FBT0UsQ0FBUCxFQUFVO01BQ1Z0QixnQkFBT3VCLElBQVAsQ0FBWUQsQ0FBQyxDQUFDRSxPQUFkO0lBQ0Q7RUFDRjtBQUNGLENBakJEOztBQW9CQSxlQUFlQyxlQUFmLENBQWdDQyxJQUFoQyxFQUFzQztFQUNwQyxJQUFJO0lBQ0YsT0FBTyxDQUFDLE1BQU0sb0JBQU07TUFDbEJDLEdBQUcsRUFBRUQsSUFEYTtNQUVsQkUsTUFBTSxFQUFFLE1BRlU7TUFHbEJDLE9BQU8sRUFBRTtJQUhTLENBQU4sQ0FBUCxFQUlIQyxPQUpKO0VBS0QsQ0FORCxDQU1FLE9BQU9SLENBQVAsRUFBVTtJQUNWdEIsZ0JBQU9DLElBQVAsQ0FBYSxnQ0FBK0J5QixJQUFLLHNCQUFxQkosQ0FBQyxDQUFDRSxPQUFRLEVBQWhGO0VBQ0Q7O0VBQ0QsT0FBTyxFQUFQO0FBQ0Q7O0FBRUQsU0FBU08sd0JBQVQsQ0FBbUNMLElBQW5DLEVBQXlDTSxlQUFlLEdBQUcsRUFBM0QsRUFBK0RDLGFBQWEsR0FBRyxFQUEvRSxFQUFtRjtFQUNqRixNQUFNQyxPQUFPLEdBQUcsTUFBTTtJQUNwQmxDLGdCQUFPZ0IsS0FBUCxDQUFjLGtFQUFpRVUsSUFBSyxFQUFwRjs7SUFDQSxPQUFPLElBQVA7RUFDRCxDQUhEOztFQUtBLElBQUksQ0FBQ1MsZ0JBQUVDLGFBQUYsQ0FBZ0JILGFBQWhCLENBQUQsSUFBbUMsQ0FBQ0UsZ0JBQUVDLGFBQUYsQ0FBZ0JKLGVBQWhCLENBQXhDLEVBQTBFO0lBRXhFLE9BQU9FLE9BQU8sRUFBZDtFQUNEOztFQUVELE1BQU07SUFDSkcsWUFBWSxFQUFFQyxlQURWO0lBRUpDLFNBQVMsRUFBRUMsZ0JBRlA7SUFJSkMsTUFBTSxFQUFFQztFQUpKLElBS0ZWLGVBTEo7RUFNQSxNQUFNO0lBRUpLLFlBRkk7SUFJSkUsU0FKSTtJQU1KSSxTQU5JO0lBT0o1QztFQVBJLElBUUZrQyxhQVJKOztFQVNBLElBQUlJLFlBQVksSUFBSUMsZUFBcEIsRUFBcUM7SUFDbkMsSUFBSUEsZUFBZSxDQUFDTSxPQUFoQixNQUE2QlAsWUFBWSxDQUFDTyxPQUFiLEVBQWpDLEVBQXlEO01BQ3ZENUMsZ0JBQU9nQixLQUFQLENBQWMsc0JBQXFCVSxJQUFLLGdDQUErQlcsWUFBYSxFQUFwRjs7TUFDQSxPQUFPdEMsUUFBUDtJQUNEOztJQUNEQyxnQkFBT2dCLEtBQVAsQ0FBYyxzQkFBcUJVLElBQUssNEJBQTJCVyxZQUFhLEVBQWhGOztJQUNBLE9BQU9ILE9BQU8sRUFBZDtFQUNEOztFQUNELElBQUlLLFNBQVMsSUFBSUMsZ0JBQWpCLEVBQW1DO0lBQ2pDeEMsZ0JBQU9nQixLQUFQLENBQWMsc0JBQXFCVSxJQUFLLGVBQXhDOztJQUNBLE9BQU8zQixRQUFQO0VBQ0Q7O0VBQ0QsSUFBSTJDLGFBQWEsSUFBSUMsU0FBckIsRUFBZ0M7SUFDOUIsTUFBTUUsTUFBTSxHQUFHRixTQUFTLEdBQUdELGFBQWEsR0FBRyxJQUE1QixHQUFtQ0ksSUFBSSxDQUFDQyxHQUFMLEVBQWxEOztJQUNBLElBQUlGLE1BQU0sR0FBRyxDQUFiLEVBQWdCO01BQ2Q3QyxnQkFBT2dCLEtBQVAsQ0FBYywyQkFBMEJnQyxjQUFLQyxRQUFMLENBQWNsRCxRQUFkLENBQXdCLG9CQUFtQjhDLE1BQU0sR0FBRyxJQUFLLEdBQWpHOztNQUNBLE9BQU85QyxRQUFQO0lBQ0Q7O0lBQ0RDLGdCQUFPZ0IsS0FBUCxDQUFjLDJCQUEwQmdDLGNBQUtDLFFBQUwsQ0FBY2xELFFBQWQsQ0FBd0IsZUFBaEU7RUFDRDs7RUFDRCxPQUFPbUMsT0FBTyxFQUFkO0FBQ0Q7O0FBRUQsU0FBU2dCLGtCQUFULENBQTZCcEQsR0FBN0IsRUFBa0NxRCxzQkFBbEMsRUFBMEQ7RUFDeEQsSUFBSUEsc0JBQXNCLENBQUNwQyxHQUF2QixDQUEyQm9CLGdCQUFFaUIsT0FBN0IsRUFBc0NDLFFBQXRDLENBQStDbEIsZ0JBQUVpQixPQUFGLENBQVVKLGNBQUtNLE9BQUwsQ0FBYXhELEdBQWIsQ0FBVixDQUEvQyxDQUFKLEVBQWtGO0lBQ2hGLE9BQU9BLEdBQVA7RUFDRDs7RUFDRCxNQUFNLElBQUl5RCxLQUFKLENBQVcsaUJBQWdCekQsR0FBSSxpQkFBckIsR0FDYixHQUFFb0IsY0FBS0MsU0FBTCxDQUFlLFdBQWYsRUFBNEJnQyxzQkFBc0IsQ0FBQ2xDLE1BQW5ELEVBQTJELEtBQTNELENBQWtFLElBRHZELEdBRWRrQyxzQkFGSSxDQUFOO0FBR0Q7O0FBRUQsZUFBZUssd0JBQWYsQ0FBeUNDLFVBQXpDLEVBQXFEO0VBQ25ELE9BQU8sQ0FBQyxNQUFNdkQsWUFBR3dELElBQUgsQ0FBUSxNQUFSLEVBQWdCO0lBQUNDLEdBQUcsRUFBRUYsVUFBTjtJQUFrQkcsTUFBTSxFQUFFLEtBQTFCO0lBQWlDQyxNQUFNLEVBQUU7RUFBekMsQ0FBaEIsQ0FBUCxFQUF3RTVDLE1BQS9FO0FBQ0Q7O0FBRUQsZUFBZTZDLHNCQUFmLENBQXVDQyxRQUF2QyxFQUFpRDtFQUMvQyxPQUFPLE1BQU03RCxZQUFHOEQsSUFBSCxDQUFRRCxRQUFSLENBQWI7QUFDRDs7QUFFRCxlQUFlRSxnQkFBZixDQUFpQ0MsV0FBakMsRUFBOENDLGlCQUFpQixHQUFHLEVBQWxFLEVBQXNFO0VBQ3BFLElBQUksRUFBQyxNQUFNakUsWUFBR2tFLE1BQUgsQ0FBVUYsV0FBVixDQUFQLENBQUosRUFBbUM7SUFDakMsT0FBTyxLQUFQO0VBQ0Q7O0VBU0QsT0FBTyxDQUFDLE1BQU1oRSxZQUFHbUUsSUFBSCxDQUFRSCxXQUFSLENBQVAsRUFBNkJJLFdBQTdCLEtBQ0gsT0FBTWQsd0JBQXdCLENBQUNVLFdBQUQsQ0FBOUIsTUFBK0NDLGlCQUEvQyxhQUErQ0EsaUJBQS9DLHVCQUErQ0EsaUJBQWlCLENBQUVJLE1BQWxFLENBREcsR0FFSCxPQUFNVCxzQkFBc0IsQ0FBQ0ksV0FBRCxDQUE1QixPQUE4Q0MsaUJBQTlDLGFBQThDQSxpQkFBOUMsdUJBQThDQSxpQkFBaUIsQ0FBRUssSUFBakUsQ0FGSjtBQUdEOztBQW9ERCxlQUFlQyxZQUFmLENBQTZCM0UsR0FBN0IsRUFBa0M0RSxPQUFPLEdBQUcsRUFBNUMsRUFBZ0Q7RUFDOUMsSUFBSSxDQUFDdkMsZ0JBQUV3QyxRQUFGLENBQVc3RSxHQUFYLENBQUwsRUFBc0I7SUFFcEI7RUFDRDs7RUFFRCxJQUFJcUQsc0JBQUo7RUFDQSxNQUFNO0lBQ0p5QjtFQURJLElBRUZ6QyxnQkFBRUMsYUFBRixDQUFnQnNDLE9BQWhCLElBQTJCQSxPQUEzQixHQUFxQyxFQUZ6Qzs7RUFHQSxJQUFJdkMsZ0JBQUV3QyxRQUFGLENBQVdELE9BQVgsQ0FBSixFQUF5QjtJQUN2QnZCLHNCQUFzQixHQUFHLENBQUN1QixPQUFELENBQXpCO0VBQ0QsQ0FGRCxNQUVPLElBQUl2QyxnQkFBRTBDLE9BQUYsQ0FBVUgsT0FBVixDQUFKLEVBQXdCO0lBQzdCdkIsc0JBQXNCLEdBQUd1QixPQUF6QjtFQUNELENBRk0sTUFFQSxJQUFJdkMsZ0JBQUVDLGFBQUYsQ0FBZ0JzQyxPQUFoQixDQUFKLEVBQThCO0lBQ25DdkIsc0JBQXNCLEdBQUd1QixPQUFPLENBQUNJLG1CQUFqQztFQUNEOztFQUNELElBQUkzQyxnQkFBRTRDLE9BQUYsQ0FBVTVCLHNCQUFWLENBQUosRUFBdUM7SUFDckMsTUFBTSxJQUFJSSxLQUFKLENBQVcsdURBQVgsQ0FBTjtFQUNEOztFQUVELElBQUl5QixNQUFNLEdBQUdsRixHQUFiO0VBQ0EsSUFBSW1GLGNBQWMsR0FBRyxLQUFyQjtFQUNBLElBQUlDLFdBQVcsR0FBRyxJQUFsQjtFQUNBLElBQUlwRCxPQUFPLEdBQUcsSUFBZDtFQUNBLE1BQU1xRCxjQUFjLEdBQUc7SUFDckI5QyxZQUFZLEVBQUUsSUFETztJQUVyQkUsU0FBUyxFQUFFLEtBRlU7SUFHckJFLE1BQU0sRUFBRTtFQUhhLENBQXZCOztFQUtBLE1BQU07SUFBQzJDLFFBQUQ7SUFBV0M7RUFBWCxJQUF1QjFELGFBQUkyRCxLQUFKLENBQVVOLE1BQVYsQ0FBN0I7O0VBQ0EsTUFBTU8sS0FBSyxHQUFHLENBQUMsT0FBRCxFQUFVLFFBQVYsRUFBb0JsQyxRQUFwQixDQUE2QitCLFFBQTdCLENBQWQ7RUFFQSxNQUFNbkQsYUFBYSxHQUFHekMsa0JBQWtCLENBQUNnRyxHQUFuQixDQUF1QjFGLEdBQXZCLENBQXRCO0VBRUEsT0FBTyxNQUFNTyx3QkFBd0IsQ0FBQ29GLE9BQXpCLENBQWlDM0YsR0FBakMsRUFBc0MsWUFBWTtJQUM3RCxJQUFJeUYsS0FBSixFQUFXO01BRVR2RixnQkFBT0MsSUFBUCxDQUFhLDJCQUEwQitFLE1BQU8sR0FBOUM7O01BQ0FsRCxPQUFPLEdBQUcsTUFBTUwsZUFBZSxDQUFDdUQsTUFBRCxDQUEvQjs7TUFDQSxJQUFJLENBQUM3QyxnQkFBRTRDLE9BQUYsQ0FBVWpELE9BQVYsQ0FBTCxFQUF5QjtRQUN2QixJQUFJQSxPQUFPLENBQUMsZUFBRCxDQUFYLEVBQThCO1VBQzVCcUQsY0FBYyxDQUFDOUMsWUFBZixHQUE4QixJQUFJUyxJQUFKLENBQVNoQixPQUFPLENBQUMsZUFBRCxDQUFoQixDQUE5QjtRQUNEOztRQUNEOUIsZ0JBQU9nQixLQUFQLENBQWMsa0JBQWlCYyxPQUFPLENBQUMsZUFBRCxDQUFrQixFQUF4RDs7UUFDQSxJQUFJQSxPQUFPLENBQUMsZUFBRCxDQUFYLEVBQThCO1VBQzVCcUQsY0FBYyxDQUFDNUMsU0FBZixHQUEyQixpQkFBaUJtRCxJQUFqQixDQUFzQjVELE9BQU8sQ0FBQyxlQUFELENBQTdCLENBQTNCO1VBQ0EsTUFBTTZELFdBQVcsR0FBRyxxQkFBcUJDLElBQXJCLENBQTBCOUQsT0FBTyxDQUFDLGVBQUQsQ0FBakMsQ0FBcEI7O1VBQ0EsSUFBSTZELFdBQUosRUFBaUI7WUFDZlIsY0FBYyxDQUFDMUMsTUFBZixHQUF3Qm9ELFFBQVEsQ0FBQ0YsV0FBVyxDQUFDLENBQUQsQ0FBWixFQUFpQixFQUFqQixDQUFoQztVQUNEO1FBQ0Y7O1FBQ0QzRixnQkFBT2dCLEtBQVAsQ0FBYyxrQkFBaUJjLE9BQU8sQ0FBQyxlQUFELENBQWtCLEVBQXhEO01BQ0Q7O01BQ0QsTUFBTWdFLFVBQVUsR0FBRy9ELHdCQUF3QixDQUFDakMsR0FBRCxFQUFNcUYsY0FBTixFQUFzQmxELGFBQXRCLENBQTNDOztNQUNBLElBQUk2RCxVQUFKLEVBQWdCO1FBQ2QsSUFBSSxNQUFNN0IsZ0JBQWdCLENBQUM2QixVQUFELEVBQWE3RCxhQUFiLGFBQWFBLGFBQWIsdUJBQWFBLGFBQWEsQ0FBRThELFNBQTVCLENBQTFCLEVBQWtFO1VBQ2hFL0YsZ0JBQU9DLElBQVAsQ0FBYSxpREFBZ0Q2RixVQUFXLEdBQXhFOztVQUNBLE9BQU81QyxrQkFBa0IsQ0FBQzRDLFVBQUQsRUFBYTNDLHNCQUFiLENBQXpCO1FBQ0Q7O1FBQ0RuRCxnQkFBT0MsSUFBUCxDQUFhLHVCQUFzQjZGLFVBQVcsMkJBQWxDLEdBQ1Qsd0VBREg7O1FBRUF0RyxrQkFBa0IsQ0FBQ3dHLE1BQW5CLENBQTBCbEcsR0FBMUI7TUFDRDs7TUFFRCxJQUFJbUcsUUFBUSxHQUFHLElBQWY7O01BQ0EsTUFBTWhELFFBQVEsR0FBRy9DLFlBQUdnRyxZQUFILENBQWdCbEQsY0FBS0MsUUFBTCxDQUFja0Qsa0JBQWtCLENBQUNkLFFBQUQsQ0FBaEMsQ0FBaEIsRUFBNkQ7UUFDNUVlLFdBQVcsRUFBRTdGO01BRCtELENBQTdELENBQWpCOztNQUdBLE1BQU0rQyxPQUFPLEdBQUdOLGNBQUtNLE9BQUwsQ0FBYUwsUUFBYixDQUFoQjs7TUFHQSxJQUFJN0QsUUFBUSxDQUFDaUUsUUFBVCxDQUFrQkMsT0FBbEIsQ0FBSixFQUFnQztRQUM5QjJDLFFBQVEsR0FBR2hELFFBQVg7UUFDQWdDLGNBQWMsR0FBRyxJQUFqQjtNQUNEOztNQUNELElBQUluRCxPQUFPLENBQUMsY0FBRCxDQUFYLEVBQTZCO1FBQzNCLE1BQU11RSxFQUFFLEdBQUd2RSxPQUFPLENBQUMsY0FBRCxDQUFsQjs7UUFDQTlCLGdCQUFPZ0IsS0FBUCxDQUFjLGlCQUFnQnFGLEVBQUcsRUFBakM7O1FBRUEsSUFBSWhILGNBQWMsQ0FBQ2lILElBQWYsQ0FBcUJDLFFBQUQsSUFBYyxJQUFJQyxNQUFKLENBQVksTUFBS3JFLGdCQUFFc0UsWUFBRixDQUFlRixRQUFmLENBQXlCLEtBQTFDLEVBQWdEYixJQUFoRCxDQUFxRFcsRUFBckQsQ0FBbEMsQ0FBSixFQUFpRztVQUMvRixJQUFJLENBQUNKLFFBQUwsRUFBZTtZQUNiQSxRQUFRLEdBQUksR0FBRXpGLGdCQUFpQixNQUEvQjtVQUNEOztVQUNEeUUsY0FBYyxHQUFHLElBQWpCO1FBQ0Q7TUFDRjs7TUFDRCxJQUFJbkQsT0FBTyxDQUFDLHFCQUFELENBQVAsSUFBa0MsZUFBZTRELElBQWYsQ0FBb0I1RCxPQUFPLENBQUMscUJBQUQsQ0FBM0IsQ0FBdEMsRUFBMkY7UUFDekY5QixnQkFBT2dCLEtBQVAsQ0FBYyx3QkFBdUJjLE9BQU8sQ0FBQyxxQkFBRCxDQUF3QixFQUFwRTs7UUFDQSxNQUFNNEUsS0FBSyxHQUFHLHFCQUFxQmQsSUFBckIsQ0FBMEI5RCxPQUFPLENBQUMscUJBQUQsQ0FBakMsQ0FBZDs7UUFDQSxJQUFJNEUsS0FBSixFQUFXO1VBQ1RULFFBQVEsR0FBRy9GLFlBQUdnRyxZQUFILENBQWdCUSxLQUFLLENBQUMsQ0FBRCxDQUFyQixFQUEwQjtZQUNuQ04sV0FBVyxFQUFFN0Y7VUFEc0IsQ0FBMUIsQ0FBWDtVQUdBMEUsY0FBYyxHQUFHQSxjQUFjLElBQUk3RixRQUFRLENBQUNpRSxRQUFULENBQWtCTCxjQUFLTSxPQUFMLENBQWEyQyxRQUFiLENBQWxCLENBQW5DO1FBQ0Q7TUFDRjs7TUFDRCxJQUFJLENBQUNBLFFBQUwsRUFBZTtRQUViLE1BQU1VLGFBQWEsR0FBRzFELFFBQVEsR0FDMUJBLFFBQVEsQ0FBQzJELFNBQVQsQ0FBbUIsQ0FBbkIsRUFBc0IzRCxRQUFRLENBQUNoQyxNQUFULEdBQWtCcUMsT0FBTyxDQUFDckMsTUFBaEQsQ0FEMEIsR0FFMUJULGdCQUZKO1FBR0EsSUFBSXFHLFlBQVksR0FBR3ZELE9BQW5COztRQUNBLElBQUksQ0FBQ0gsc0JBQXNCLENBQUNFLFFBQXZCLENBQWdDd0QsWUFBaEMsQ0FBTCxFQUFvRDtVQUNsRDdHLGdCQUFPQyxJQUFQLENBQWEsK0JBQThCNEcsWUFBYSxzQkFBNUMsR0FDVCxrQkFBaUIxRSxnQkFBRTJFLEtBQUYsQ0FBUTNELHNCQUFSLENBQWdDLEdBRHBEOztVQUVBMEQsWUFBWSxHQUFHMUUsZ0JBQUUyRSxLQUFGLENBQVEzRCxzQkFBUixDQUFmO1FBQ0Q7O1FBQ0Q4QyxRQUFRLEdBQUksR0FBRVUsYUFBYyxHQUFFRSxZQUFhLEVBQTNDO01BQ0Q7O01BQ0QsTUFBTUUsVUFBVSxHQUFHLE1BQU1DLGlCQUFRaEUsSUFBUixDQUFhO1FBQ3BDaUUsTUFBTSxFQUFFaEIsUUFENEI7UUFFcENpQixNQUFNLEVBQUU7TUFGNEIsQ0FBYixDQUF6QjtNQUlBbEMsTUFBTSxHQUFHLE1BQU1tQyxXQUFXLENBQUNuQyxNQUFELEVBQVMrQixVQUFULENBQTFCO0lBQ0QsQ0EvRUQsTUErRU8sSUFBSSxNQUFNN0csWUFBR2tFLE1BQUgsQ0FBVVksTUFBVixDQUFWLEVBQTZCO01BRWxDaEYsZ0JBQU9DLElBQVAsQ0FBYSxvQkFBbUIrRSxNQUFPLEdBQXZDOztNQUNBQyxjQUFjLEdBQUc3RixRQUFRLENBQUNpRSxRQUFULENBQWtCTCxjQUFLTSxPQUFMLENBQWEwQixNQUFiLENBQWxCLENBQWpCO0lBQ0QsQ0FKTSxNQUlBO01BQ0wsSUFBSW9DLFlBQVksR0FBSSx1QkFBc0JwQyxNQUFPLHVDQUFqRDs7TUFFQSxJQUFJN0MsZ0JBQUV3QyxRQUFGLENBQVdTLFFBQVgsS0FBd0JBLFFBQVEsQ0FBQ25FLE1BQVQsR0FBa0IsQ0FBOUMsRUFBaUQ7UUFDL0NtRyxZQUFZLEdBQUksaUJBQWdCaEMsUUFBUyxjQUFhSixNQUFPLHNCQUE5QyxHQUNaLCtDQURIO01BRUQ7O01BQ0QsTUFBTSxJQUFJekIsS0FBSixDQUFVNkQsWUFBVixDQUFOO0lBQ0Q7O0lBRUQsTUFBTUMsY0FBYyxHQUFHLENBQUMsTUFBTW5ILFlBQUdtRSxJQUFILENBQVFXLE1BQVIsQ0FBUCxFQUF3QnNDLE1BQXhCLEVBQXZCOztJQUNBLElBQUlELGNBQUosRUFBb0I7TUFDbEJuQyxXQUFXLEdBQUcsTUFBTXBCLHNCQUFzQixDQUFDa0IsTUFBRCxDQUExQztJQUNEOztJQUVELElBQUlxQyxjQUFjLElBQUlwQyxjQUFsQixJQUFvQyxDQUFDOUMsZ0JBQUVvRixVQUFGLENBQWEzQyxhQUFiLENBQXpDLEVBQXNFO01BQ3BFLE1BQU00QyxXQUFXLEdBQUd4QyxNQUFwQjs7TUFDQSxJQUFJRSxXQUFXLE1BQUtqRCxhQUFMLGFBQUtBLGFBQUwsdUJBQUtBLGFBQWEsQ0FBRWlELFdBQXBCLENBQWYsRUFBZ0Q7UUFDOUMsTUFBTTtVQUFDbkY7UUFBRCxJQUFha0MsYUFBbkI7O1FBQ0EsSUFBSSxNQUFNZ0MsZ0JBQWdCLENBQUNsRSxRQUFELEVBQVdrQyxhQUFYLGFBQVdBLGFBQVgsdUJBQVdBLGFBQWEsQ0FBRThELFNBQTFCLENBQTFCLEVBQWdFO1VBQzlELElBQUl5QixXQUFXLEtBQUsxSCxHQUFwQixFQUF5QjtZQUN2QixNQUFNSSxZQUFHQyxNQUFILENBQVVxSCxXQUFWLENBQU47VUFDRDs7VUFDRHhILGdCQUFPQyxJQUFQLENBQWEsZ0RBQStDRixRQUFTLEdBQXJFOztVQUNBLE9BQU9tRCxrQkFBa0IsQ0FBQ25ELFFBQUQsRUFBV29ELHNCQUFYLENBQXpCO1FBQ0Q7O1FBQ0RuRCxnQkFBT0MsSUFBUCxDQUFhLHVCQUFzQkYsUUFBUywyQkFBaEMsR0FDVCwrREFESDs7UUFFQVAsa0JBQWtCLENBQUN3RyxNQUFuQixDQUEwQmxHLEdBQTFCO01BQ0Q7O01BQ0QsTUFBTTJILE9BQU8sR0FBRyxNQUFNVCxpQkFBUVUsT0FBUixFQUF0Qjs7TUFDQSxJQUFJO1FBQ0YxQyxNQUFNLEdBQUcsTUFBTTJDLFFBQVEsQ0FBQ0gsV0FBRCxFQUFjQyxPQUFkLEVBQXVCdEUsc0JBQXZCLENBQXZCO01BQ0QsQ0FGRCxTQUVVO1FBQ1IsSUFBSTZCLE1BQU0sS0FBS3dDLFdBQVgsSUFBMEJBLFdBQVcsS0FBSzFILEdBQTlDLEVBQW1EO1VBQ2pELE1BQU1JLFlBQUdDLE1BQUgsQ0FBVXFILFdBQVYsQ0FBTjtRQUNEO01BQ0Y7O01BQ0R4SCxnQkFBT0MsSUFBUCxDQUFhLDBCQUF5QitFLE1BQU8sR0FBN0M7SUFDRCxDQXhCRCxNQXdCTyxJQUFJLENBQUNoQyxjQUFLNEUsVUFBTCxDQUFnQjVDLE1BQWhCLENBQUwsRUFBOEI7TUFDbkNBLE1BQU0sR0FBR2hDLGNBQUs2RSxPQUFMLENBQWFuSCxPQUFPLENBQUNpRCxHQUFSLEVBQWIsRUFBNEJxQixNQUE1QixDQUFUOztNQUNBaEYsZ0JBQU91QixJQUFQLENBQWEsaUNBQWdDekIsR0FBSSxvQkFBckMsR0FDVCw4QkFBNkJrRixNQUFPLHVEQUR2Qzs7TUFFQWxGLEdBQUcsR0FBR2tGLE1BQU47SUFDRDs7SUFFRCxNQUFNOEMsZUFBZSxHQUFHLE1BQU9DLGNBQVAsSUFBMEI7TUFDaEQsTUFBTUMsY0FBYyxHQUFHL0YsYUFBSCxhQUFHQSxhQUFILHVCQUFHQSxhQUFhLENBQUVsQyxRQUF0Qzs7TUFDQSxJQUFJaUksY0FBYyxJQUFJQSxjQUFjLEtBQUtELGNBQXpDLEVBQXlEO1FBQ3ZELE1BQU03SCxZQUFHQyxNQUFILENBQVU2SCxjQUFWLENBQU47TUFDRDs7TUFDRCxNQUFNakMsU0FBUyxHQUFHLEVBQWxCOztNQUNBLElBQUksQ0FBQyxNQUFNN0YsWUFBR21FLElBQUgsQ0FBUTBELGNBQVIsQ0FBUCxFQUFnQ3pELFdBQWhDLEVBQUosRUFBbUQ7UUFDakR5QixTQUFTLENBQUN4QixNQUFWLEdBQW1CLE1BQU1mLHdCQUF3QixDQUFDdUUsY0FBRCxDQUFqRDtNQUNELENBRkQsTUFFTztRQUNMaEMsU0FBUyxDQUFDdkIsSUFBVixHQUFpQixNQUFNVixzQkFBc0IsQ0FBQ2lFLGNBQUQsQ0FBN0M7TUFDRDs7TUFDRHZJLGtCQUFrQixDQUFDeUksR0FBbkIsQ0FBdUJuSSxHQUF2QixFQUE0QixFQUMxQixHQUFHcUYsY0FEdUI7UUFFMUJ4QyxTQUFTLEVBQUVHLElBQUksQ0FBQ0MsR0FBTCxFQUZlO1FBRzFCbUMsV0FIMEI7UUFJMUJhLFNBSjBCO1FBSzFCaEcsUUFBUSxFQUFFZ0k7TUFMZ0IsQ0FBNUI7TUFPQSxPQUFPQSxjQUFQO0lBQ0QsQ0FuQkQ7O0lBcUJBLElBQUk1RixnQkFBRW9GLFVBQUYsQ0FBYTNDLGFBQWIsQ0FBSixFQUFpQztNQUMvQixNQUFNc0QsTUFBTSxHQUFHLE1BQU10RCxhQUFhLENBQUM7UUFDakMzQyxhQUFhLEVBQUVFLGdCQUFFZ0csS0FBRixDQUFRbEcsYUFBUixDQURrQjtRQUVqQ3NELEtBRmlDO1FBR2pDekQsT0FBTyxFQUFFSyxnQkFBRWdHLEtBQUYsQ0FBUXJHLE9BQVIsQ0FId0I7UUFJakNWLE9BQU8sRUFBRTREO01BSndCLENBQUQsQ0FBbEM7TUFNQSxPQUFRLEVBQUNrRCxNQUFELGFBQUNBLE1BQUQsZUFBQ0EsTUFBTSxDQUFFOUcsT0FBVCxLQUFvQnRCLEdBQUcsTUFBS29JLE1BQUwsYUFBS0EsTUFBTCx1QkFBS0EsTUFBTSxDQUFFOUcsT0FBYixDQUF2QixJQUErQyxFQUFDLE1BQU1sQixZQUFHa0UsTUFBSCxDQUFVOEQsTUFBVixhQUFVQSxNQUFWLHVCQUFVQSxNQUFNLENBQUU5RyxPQUFsQixDQUFQLENBQWhELEdBQ0g0RCxNQURHLEdBRUgsTUFBTThDLGVBQWUsQ0FBQ0ksTUFBTSxDQUFDOUcsT0FBUixDQUZ6QjtJQUdEOztJQUVEOEIsa0JBQWtCLENBQUM4QixNQUFELEVBQVM3QixzQkFBVCxDQUFsQjtJQUNBLE9BQVFyRCxHQUFHLEtBQUtrRixNQUFSLEtBQW1CRSxXQUFXLElBQUkvQyxnQkFBRXJCLE1BQUYsQ0FBU3FFLGNBQVQsRUFBeUJtQixJQUF6QixDQUE4QjhCLE9BQTlCLENBQWxDLENBQUQsR0FDSCxNQUFNTixlQUFlLENBQUM5QyxNQUFELENBRGxCLEdBRUhBLE1BRko7RUFHRCxDQXZLWSxDQUFiO0FBd0tEOztBQUVELGVBQWVtQyxXQUFmLENBQTRCckgsR0FBNUIsRUFBaUNpSCxVQUFqQyxFQUE2QztFQUMzQyxNQUFNO0lBQUNzQjtFQUFELElBQVMxRyxhQUFJMkQsS0FBSixDQUFVeEYsR0FBVixDQUFmOztFQUNBLElBQUk7SUFDRixNQUFNd0ksYUFBSUMsWUFBSixDQUFpQkYsSUFBakIsRUFBdUJ0QixVQUF2QixFQUFtQztNQUN2Q2xGLE9BQU8sRUFBRXBCO0lBRDhCLENBQW5DLENBQU47RUFHRCxDQUpELENBSUUsT0FBTytILEdBQVAsRUFBWTtJQUNaLE1BQU0sSUFBSWpGLEtBQUosQ0FBVywrQkFBOEJpRixHQUFHLENBQUNoSCxPQUFRLEVBQXJELENBQU47RUFDRDs7RUFDRCxPQUFPdUYsVUFBUDtBQUNEOztBQWVELGVBQWVZLFFBQWYsQ0FBeUJjLE9BQXpCLEVBQWtDQyxPQUFsQyxFQUEyQ3ZGLHNCQUEzQyxFQUFtRTtFQUNqRSxNQUFNd0YsYUFBSUMsY0FBSixDQUFtQkgsT0FBbkIsQ0FBTjs7RUFFQSxJQUFJLENBQUN0RyxnQkFBRTBDLE9BQUYsQ0FBVTFCLHNCQUFWLENBQUwsRUFBd0M7SUFDdENBLHNCQUFzQixHQUFHLENBQUNBLHNCQUFELENBQXpCO0VBQ0Q7O0VBRUQsTUFBTXNFLE9BQU8sR0FBRyxNQUFNVCxpQkFBUVUsT0FBUixFQUF0Qjs7RUFDQSxJQUFJO0lBQ0YxSCxnQkFBT2dCLEtBQVAsQ0FBYyxjQUFheUgsT0FBUSxHQUFuQzs7SUFDQSxNQUFNSSxLQUFLLEdBQUcsSUFBSUMsZ0JBQU9DLEtBQVgsR0FBbUJDLEtBQW5CLEVBQWQ7SUFDQSxNQUFNQyxpQkFBaUIsR0FBR3ZJLE9BQU8sQ0FBQ3dJLEdBQVIsQ0FBWUMsMEJBQXRDO0lBQ0EsTUFBTUMsY0FBYyxHQUFHakgsZ0JBQUU0QyxPQUFGLENBQVVrRSxpQkFBVixLQUNsQixDQUFDLENBQUMsR0FBRCxFQUFNLE9BQU4sRUFBZTVGLFFBQWYsQ0FBd0JsQixnQkFBRWlCLE9BQUYsQ0FBVTZGLGlCQUFWLENBQXhCLENBRE47SUFRQSxNQUFNSSxjQUFjLEdBQUc7TUFBQ0Q7SUFBRCxDQUF2Qjs7SUFFQSxJQUFJcEcsY0FBS00sT0FBTCxDQUFhbUYsT0FBYixNQUEwQnRKLE9BQTlCLEVBQXVDO01BQ3JDYSxnQkFBT2dCLEtBQVAsQ0FBYyw2REFBNERnQyxjQUFLQyxRQUFMLENBQWN3RixPQUFkLENBQXVCLEdBQWpHOztNQUNBWSxjQUFjLENBQUNDLGlCQUFmLEdBQW1DLE1BQW5DO0lBQ0Q7O0lBQ0QsTUFBTVgsYUFBSVksWUFBSixDQUFpQmQsT0FBakIsRUFBMEJoQixPQUExQixFQUFtQzRCLGNBQW5DLENBQU47SUFDQSxNQUFNRyxXQUFXLEdBQUksVUFBU3JHLHNCQUFzQixDQUFDcEMsR0FBdkIsQ0FBNEIwSSxHQUFELElBQVNBLEdBQUcsQ0FBQ0MsT0FBSixDQUFZLEtBQVosRUFBbUIsRUFBbkIsQ0FBcEMsRUFBNERDLElBQTVELENBQWlFLEdBQWpFLENBQXNFLEdBQXBHO0lBQ0EsTUFBTUMsaUJBQWlCLEdBQUcsQ0FBQyxNQUFNMUosWUFBR3dELElBQUgsQ0FBUThGLFdBQVIsRUFBcUI7TUFDcEQ3RixHQUFHLEVBQUU4RCxPQUQrQztNQUVwRDdELE1BQU0sRUFBRTtJQUY0QyxDQUFyQixDQUFQLEVBSXRCaUcsSUFKc0IsQ0FJakIsQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLEtBQVVELENBQUMsQ0FBQ0UsS0FBRixDQUFRaEgsY0FBS2lILEdBQWIsRUFBa0JoSixNQUFsQixHQUEyQjhJLENBQUMsQ0FBQ0MsS0FBRixDQUFRaEgsY0FBS2lILEdBQWIsRUFBa0JoSixNQUp0QyxDQUExQjs7SUFLQSxJQUFJa0IsZ0JBQUU0QyxPQUFGLENBQVU2RSxpQkFBVixDQUFKLEVBQWtDO01BQ2hDNUosZ0JBQU9rSyxhQUFQLENBQXNCLCtDQUE4Qy9HLHNCQUF1QixJQUF0RSxHQUNuQmpDLGNBQUtDLFNBQUwsQ0FBZSxRQUFmLEVBQXlCZ0Msc0JBQXNCLENBQUNsQyxNQUFoRCxFQUF3RCxLQUF4RCxDQURtQixHQUVsQixzRUFGa0IsR0FHbEIsSUFBR2tDLHNCQUF1QixLQUFJakMsY0FBS0MsU0FBTCxDQUFlLFdBQWYsRUFBNEJnQyxzQkFBc0IsQ0FBQ2xDLE1BQW5ELEVBQTJELEtBQTNELENBQWtFLEVBSG5HO0lBSUQ7O0lBQ0RqQixnQkFBT2dCLEtBQVAsQ0FBYyxhQUFZRSxjQUFLQyxTQUFMLENBQWUsYUFBZixFQUE4QnlJLGlCQUFpQixDQUFDM0ksTUFBaEQsRUFBd0QsSUFBeEQsQ0FBOEQsR0FBM0UsR0FDVixTQUFRd0gsT0FBUSxRQUFPMEIsSUFBSSxDQUFDQyxLQUFMLENBQVd2QixLQUFLLENBQUN3QixXQUFOLEdBQW9CQyxjQUEvQixDQUErQyxPQUFNVixpQkFBa0IsRUFEakc7O0lBRUEsTUFBTVcsYUFBYSxHQUFHcEksZ0JBQUUyRSxLQUFGLENBQVE4QyxpQkFBUixDQUF0Qjs7SUFDQTVKLGdCQUFPQyxJQUFQLENBQWEsYUFBWXNLLGFBQWMseUJBQXZDOztJQUNBLE1BQU1DLE9BQU8sR0FBR3hILGNBQUs2RSxPQUFMLENBQWFhLE9BQWIsRUFBc0IxRixjQUFLQyxRQUFMLENBQWNzSCxhQUFkLENBQXRCLENBQWhCOztJQUNBLE1BQU1ySyxZQUFHdUssRUFBSCxDQUFNekgsY0FBSzZFLE9BQUwsQ0FBYUosT0FBYixFQUFzQjhDLGFBQXRCLENBQU4sRUFBNENDLE9BQTVDLEVBQXFEO01BQUNFLE1BQU0sRUFBRTtJQUFULENBQXJELENBQU47SUFDQSxPQUFPRixPQUFQO0VBQ0QsQ0F0Q0QsU0FzQ1U7SUFDUixNQUFNdEssWUFBR0MsTUFBSCxDQUFVc0gsT0FBVixDQUFOO0VBQ0Q7QUFDRjs7QUFFRCxTQUFTa0QsaUJBQVQsQ0FBNEI3SyxHQUE1QixFQUFpQztFQUMvQixPQUFRLHVDQUFELENBQTBDNEYsSUFBMUMsQ0FBK0M1RixHQUEvQyxDQUFQO0FBQ0Q7O0FBWUQsU0FBUzhLLGFBQVQsQ0FBd0JDLEtBQXhCLEVBQStCQyxRQUEvQixFQUF5Q0MsU0FBekMsRUFBb0Q7RUFFbEQsSUFBSTVJLGdCQUFFMEMsT0FBRixDQUFVZ0csS0FBVixDQUFKLEVBQXNCO0lBQ3BCLE9BQU9BLEtBQUssQ0FBQzlKLEdBQU4sQ0FBV2lLLElBQUQsSUFBVUosYUFBYSxDQUFDSSxJQUFELEVBQU9GLFFBQVAsRUFBaUJDLFNBQWpCLENBQWpDLENBQVA7RUFDRDs7RUFHRCxJQUFJNUksZ0JBQUVDLGFBQUYsQ0FBZ0J5SSxLQUFoQixDQUFKLEVBQTRCO0lBQzFCLE1BQU1JLFNBQVMsR0FBRyxFQUFsQjs7SUFDQSxLQUFLLElBQUksQ0FBQ0MsR0FBRCxFQUFNQyxLQUFOLENBQVQsSUFBeUJoSixnQkFBRWlKLE9BQUYsQ0FBVVAsS0FBVixDQUF6QixFQUEyQztNQUN6QyxNQUFNUSxzQkFBc0IsR0FBR1QsYUFBYSxDQUFDTyxLQUFELEVBQVFMLFFBQVIsRUFBa0JDLFNBQWxCLENBQTVDOztNQUNBLElBQUlHLEdBQUcsS0FBS0osUUFBWixFQUFzQjtRQUNwQkcsU0FBUyxDQUFDRixTQUFELENBQVQsR0FBdUJNLHNCQUF2QjtNQUNELENBRkQsTUFFTyxJQUFJSCxHQUFHLEtBQUtILFNBQVosRUFBdUI7UUFDNUJFLFNBQVMsQ0FBQ0gsUUFBRCxDQUFULEdBQXNCTyxzQkFBdEI7TUFDRDs7TUFDREosU0FBUyxDQUFDQyxHQUFELENBQVQsR0FBaUJHLHNCQUFqQjtJQUNEOztJQUNELE9BQU9KLFNBQVA7RUFDRDs7RUFHRCxPQUFPSixLQUFQO0FBQ0Q7O0FBUUQsU0FBU1MsY0FBVCxDQUF5QkMsR0FBekIsRUFBOEI7RUFDNUIsSUFBSXBKLGdCQUFFMEMsT0FBRixDQUFVMEcsR0FBVixDQUFKLEVBQW9CO0lBQ2xCLE9BQU9BLEdBQVA7RUFDRDs7RUFFRCxJQUFJQyxVQUFKOztFQUNBLElBQUk7SUFDRkEsVUFBVSxHQUFHQyxJQUFJLENBQUNuRyxLQUFMLENBQVdpRyxHQUFYLENBQWI7O0lBQ0EsSUFBSXBKLGdCQUFFMEMsT0FBRixDQUFVMkcsVUFBVixDQUFKLEVBQTJCO01BQ3pCLE9BQU9BLFVBQVA7SUFDRDtFQUNGLENBTEQsQ0FLRSxPQUFPRSxHQUFQLEVBQVk7SUFDWjFMLGdCQUFPdUIsSUFBUCxDQUFhLDBDQUFiO0VBQ0Q7O0VBQ0QsSUFBSVksZ0JBQUV3QyxRQUFGLENBQVc0RyxHQUFYLENBQUosRUFBcUI7SUFDbkIsT0FBTyxDQUFDQSxHQUFELENBQVA7RUFDRDs7RUFDRCxNQUFNLElBQUloSSxLQUFKLENBQVcsaURBQWdEZ0ksR0FBSSxFQUEvRCxDQUFOO0FBQ0Q7O0FBU0QsU0FBU0ksdUJBQVQsQ0FBa0NDLEdBQWxDLEVBQXVDQyxTQUFTLEdBQUcsSUFBbkQsRUFBeUQ7RUFDdkQsTUFBTUMsWUFBWSxHQUFJLEdBQUVGLEdBQUcsQ0FBQ0csV0FBSixDQUFnQkMsSUFBSyxJQUFHQyxjQUFLQyxXQUFMLENBQWlCTixHQUFqQixFQUFzQmhGLFNBQXRCLENBQWdDLENBQWhDLEVBQW1DLENBQW5DLENBQXNDLEVBQXRGO0VBQ0EsT0FBT2lGLFNBQVMsR0FBSSxHQUFFQyxZQUFhLEtBQUlELFNBQVMsQ0FBQ2pGLFNBQVYsQ0FBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsQ0FBMEIsR0FBakQsR0FBc0RrRixZQUF0RTtBQUNEOztlQUdjO0VBQ2JySCxZQURhO0VBQ0NrRyxpQkFERDtFQUNvQkMsYUFEcEI7RUFDbUNVLGNBRG5DO0VBQ21ESztBQURuRCxDIn0=