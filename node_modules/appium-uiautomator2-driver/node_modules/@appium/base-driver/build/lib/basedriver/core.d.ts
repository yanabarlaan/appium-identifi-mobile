export type Capabilities = import('@appium/types').Capabilities;
export type W3CCapabilities = import('@appium/types').W3CCapabilities;
export type Driver = import('@appium/types').Driver;
export type Core = import('@appium/types').Core;
export type DriverOpts = import('@appium/types').ServerArgs;
export type EventHistory = import('@appium/types').EventHistory;
export type AppiumLogger = import('@appium/types').AppiumLogger;
/**
 * @implements {Core}
 */
export class DriverCore implements Core {
    /**
     * Make the basedriver version available so for any driver which inherits from this package, we
     * know which version of basedriver it inherited from
     */
    static baseVersion: any;
    constructor(opts?: import("@appium/types").ServerArgs, shouldValidateCaps?: boolean);
    /**
    * @type {string?}
    */
    sessionId: string | null;
    /**
    * @type {DriverOpts & Capabilities}
    */
    opts: import("@appium/types").ServerArgs & Partial<import("@wdio/types/build/Capabilities").Capabilities & import("@wdio/types/build/Capabilities").AppiumCapabilities & {
        [x: string]: any;
    }>;
    /**
    * @type {DriverOpts}
    */
    initialOpts: DriverOpts;
    /**
    * @type {Capabilities}
    */
    caps: Capabilities;
    /**
    * @type {W3CCapabilities}
    */
    originalCaps: W3CCapabilities;
    helpers: import("@appium/types").DriverHelpers;
    /**
    * basePath is used for several purposes, for example in setting up
    * proxying to other drivers, since we need to know what the base path
    * of any incoming request might look like. We set it to the default
    * initially but it is automatically updated during any actual program
    * execution by the routeConfiguringFunction, which is necessarily run as
    * the entrypoint for any Appium server
    */
    basePath: string;
    relaxedSecurityEnabled: boolean;
    /** @type {string[]} */
    allowInsecure: string[];
    /** @type {string[]} */
    denyInsecure: string[];
    newCommandTimeoutMs: number;
    implicitWaitMs: number;
    /** @type {string[]} */
    locatorStrategies: string[];
    /** @type {string[]} */
    webLocatorStrategies: string[];
    /** @type {Driver[]} */
    managedDrivers: Driver[];
    /** @type {NodeJS.Timeout?} */
    noCommandTimer: NodeJS.Timeout | null;
    /** @type {EventHistory} */
    _eventHistory: EventHistory;
    _constraints: import("@appium/types").Constraints;
    /** @type {NodeJS.EventEmitter} */
    eventEmitter: NodeJS.EventEmitter;
    /**
    * @type {AppiumLogger}
    */
    _log: AppiumLogger;
    /**
    * @protected
    */
    protected shutdownUnexpectedly: boolean;
    /**
    * @type {boolean}
    * @protected
    */
    protected shouldValidateCaps: boolean;
    /**
    * @protected
    */
    protected commandsQueueGuard: AsyncLock;
    /**
    * settings should be instantiated by drivers which extend BaseDriver, but
    * we set it to an empty DeviceSettings instance here to make sure that the
    * default settings are applied even if an extending driver doesn't utilize
    * the settings functionality itself
    */
    settings: DeviceSettings<Record<string, unknown>>;
    get log(): import("@appium/types").AppiumLogger;
    /**
    * Set a callback handler if needed to execute a custom piece of code
    * when the driver is shut down unexpectedly. Multiple calls to this method
    * will cause the handler to be executed mutiple times
    *
    * @param {(...args: any[]) => void} handler The code to be executed on unexpected shutdown.
    * The function may accept one argument, which is the actual error instance, which
    * caused the driver to shut down.
    */
    onUnexpectedShutdown(handler: (...args: any[]) => void): void;
    /**
    * This property is used by AppiumDriver to store the data of the
    * specific driver sessions. This data can be later used to adjust
    * properties for driver instances running in parallel.
    * Override it in inherited driver classes if necessary.
    *
    * @return {Record<string,unknown>} Driver properties mapping
    */
    get driverData(): Record<string, unknown>;
    /**
    * This property controls the way {#executeCommand} method
    * handles new driver commands received from the client.
    * Override it for inherited classes only in special cases.
    *
    * @return {boolean} If the returned value is true (default) then all the commands
    *   received by the particular driver instance are going to be put into the queue,
    *   so each following command will not be executed until the previous command
    *   execution is completed. False value disables that queue, so each driver command
    *   is executed independently and does not wait for anything.
    */
    get isCommandsQueueEnabled(): boolean;
    get eventHistory(): import("@appium/types").EventHistory;
    /**
    * API method for driver developers to log timings for important events
    * @param {string} eventName
    */
    logEvent(eventName: string): void;
    /**
    * Overridden in appium driver, but here so that individual drivers can be
    * tested with clients that poll
    */
    getStatus(): Promise<{}>;
    set desiredCapConstraints(arg: import("@appium/types").Constraints);
    get desiredCapConstraints(): import("@appium/types").Constraints;
    /**
    * method required by MJSONWP in order to determine whether it should
    * respond with an invalid session response
    * @param {string} [sessionId]
    * @returns {boolean}
    */
    sessionExists(sessionId?: string | undefined): boolean;
    /**
    * method required by MJSONWP in order to determine if the command should
    * be proxied directly to the driver
    * @param {string} sessionId
    * @returns {this | import('@appium/types').Driver}
    */
    driverForSession(sessionId: string): import("@appium/types").Driver | DriverCore;
    /**
    *
    * @param {Capabilities} caps
    */
    logExtraCaps(caps: Partial<import("@wdio/types/build/Capabilities").Capabilities & import("@wdio/types/build/Capabilities").AppiumCapabilities & {
        [x: string]: any;
    }>): void;
    /**
    *
    * @param {Capabilities} caps
    * @returns {boolean}
    */
    validateDesiredCaps(caps: Capabilities): boolean;
    isMjsonwpProtocol(): boolean;
    isW3CProtocol(): boolean;
    setProtocolMJSONWP(): void;
    protocol: string | undefined;
    setProtocolW3C(): void;
    /**
    * Check whether a given feature is enabled via its name
    *
    * @param {string} name - name of feature/command
    *
    * @returns {Boolean}
    */
    isFeatureEnabled(name: string): boolean;
    /**
    * Assert that a given feature is enabled and throw a helpful error if it's
    * not
    *
    * @param {string} name - name of feature/command
    */
    ensureFeatureEnabled(name: string): void;
    /**
    *
    * @param {string} strategy
    * @param {boolean} [webContext]
    */
    validateLocatorStrategy(strategy: string, webContext?: boolean | undefined): void;
    /**
    *
    * @param {string} [sessionId]
    * @returns {boolean}
    */
    proxyActive(sessionId?: string | undefined): boolean;
    /**
    *
    * @param {string} sessionId
    * @returns {[string, RegExp][]}
    */
    getProxyAvoidList(sessionId: string): [string, RegExp][];
    /**
    *
    * @param {string} [sessionId]
    * @returns {boolean}
    */
    canProxy(sessionId?: string | undefined): boolean;
    /**
    * Whether a given command route (expressed as method and url) should not be
    * proxied according to this driver
    *
    * @param {string} sessionId - the current sessionId (in case the driver runs
    * multiple session ids and requires it). This is not used in this method but
    * should be made available to overridden methods.
    * @param {import('@appium/types').HTTPMethod} method - HTTP method of the route
    * @param {string} url - url of the route
    * @param {any} [body] - webdriver request body
    *
    * @returns {boolean} - whether the route should be avoided
    */
    proxyRouteIsAvoided(sessionId: string, method: import('@appium/types').HTTPMethod, url: string, body?: any): boolean;
    /**
    *
    * @param {Driver} driver
    */
    addManagedDriver(driver: Driver): void;
    getManagedDrivers(): import("@appium/types").Driver[];
    clearNewCommandTimeout(): Promise<void>;
}
import { EventEmitter } from "events";
import AsyncLock from "async-lock";
import DeviceSettings from "./device-settings";
//# sourceMappingURL=core.d.ts.map